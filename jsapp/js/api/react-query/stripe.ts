/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { CheckoutLink } from '../models/checkoutLink'

import type { ErrorDetail } from '../models/errorDetail'

import type { OneTimeAddOn } from '../models/oneTimeAddOn'

import type { PaginatedOneTimeAddOnList } from '../models/paginatedOneTimeAddOnList'

import type { PaginatedProductList } from '../models/paginatedProductList'

import type { PaginatedSubscriptionList } from '../models/paginatedSubscriptionList'

import type { StripeAddonsListParams } from '../models/stripeAddonsListParams'

import type { StripeProductsListParams } from '../models/stripeProductsListParams'

import type { StripeSubscriptionsListParams } from '../models/stripeSubscriptionsListParams'

import type { Subscription } from '../models/subscription'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Lists the one-time add-ons for the authenticated user's organization.
 */
export type stripeAddonsListResponse200 = {
  data: PaginatedOneTimeAddOnList
  status: 200
}

export type stripeAddonsListResponseComposite = stripeAddonsListResponse200

export type stripeAddonsListResponse = stripeAddonsListResponseComposite & {
  headers: Headers
}

export const getStripeAddonsListUrl = (params?: StripeAddonsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/stripe/addons/?${stringifiedParams}` : `/api/v2/stripe/addons/`
}

export const stripeAddonsList = async (
  params?: StripeAddonsListParams,
  options?: RequestInit,
): Promise<stripeAddonsListResponse> => {
  return fetchWithAuth<stripeAddonsListResponse>(getStripeAddonsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getStripeAddonsListQueryKey = (params?: StripeAddonsListParams) => {
  return ['api', 'v2', 'stripe', 'addons', ...(params ? [params] : [])] as const
}

export const getStripeAddonsListQueryOptions = <TData = Awaited<ReturnType<typeof stripeAddonsList>>, TError = unknown>(
  params?: StripeAddonsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeAddonsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStripeAddonsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof stripeAddonsList>>> = ({ signal }) =>
    stripeAddonsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof stripeAddonsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type StripeAddonsListQueryResult = NonNullable<Awaited<ReturnType<typeof stripeAddonsList>>>
export type StripeAddonsListQueryError = unknown

export function useStripeAddonsList<TData = Awaited<ReturnType<typeof stripeAddonsList>>, TError = unknown>(
  params?: StripeAddonsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeAddonsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getStripeAddonsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Lists the one-time add-ons for the authenticated user's organization.
 */
export type stripeAddonsRetrieveResponse200 = {
  data: OneTimeAddOn
  status: 200
}

export type stripeAddonsRetrieveResponseComposite = stripeAddonsRetrieveResponse200

export type stripeAddonsRetrieveResponse = stripeAddonsRetrieveResponseComposite & {
  headers: Headers
}

export const getStripeAddonsRetrieveUrl = (id: string) => {
  return `/api/v2/stripe/addons/${id}/`
}

export const stripeAddonsRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<stripeAddonsRetrieveResponse> => {
  return fetchWithAuth<stripeAddonsRetrieveResponse>(getStripeAddonsRetrieveUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getStripeAddonsRetrieveQueryKey = (id: string) => {
  return ['api', 'v2', 'stripe', 'addons', id] as const
}

export const getStripeAddonsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof stripeAddonsRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeAddonsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStripeAddonsRetrieveQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof stripeAddonsRetrieve>>> = ({ signal }) =>
    stripeAddonsRetrieve(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof stripeAddonsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type StripeAddonsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof stripeAddonsRetrieve>>>
export type StripeAddonsRetrieveQueryError = unknown

export function useStripeAddonsRetrieve<TData = Awaited<ReturnType<typeof stripeAddonsRetrieve>>, TError = unknown>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeAddonsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getStripeAddonsRetrieveQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export type stripeCheckoutLinkCreateResponse200 = {
  data: CheckoutLink
  status: 200
}

export type stripeCheckoutLinkCreateResponseComposite = stripeCheckoutLinkCreateResponse200

export type stripeCheckoutLinkCreateResponse = stripeCheckoutLinkCreateResponseComposite & {
  headers: Headers
}

export const getStripeCheckoutLinkCreateUrl = () => {
  return `/api/v2/stripe/checkout-link`
}

export const stripeCheckoutLinkCreate = async (
  checkoutLink: CheckoutLink,
  options?: RequestInit,
): Promise<stripeCheckoutLinkCreateResponse> => {
  return fetchWithAuth<stripeCheckoutLinkCreateResponse>(getStripeCheckoutLinkCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(checkoutLink),
  })
}

export const getStripeCheckoutLinkCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stripeCheckoutLinkCreate>>,
    TError,
    { data: CheckoutLink },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof stripeCheckoutLinkCreate>>,
  TError,
  { data: CheckoutLink },
  TContext
> => {
  const mutationKey = ['stripeCheckoutLinkCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof stripeCheckoutLinkCreate>>, { data: CheckoutLink }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return stripeCheckoutLinkCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type StripeCheckoutLinkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof stripeCheckoutLinkCreate>>>
export type StripeCheckoutLinkCreateMutationBody = CheckoutLink
export type StripeCheckoutLinkCreateMutationError = unknown

export const useStripeCheckoutLinkCreate = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stripeCheckoutLinkCreate>>,
    TError,
    { data: CheckoutLink },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getStripeCheckoutLinkCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Returns Product and Price Lists, sorted from the product with the lowest price to highest
<strong>This endpoint is cached for an amount of time determined by ENDPOINT_CACHE_DURATION</strong>

<pre class="prettyprint">
<b>GET</b> /api/v2/stripe/products/
</pre>

> Example
>
>       curl -X GET https://[kpi]/api/v2/stripe/products/

> Response
>
>       HTTP 200 Ok
>        {
>           "count": ...
>           "next": ...
>           "previous": ...
>           "results": [
>               {
>                   "id": string,
>                   "name": string,
>                   "type": string,
>                   "prices": [
>                       {
>                           "id": string,
>                           "nickname": string,
>                           "currency": string,
>                           "type": string,
>                           "recurring": {
>                               "aggregate_usage": string ('sum', 'last_during_period`, `last_ever`, `max`)
>                               "interval": string ('month', 'year', 'week', 'day')
>                               "interval_count": int,
>                               "usage_type": string ('metered', 'licensed')
>                           },
>                           "unit_amount": int (cents),
>                           "human_readable_price": string,
>                           "metadata": {},
>                           "active": bool,
>                           "product": string,
>                           "transform_quantity": null | {'round': 'up'|'down', 'divide_by': int}
>                       },
>                       ...
>                   ],
>                   "metadata": {},
>               },
>               ...
>           ]
>        }
>

### Note: unit_amount is price in cents (assuming currency is USD/AUD/CAD/etc.)

## Current Endpoint
 */
export type stripeProductsListResponse200 = {
  data: PaginatedProductList
  status: 200
}

export type stripeProductsListResponseComposite = stripeProductsListResponse200

export type stripeProductsListResponse = stripeProductsListResponseComposite & {
  headers: Headers
}

export const getStripeProductsListUrl = (params?: StripeProductsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/stripe/products/?${stringifiedParams}` : `/api/v2/stripe/products/`
}

export const stripeProductsList = async (
  params?: StripeProductsListParams,
  options?: RequestInit,
): Promise<stripeProductsListResponse> => {
  return fetchWithAuth<stripeProductsListResponse>(getStripeProductsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getStripeProductsListQueryKey = (params?: StripeProductsListParams) => {
  return ['api', 'v2', 'stripe', 'products', ...(params ? [params] : [])] as const
}

export const getStripeProductsListQueryOptions = <
  TData = Awaited<ReturnType<typeof stripeProductsList>>,
  TError = unknown,
>(
  params?: StripeProductsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeProductsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStripeProductsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof stripeProductsList>>> = ({ signal }) =>
    stripeProductsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof stripeProductsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type StripeProductsListQueryResult = NonNullable<Awaited<ReturnType<typeof stripeProductsList>>>
export type StripeProductsListQueryError = unknown

export function useStripeProductsList<TData = Awaited<ReturnType<typeof stripeProductsList>>, TError = unknown>(
  params?: StripeProductsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeProductsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getStripeProductsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export type stripeSubscriptionsListResponse200 = {
  data: PaginatedSubscriptionList
  status: 200
}

export type stripeSubscriptionsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type stripeSubscriptionsListResponseComposite =
  | stripeSubscriptionsListResponse200
  | stripeSubscriptionsListResponse401

export type stripeSubscriptionsListResponse = stripeSubscriptionsListResponseComposite & {
  headers: Headers
}

export const getStripeSubscriptionsListUrl = (params?: StripeSubscriptionsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/stripe/subscriptions/?${stringifiedParams}`
    : `/api/v2/stripe/subscriptions/`
}

export const stripeSubscriptionsList = async (
  params?: StripeSubscriptionsListParams,
  options?: RequestInit,
): Promise<stripeSubscriptionsListResponse> => {
  return fetchWithAuth<stripeSubscriptionsListResponse>(getStripeSubscriptionsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getStripeSubscriptionsListQueryKey = (params?: StripeSubscriptionsListParams) => {
  return ['api', 'v2', 'stripe', 'subscriptions', ...(params ? [params] : [])] as const
}

export const getStripeSubscriptionsListQueryOptions = <
  TData = Awaited<ReturnType<typeof stripeSubscriptionsList>>,
  TError = ErrorDetail,
>(
  params?: StripeSubscriptionsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeSubscriptionsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStripeSubscriptionsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof stripeSubscriptionsList>>> = ({ signal }) =>
    stripeSubscriptionsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof stripeSubscriptionsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type StripeSubscriptionsListQueryResult = NonNullable<Awaited<ReturnType<typeof stripeSubscriptionsList>>>
export type StripeSubscriptionsListQueryError = ErrorDetail

export function useStripeSubscriptionsList<
  TData = Awaited<ReturnType<typeof stripeSubscriptionsList>>,
  TError = ErrorDetail,
>(
  params?: StripeSubscriptionsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeSubscriptionsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getStripeSubscriptionsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export type stripeSubscriptionsRetrieveResponse200 = {
  data: Subscription
  status: 200
}

export type stripeSubscriptionsRetrieveResponseComposite = stripeSubscriptionsRetrieveResponse200

export type stripeSubscriptionsRetrieveResponse = stripeSubscriptionsRetrieveResponseComposite & {
  headers: Headers
}

export const getStripeSubscriptionsRetrieveUrl = (id: string) => {
  return `/api/v2/stripe/subscriptions/${id}/`
}

export const stripeSubscriptionsRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<stripeSubscriptionsRetrieveResponse> => {
  return fetchWithAuth<stripeSubscriptionsRetrieveResponse>(getStripeSubscriptionsRetrieveUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getStripeSubscriptionsRetrieveQueryKey = (id: string) => {
  return ['api', 'v2', 'stripe', 'subscriptions', id] as const
}

export const getStripeSubscriptionsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof stripeSubscriptionsRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeSubscriptionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStripeSubscriptionsRetrieveQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof stripeSubscriptionsRetrieve>>> = ({ signal }) =>
    stripeSubscriptionsRetrieve(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof stripeSubscriptionsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type StripeSubscriptionsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof stripeSubscriptionsRetrieve>>
>
export type StripeSubscriptionsRetrieveQueryError = unknown

export function useStripeSubscriptionsRetrieve<
  TData = Awaited<ReturnType<typeof stripeSubscriptionsRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof stripeSubscriptionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getStripeSubscriptionsRetrieveQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
