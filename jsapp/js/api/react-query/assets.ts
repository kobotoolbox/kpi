/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { Asset } from '../models/asset'

import type { AssetBulkRequest } from '../models/assetBulkRequest'

import type { AssetBulkResponse } from '../models/assetBulkResponse'

import type { AssetCreateRequest } from '../models/assetCreateRequest'

import type { AssetMetadataResponse } from '../models/assetMetadataResponse'

import type { AssetValidContentResponse } from '../models/assetValidContentResponse'

import type { AssetsCountsListParams } from '../models/assetsCountsListParams'

import type { AssetsListParams } from '../models/assetsListParams'

import type { AssetsRetrieveParams } from '../models/assetsRetrieveParams'

import type { ContentResponse } from '../models/contentResponse'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { HashResponse } from '../models/hashResponse'

import type { PaginatedAssetCountResponseList } from '../models/paginatedAssetCountResponseList'

import type { PaginatedAssetList } from '../models/paginatedAssetList'

import type { PatchedAssetPatchRequest } from '../models/patchedAssetPatchRequest'

import type { ReportResponse } from '../models/reportResponse'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## Get user's assets


Search can be made with `q` parameter.
Search filters can be returned with results by passing `metadata=on` to querystring.


Results can be sorted with `ordering` parameter, e.g.:

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/?ordering=-name
```


Allowed fields are:

- `asset_type`
- `date_modified`
- `date_deployed`
- `date_modified__date`
- `date_deployed__date`
- `name`
- `settings__sector`
- `settings__sector__value`
- `settings__description`
- `owner__username`
- `owner__extra_details__data__name`
- `owner__extra_details__data__organization`
- `owner__email`
- `_deployment_status`
- `subscribers_count`


Note: Collections can be displayed first with parameter `collections_first`, e.g.:

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/?collections_first=true&ordering=-name
```

 */
export type assetsListResponse200 = {
  data: PaginatedAssetList
  status: 200
}

export type assetsListResponseComposite = assetsListResponse200

export type assetsListResponse = assetsListResponseComposite & {
  headers: Headers
}

export const getAssetsListUrl = (params?: AssetsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/assets/?${stringifiedParams}` : `/api/v2/assets/`
}

export const assetsList = async (params?: AssetsListParams, options?: RequestInit): Promise<assetsListResponse> => {
  return fetchWithAuth<assetsListResponse>(getAssetsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsListQueryKey = (params?: AssetsListParams) => {
  return ['api', 'v2', 'assets', ...(params ? [params] : [])] as const
}

export const getAssetsListQueryOptions = <TData = Awaited<ReturnType<typeof assetsList>>, TError = unknown>(
  params?: AssetsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsList>>> = ({ signal }) =>
    assetsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsList>>>
export type AssetsListQueryError = unknown

export function useAssetsList<TData = Awaited<ReturnType<typeof assetsList>>, TError = unknown>(
  params?: AssetsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create or clone an asset

When cloning an asset, you must provide:

- the name (as a string),
- the `clone_from` (the uid representing the asset),
- the asset_type

Where `asset_type` must be one of these values:

* block (can be cloned to `block`, `question`, `survey`, `template`)
* question (can be cloned to `question`, `survey`, `template`)
* survey (can be cloned to `block`, `question`, `survey`, `template`)
* template (can be cloned to `survey`, `template`)

Settings are cloned only when type of assets are `survey` or `template`.
In that case, `share-metadata` is not preserved.

When creating a new `block` or `question` asset, settings are not saved either.

 */
export type assetsCreateResponse201 = {
  data: Asset
  status: 201
}

export type assetsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsCreateResponseComposite = assetsCreateResponse201 | assetsCreateResponse400 | assetsCreateResponse401

export type assetsCreateResponse = assetsCreateResponseComposite & {
  headers: Headers
}

export const getAssetsCreateUrl = () => {
  return `/api/v2/assets/`
}

export const assetsCreate = async (
  assetCreateRequest: AssetCreateRequest,
  options?: RequestInit,
): Promise<assetsCreateResponse> => {
  return fetchWithAuth<assetsCreateResponse>(getAssetsCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(assetCreateRequest),
  })
}

export const getAssetsCreateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsCreate>>,
    TError,
    { data: AssetCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof assetsCreate>>, TError, { data: AssetCreateRequest }, TContext> => {
  const mutationKey = ['assetsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsCreate>>, { data: AssetCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return assetsCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsCreate>>>
export type AssetsCreateMutationBody = AssetCreateRequest
export type AssetsCreateMutationError = ErrorObject | ErrorDetail

export const useAssetsCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsCreate>>,
    TError,
    { data: AssetCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Count the daily amount of submission

Returns up to the last 31 days of daily counts and total counts of submissions to a survey.


Use the `days` query to get the daily counts from the last x amount of days.
Default amount is 30 days


```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/counts/?days=7
```

 */
export type assetsCountsListResponse200 = {
  data: PaginatedAssetCountResponseList
  status: 200
}

export type assetsCountsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsCountsListResponseComposite = assetsCountsListResponse200 | assetsCountsListResponse401

export type assetsCountsListResponse = assetsCountsListResponseComposite & {
  headers: Headers
}

export const getAssetsCountsListUrl = (parentLookupAsset: string, params?: AssetsCountsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${parentLookupAsset}/counts/?${stringifiedParams}`
    : `/api/v2/assets/${parentLookupAsset}/counts/`
}

export const assetsCountsList = async (
  parentLookupAsset: string,
  params?: AssetsCountsListParams,
  options?: RequestInit,
): Promise<assetsCountsListResponse> => {
  return fetchWithAuth<assetsCountsListResponse>(getAssetsCountsListUrl(parentLookupAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsCountsListQueryKey = (parentLookupAsset: string, params?: AssetsCountsListParams) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'counts', ...(params ? [params] : [])] as const
}

export const getAssetsCountsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsCountsList>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  params?: AssetsCountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsCountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsCountsListQueryKey(parentLookupAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsCountsList>>> = ({ signal }) =>
    assetsCountsList(parentLookupAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!parentLookupAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsCountsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsCountsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsCountsList>>>
export type AssetsCountsListQueryError = ErrorDetail

export function useAssetsCountsList<TData = Awaited<ReturnType<typeof assetsCountsList>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  params?: AssetsCountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsCountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsCountsListQueryOptions(parentLookupAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get a user's current asset

 */
export type assetsRetrieveResponse200 = {
  data: Asset
  status: 200
}

export type assetsRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsRetrieveResponseComposite = assetsRetrieveResponse200 | assetsRetrieveResponse404

export type assetsRetrieveResponse = assetsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsRetrieveUrl = (uid: string, params?: AssetsRetrieveParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/assets/${uid}/?${stringifiedParams}` : `/api/v2/assets/${uid}/`
}

export const assetsRetrieve = async (
  uid: string,
  params?: AssetsRetrieveParams,
  options?: RequestInit,
): Promise<assetsRetrieveResponse> => {
  return fetchWithAuth<assetsRetrieveResponse>(getAssetsRetrieveUrl(uid, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsRetrieveQueryKey = (uid: string, params?: AssetsRetrieveParams) => {
  return ['api', 'v2', 'assets', uid, ...(params ? [params] : [])] as const
}

export const getAssetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof assetsRetrieve>>, TError = ErrorDetail>(
  uid: string,
  params?: AssetsRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsRetrieveQueryKey(uid, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsRetrieve>>> = ({ signal }) =>
    assetsRetrieve(uid, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsRetrieve>>>
export type AssetsRetrieveQueryError = ErrorDetail

export function useAssetsRetrieve<TData = Awaited<ReturnType<typeof assetsRetrieve>>, TError = ErrorDetail>(
  uid: string,
  params?: AssetsRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsRetrieveQueryOptions(uid, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update or connect a user's asset

Updates a project or connect project's data from this project to other projects

When `Data sharing`:

`fields`: Optional. List of questions whose responses will be shared. If
missing or empty, all responses will be shared. Questions must be
identified by full group path separated by slashes, e.g.
`group/subgroup/question_name`.

 */
export type assetsPartialUpdateResponse200 = {
  data: Asset
  status: 200
}

export type assetsPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsPartialUpdateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsPartialUpdateResponseComposite =
  | assetsPartialUpdateResponse200
  | assetsPartialUpdateResponse400
  | assetsPartialUpdateResponse401

export type assetsPartialUpdateResponse = assetsPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsPartialUpdateUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/`
}

export const assetsPartialUpdate = async (
  uid: string,
  patchedAssetPatchRequest: PatchedAssetPatchRequest,
  options?: RequestInit,
): Promise<assetsPartialUpdateResponse> => {
  return fetchWithAuth<assetsPartialUpdateResponse>(getAssetsPartialUpdateUrl(uid), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedAssetPatchRequest),
  })
}

export const getAssetsPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPartialUpdate>>,
    TError,
    { uid: string; data: PatchedAssetPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPartialUpdate>>,
  TError,
  { uid: string; data: PatchedAssetPatchRequest },
  TContext
> => {
  const mutationKey = ['assetsPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPartialUpdate>>,
    { uid: string; data: PatchedAssetPatchRequest }
  > = (props) => {
    const { uid, data } = props ?? {}

    return assetsPartialUpdate(uid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsPartialUpdate>>>
export type AssetsPartialUpdateMutationBody = PatchedAssetPatchRequest
export type AssetsPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useAssetsPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPartialUpdate>>,
    TError,
    { uid: string; data: PatchedAssetPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete a user's asset

 */
export type assetsDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDestroyResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsDestroyResponseComposite = assetsDestroyResponse204 | assetsDestroyResponse401

export type assetsDestroyResponse = assetsDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDestroyUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/`
}

export const assetsDestroy = async (uid: string, options?: RequestInit): Promise<assetsDestroyResponse> => {
  return fetchWithAuth<assetsDestroyResponse>(getAssetsDestroyUrl(uid), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof assetsDestroy>>, TError, { uid: string }, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof assetsDestroy>>, TError, { uid: string }, TContext> => {
  const mutationKey = ['assetsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsDestroy>>, { uid: string }> = (props) => {
    const { uid } = props ?? {}

    return assetsDestroy(uid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDestroy>>>

export type AssetsDestroyMutationError = ErrorDetail

export const useAssetsDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof assetsDestroy>>, TError, { uid: string }, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Return the content of a user's asset.

 */
export type assetsContentRetrieveResponse200 = {
  data: ContentResponse
  status: 200
}

export type assetsContentRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsContentRetrieveResponseComposite = assetsContentRetrieveResponse200 | assetsContentRetrieveResponse404

export type assetsContentRetrieveResponse = assetsContentRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsContentRetrieveUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/content/`
}

export const assetsContentRetrieve = async (
  uid: string,
  options?: RequestInit,
): Promise<assetsContentRetrieveResponse> => {
  return fetchWithAuth<assetsContentRetrieveResponse>(getAssetsContentRetrieveUrl(uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsContentRetrieveQueryKey = (uid: string) => {
  return ['api', 'v2', 'assets', uid, 'content'] as const
}

export const getAssetsContentRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsContentRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsContentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsContentRetrieveQueryKey(uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsContentRetrieve>>> = ({ signal }) =>
    assetsContentRetrieve(uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsContentRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsContentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsContentRetrieve>>>
export type AssetsContentRetrieveQueryError = ErrorDetail

export function useAssetsContentRetrieve<
  TData = Awaited<ReturnType<typeof assetsContentRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsContentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsContentRetrieveQueryOptions(uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Report of a user's asset

Returns the submission data for all deployments of a survey.
This data is grouped by answers, and does not show the data for individual submissions.
The endpoint will return a **404 NOT FOUND** error if the asset is not deployed and will only return the data for the most recently deployed version.

 */
export type assetsReportsRetrieveResponse200 = {
  data: ReportResponse
  status: 200
}

export type assetsReportsRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsReportsRetrieveResponseComposite = assetsReportsRetrieveResponse200 | assetsReportsRetrieveResponse404

export type assetsReportsRetrieveResponse = assetsReportsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsReportsRetrieveUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/reports/`
}

export const assetsReportsRetrieve = async (
  uid: string,
  options?: RequestInit,
): Promise<assetsReportsRetrieveResponse> => {
  return fetchWithAuth<assetsReportsRetrieveResponse>(getAssetsReportsRetrieveUrl(uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsReportsRetrieveQueryKey = (uid: string) => {
  return ['api', 'v2', 'assets', uid, 'reports'] as const
}

export const getAssetsReportsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsReportsRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsReportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsReportsRetrieveQueryKey(uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsReportsRetrieve>>> = ({ signal }) =>
    assetsReportsRetrieve(uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsReportsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsReportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsReportsRetrieve>>>
export type AssetsReportsRetrieveQueryError = ErrorDetail

export function useAssetsReportsRetrieve<
  TData = Awaited<ReturnType<typeof assetsReportsRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsReportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsReportsRetrieveQueryOptions(uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Return plain HTML of survey in tabular format

 */
export type assetsTableViewRetrieveResponse200 = {
  data: string
  status: 200
}

export type assetsTableViewRetrieveResponse404 = {
  data: void
  status: 404
}

export type assetsTableViewRetrieveResponseComposite =
  | assetsTableViewRetrieveResponse200
  | assetsTableViewRetrieveResponse404

export type assetsTableViewRetrieveResponse = assetsTableViewRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsTableViewRetrieveUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/table_view/`
}

export const assetsTableViewRetrieve = async (
  uid: string,
  options?: RequestInit,
): Promise<assetsTableViewRetrieveResponse> => {
  return fetchWithAuth<assetsTableViewRetrieveResponse>(getAssetsTableViewRetrieveUrl(uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsTableViewRetrieveQueryKey = (uid: string) => {
  return ['api', 'v2', 'assets', uid, 'table_view'] as const
}

export const getAssetsTableViewRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsTableViewRetrieve>>,
  TError = void,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsTableViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsTableViewRetrieveQueryKey(uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsTableViewRetrieve>>> = ({ signal }) =>
    assetsTableViewRetrieve(uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsTableViewRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsTableViewRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsTableViewRetrieve>>>
export type AssetsTableViewRetrieveQueryError = void

export function useAssetsTableViewRetrieve<TData = Awaited<ReturnType<typeof assetsTableViewRetrieve>>, TError = void>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsTableViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsTableViewRetrieveQueryOptions(uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Return valid content for user's asset

 */
export type assetsValidContentRetrieveResponse200 = {
  data: AssetValidContentResponse
  status: 200
}

export type assetsValidContentRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsValidContentRetrieveResponseComposite =
  | assetsValidContentRetrieveResponse200
  | assetsValidContentRetrieveResponse404

export type assetsValidContentRetrieveResponse = assetsValidContentRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsValidContentRetrieveUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/valid_content/`
}

export const assetsValidContentRetrieve = async (
  uid: string,
  options?: RequestInit,
): Promise<assetsValidContentRetrieveResponse> => {
  return fetchWithAuth<assetsValidContentRetrieveResponse>(getAssetsValidContentRetrieveUrl(uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsValidContentRetrieveQueryKey = (uid: string) => {
  return ['api', 'v2', 'assets', uid, 'valid_content'] as const
}

export const getAssetsValidContentRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsValidContentRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsValidContentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsValidContentRetrieveQueryKey(uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsValidContentRetrieve>>> = ({ signal }) =>
    assetsValidContentRetrieve(uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsValidContentRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsValidContentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsValidContentRetrieve>>>
export type AssetsValidContentRetrieveQueryError = ErrorDetail

export function useAssetsValidContentRetrieve<
  TData = Awaited<ReturnType<typeof assetsValidContentRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsValidContentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsValidContentRetrieveQueryOptions(uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## This route will render the XForm into syntax-highlighted HTML.

It is useful for debugging pyxform transformations

 */
export type assetsXformRetrieveResponse200 = {
  data: string
  status: 200
}

export type assetsXformRetrieveResponse404 = {
  data: void
  status: 404
}

export type assetsXformRetrieveResponseComposite = assetsXformRetrieveResponse200 | assetsXformRetrieveResponse404

export type assetsXformRetrieveResponse = assetsXformRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsXformRetrieveUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/xform/`
}

export const assetsXformRetrieve = async (uid: string, options?: RequestInit): Promise<assetsXformRetrieveResponse> => {
  return fetchWithAuth<assetsXformRetrieveResponse>(getAssetsXformRetrieveUrl(uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsXformRetrieveQueryKey = (uid: string) => {
  return ['api', 'v2', 'assets', uid, 'xform'] as const
}

export const getAssetsXformRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsXformRetrieve>>,
  TError = void,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsXformRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsXformRetrieveQueryKey(uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsXformRetrieve>>> = ({ signal }) =>
    assetsXformRetrieve(uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsXformRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsXformRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsXformRetrieve>>>
export type AssetsXformRetrieveQueryError = void

export function useAssetsXformRetrieve<TData = Awaited<ReturnType<typeof assetsXformRetrieve>>, TError = void>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsXformRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsXformRetrieveQueryOptions(uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Return plain HTML of survey in tabular format

 */
export type assetsXlsRetrieveResponse200 = {
  data: string
  status: 200
}

export type assetsXlsRetrieveResponse404 = {
  data: void
  status: 404
}

export type assetsXlsRetrieveResponseComposite = assetsXlsRetrieveResponse200 | assetsXlsRetrieveResponse404

export type assetsXlsRetrieveResponse = assetsXlsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsXlsRetrieveUrl = (uid: string) => {
  return `/api/v2/assets/${uid}/xls/`
}

export const assetsXlsRetrieve = async (uid: string, options?: RequestInit): Promise<assetsXlsRetrieveResponse> => {
  return fetchWithAuth<assetsXlsRetrieveResponse>(getAssetsXlsRetrieveUrl(uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsXlsRetrieveQueryKey = (uid: string) => {
  return ['api', 'v2', 'assets', uid, 'xls'] as const
}

export const getAssetsXlsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof assetsXlsRetrieve>>, TError = void>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsXlsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsXlsRetrieveQueryKey(uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsXlsRetrieve>>> = ({ signal }) =>
    assetsXlsRetrieve(uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsXlsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsXlsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsXlsRetrieve>>>
export type AssetsXlsRetrieveQueryError = void

export function useAssetsXlsRetrieve<TData = Awaited<ReturnType<typeof assetsXlsRetrieve>>, TError = void>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsXlsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsXlsRetrieveQueryOptions(uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Perform bulk actions on assets

Actions available:

- `archive`
- `delete`
- `unarchive`
- `undelete` (superusers only)

 */
export type assetsBulkCreateResponse200 = {
  data: AssetBulkResponse
  status: 200
}

export type assetsBulkCreateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsBulkCreateResponseComposite = assetsBulkCreateResponse200 | assetsBulkCreateResponse404

export type assetsBulkCreateResponse = assetsBulkCreateResponseComposite & {
  headers: Headers
}

export const getAssetsBulkCreateUrl = () => {
  return `/api/v2/assets/bulk/`
}

export const assetsBulkCreate = async (
  assetBulkRequest: AssetBulkRequest,
  options?: RequestInit,
): Promise<assetsBulkCreateResponse> => {
  return fetchWithAuth<assetsBulkCreateResponse>(getAssetsBulkCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(assetBulkRequest),
  })
}

export const getAssetsBulkCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsBulkCreate>>,
    TError,
    { data: AssetBulkRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof assetsBulkCreate>>, TError, { data: AssetBulkRequest }, TContext> => {
  const mutationKey = ['assetsBulkCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsBulkCreate>>, { data: AssetBulkRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return assetsBulkCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsBulkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsBulkCreate>>>
export type AssetsBulkCreateMutationBody = AssetBulkRequest
export type AssetsBulkCreateMutationError = ErrorDetail

export const useAssetsBulkCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsBulkCreate>>,
    TError,
    { data: AssetBulkRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsBulkCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Get a hash of all `version_id`s of all accessible assets by the current user.

Useful to detect any changes in assets with only one call to `API`

 */
export type assetsHashRetrieveResponse200 = {
  data: HashResponse
  status: 200
}

export type assetsHashRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsHashRetrieveResponseComposite = assetsHashRetrieveResponse200 | assetsHashRetrieveResponse401

export type assetsHashRetrieveResponse = assetsHashRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsHashRetrieveUrl = () => {
  return `/api/v2/assets/hash/`
}

export const assetsHashRetrieve = async (options?: RequestInit): Promise<assetsHashRetrieveResponse> => {
  return fetchWithAuth<assetsHashRetrieveResponse>(getAssetsHashRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHashRetrieveQueryKey = () => {
  return ['api', 'v2', 'assets', 'hash'] as const
}

export const getAssetsHashRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHashRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHashRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHashRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHashRetrieve>>> = ({ signal }) =>
    assetsHashRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHashRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHashRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHashRetrieve>>>
export type AssetsHashRetrieveQueryError = ErrorDetail

export function useAssetsHashRetrieve<
  TData = Awaited<ReturnType<typeof assetsHashRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHashRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHashRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get metadata for all authenticated user' assets

 */
export type assetsMetadataRetrieveResponse200 = {
  data: AssetMetadataResponse
  status: 200
}

export type assetsMetadataRetrieveResponseComposite = assetsMetadataRetrieveResponse200

export type assetsMetadataRetrieveResponse = assetsMetadataRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsMetadataRetrieveUrl = () => {
  return `/api/v2/assets/metadata/`
}

export const assetsMetadataRetrieve = async (options?: RequestInit): Promise<assetsMetadataRetrieveResponse> => {
  return fetchWithAuth<assetsMetadataRetrieveResponse>(getAssetsMetadataRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsMetadataRetrieveQueryKey = () => {
  return ['api', 'v2', 'assets', 'metadata'] as const
}

export const getAssetsMetadataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsMetadataRetrieve>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsMetadataRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsMetadataRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsMetadataRetrieve>>> = ({ signal }) =>
    assetsMetadataRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsMetadataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsMetadataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsMetadataRetrieve>>>
export type AssetsMetadataRetrieveQueryError = unknown

export function useAssetsMetadataRetrieve<
  TData = Awaited<ReturnType<typeof assetsMetadataRetrieve>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsMetadataRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsMetadataRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
