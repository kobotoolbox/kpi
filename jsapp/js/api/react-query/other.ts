/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * This page documents all KoboToolbox API endpoints.

The endpoints are grouped by area of intended use. Each category contains related endpoints, with detailed documentation on usage and configuration. Use this as a reference to quickly find the right endpoint for managing projects, forms, data, permissions, integrations, logs, and organizational resources.

**General note**: All projects (whether deployed or draft), as well as all library content (questions, blocks, templates, and collections) in the user-facing application are represented in the API as assets.
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useQuery } from '@tanstack/react-query'
import type { QueryFunction, QueryKey, UseQueryOptions, UseQueryResult } from '@tanstack/react-query'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { Language } from '../models/language'

import type { LanguagesListParams } from '../models/languagesListParams'

import type { PaginatedLanguageListList } from '../models/paginatedLanguageListList'

import type { PaginatedPermissionResponseList } from '../models/paginatedPermissionResponseList'

import type { PaginatedTranscriptionServiceList } from '../models/paginatedTranscriptionServiceList'

import type { PaginatedTranslationServiceList } from '../models/paginatedTranslationServiceList'

import type { PermissionResponse } from '../models/permissionResponse'

import type { PermissionsListParams } from '../models/permissionsListParams'

import type { TermsOfServiceResponse } from '../models/termsOfServiceResponse'

import type { TranscriptionService } from '../models/transcriptionService'

import type { TranscriptionServicesListParams } from '../models/transcriptionServicesListParams'

import type { TranslationService } from '../models/translationService'

import type { TranslationServicesListParams } from '../models/translationServicesListParams'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List the languages accessible to requesting (authenticated) user.

Search can be made with `q` parameter. By default, search for the term in language names or language codes.

Examples:
```shell
  curl -X GET https://kf.kobotoolbox.org/api/v2/languages/?q=fr
```

Complex searches can be done on other fields, such as `transcription_services` and `translation_services`.

Examples:
```shell
  curl -X GET https://kf.kobotoolbox.org/api/v2/languages/?q=transcription_services__code:goog AND translation_services__code:goog
```

Results are order by `featured` first (descending order), then by their name.

 */
export type languagesListResponse200 = {
  data: PaginatedLanguageListList
  status: 200
}

export type languagesListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type languagesListResponseComposite = languagesListResponse200 | languagesListResponse401

export type languagesListResponse = languagesListResponseComposite & {
  headers: Headers
}

export const getLanguagesListUrl = (params?: LanguagesListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/languages/?${stringifiedParams}` : `/api/v2/languages/`
}

export const languagesList = async (
  params?: LanguagesListParams,
  options?: RequestInit,
): Promise<languagesListResponse> => {
  return fetchWithAuth<languagesListResponse>(getLanguagesListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getLanguagesListQueryKey = (params?: LanguagesListParams) => {
  return ['api', 'v2', 'languages', ...(params ? [params] : [])] as const
}

export const getLanguagesListQueryOptions = <TData = Awaited<ReturnType<typeof languagesList>>, TError = ErrorDetail>(
  params?: LanguagesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof languagesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLanguagesListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof languagesList>>> = ({ signal }) =>
    languagesList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof languagesList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type LanguagesListQueryResult = NonNullable<Awaited<ReturnType<typeof languagesList>>>
export type LanguagesListQueryError = ErrorDetail

export function useLanguagesList<TData = Awaited<ReturnType<typeof languagesList>>, TError = ErrorDetail>(
  params?: LanguagesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof languagesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getLanguagesListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve one language

* `code` - is the unique identifier of a specific language

 */
export type languagesRetrieveResponse200 = {
  data: Language
  status: 200
}

export type languagesRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type languagesRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type languagesRetrieveResponseComposite =
  | languagesRetrieveResponse200
  | languagesRetrieveResponse401
  | languagesRetrieveResponse404

export type languagesRetrieveResponse = languagesRetrieveResponseComposite & {
  headers: Headers
}

export const getLanguagesRetrieveUrl = (code: string) => {
  return `/api/v2/languages/${code}/`
}

export const languagesRetrieve = async (code: string, options?: RequestInit): Promise<languagesRetrieveResponse> => {
  return fetchWithAuth<languagesRetrieveResponse>(getLanguagesRetrieveUrl(code), {
    ...options,
    method: 'GET',
  })
}

export const getLanguagesRetrieveQueryKey = (code: string) => {
  return ['api', 'v2', 'languages', code] as const
}

export const getLanguagesRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof languagesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  code: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof languagesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLanguagesRetrieveQueryKey(code)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof languagesRetrieve>>> = ({ signal }) =>
    languagesRetrieve(code, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!code, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof languagesRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type LanguagesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof languagesRetrieve>>>
export type LanguagesRetrieveQueryError = ErrorDetail | ErrorObject

export function useLanguagesRetrieve<
  TData = Awaited<ReturnType<typeof languagesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  code: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof languagesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getLanguagesRetrieveQueryOptions(code, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List all assignable permissions for `Asset`

The `implied` property of a given permission shows which additional
permissions are automatically granted when assigning that particular
permission.

The `contradictory` property shows which permissions are removed when
assigning that particular permission.

 */
export type permissionsListResponse200 = {
  data: PaginatedPermissionResponseList
  status: 200
}

export type permissionsListResponseComposite = permissionsListResponse200

export type permissionsListResponse = permissionsListResponseComposite & {
  headers: Headers
}

export const getPermissionsListUrl = (params?: PermissionsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/permissions/?${stringifiedParams}` : `/api/v2/permissions/`
}

export const permissionsList = async (
  params?: PermissionsListParams,
  options?: RequestInit,
): Promise<permissionsListResponse> => {
  return fetchWithAuth<permissionsListResponse>(getPermissionsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getPermissionsListQueryKey = (params?: PermissionsListParams) => {
  return ['api', 'v2', 'permissions', ...(params ? [params] : [])] as const
}

export const getPermissionsListQueryOptions = <TData = Awaited<ReturnType<typeof permissionsList>>, TError = unknown>(
  params?: PermissionsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof permissionsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPermissionsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsList>>> = ({ signal }) =>
    permissionsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type PermissionsListQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsList>>>
export type PermissionsListQueryError = unknown

export function usePermissionsList<TData = Awaited<ReturnType<typeof permissionsList>>, TError = unknown>(
  params?: PermissionsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof permissionsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPermissionsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a codename's permissions

 */
export type permissionsRetrieveResponse200 = {
  data: PermissionResponse
  status: 200
}

export type permissionsRetrieveResponseComposite = permissionsRetrieveResponse200

export type permissionsRetrieveResponse = permissionsRetrieveResponseComposite & {
  headers: Headers
}

export const getPermissionsRetrieveUrl = (codename: string) => {
  return `/api/v2/permissions/${codename}/`
}

export const permissionsRetrieve = async (
  codename: string,
  options?: RequestInit,
): Promise<permissionsRetrieveResponse> => {
  return fetchWithAuth<permissionsRetrieveResponse>(getPermissionsRetrieveUrl(codename), {
    ...options,
    method: 'GET',
  })
}

export const getPermissionsRetrieveQueryKey = (codename: string) => {
  return ['api', 'v2', 'permissions', codename] as const
}

export const getPermissionsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionsRetrieve>>,
  TError = unknown,
>(
  codename: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof permissionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPermissionsRetrieveQueryKey(codename)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsRetrieve>>> = ({ signal }) =>
    permissionsRetrieve(codename, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!codename, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type PermissionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsRetrieve>>>
export type PermissionsRetrieveQueryError = unknown

export function usePermissionsRetrieve<TData = Awaited<ReturnType<typeof permissionsRetrieve>>, TError = unknown>(
  codename: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof permissionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPermissionsRetrieveQueryOptions(codename, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List the different terms of service

 */
export type termsOfServiceListResponse200 = {
  data: TermsOfServiceResponse[]
  status: 200
}

export type termsOfServiceListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type termsOfServiceListResponseComposite = termsOfServiceListResponse200 | termsOfServiceListResponse401

export type termsOfServiceListResponse = termsOfServiceListResponseComposite & {
  headers: Headers
}

export const getTermsOfServiceListUrl = () => {
  return `/api/v2/terms-of-service/`
}

export const termsOfServiceList = async (options?: RequestInit): Promise<termsOfServiceListResponse> => {
  return fetchWithAuth<termsOfServiceListResponse>(getTermsOfServiceListUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getTermsOfServiceListQueryKey = () => {
  return ['api', 'v2', 'terms-of-service'] as const
}

export const getTermsOfServiceListQueryOptions = <
  TData = Awaited<ReturnType<typeof termsOfServiceList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof termsOfServiceList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTermsOfServiceListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof termsOfServiceList>>> = ({ signal }) =>
    termsOfServiceList({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof termsOfServiceList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TermsOfServiceListQueryResult = NonNullable<Awaited<ReturnType<typeof termsOfServiceList>>>
export type TermsOfServiceListQueryError = ErrorDetail

export function useTermsOfServiceList<
  TData = Awaited<ReturnType<typeof termsOfServiceList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof termsOfServiceList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTermsOfServiceListQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a specific terms of service

 */
export type termsOfServiceRetrieveResponse200 = {
  data: TermsOfServiceResponse
  status: 200
}

export type termsOfServiceRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type termsOfServiceRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type termsOfServiceRetrieveResponseComposite =
  | termsOfServiceRetrieveResponse200
  | termsOfServiceRetrieveResponse401
  | termsOfServiceRetrieveResponse404

export type termsOfServiceRetrieveResponse = termsOfServiceRetrieveResponseComposite & {
  headers: Headers
}

export const getTermsOfServiceRetrieveUrl = (slug: string) => {
  return `/api/v2/terms-of-service/${slug}/`
}

export const termsOfServiceRetrieve = async (
  slug: string,
  options?: RequestInit,
): Promise<termsOfServiceRetrieveResponse> => {
  return fetchWithAuth<termsOfServiceRetrieveResponse>(getTermsOfServiceRetrieveUrl(slug), {
    ...options,
    method: 'GET',
  })
}

export const getTermsOfServiceRetrieveQueryKey = (slug: string) => {
  return ['api', 'v2', 'terms-of-service', slug] as const
}

export const getTermsOfServiceRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof termsOfServiceRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  slug: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof termsOfServiceRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTermsOfServiceRetrieveQueryKey(slug)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof termsOfServiceRetrieve>>> = ({ signal }) =>
    termsOfServiceRetrieve(slug, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!slug, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof termsOfServiceRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TermsOfServiceRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof termsOfServiceRetrieve>>>
export type TermsOfServiceRetrieveQueryError = ErrorDetail | ErrorObject

export function useTermsOfServiceRetrieve<
  TData = Awaited<ReturnType<typeof termsOfServiceRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  slug: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof termsOfServiceRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTermsOfServiceRetrieveQueryOptions(slug, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List the transcription services accessible to requesting user.

Search can be made with `q` parameter to search for the term in names and codes.

Results are order by name.

 */
export type transcriptionServicesListResponse200 = {
  data: PaginatedTranscriptionServiceList
  status: 200
}

export type transcriptionServicesListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type transcriptionServicesListResponseComposite =
  | transcriptionServicesListResponse200
  | transcriptionServicesListResponse401

export type transcriptionServicesListResponse = transcriptionServicesListResponseComposite & {
  headers: Headers
}

export const getTranscriptionServicesListUrl = (params?: TranscriptionServicesListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/transcription-services/?${stringifiedParams}`
    : `/api/v2/transcription-services/`
}

export const transcriptionServicesList = async (
  params?: TranscriptionServicesListParams,
  options?: RequestInit,
): Promise<transcriptionServicesListResponse> => {
  return fetchWithAuth<transcriptionServicesListResponse>(getTranscriptionServicesListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getTranscriptionServicesListQueryKey = (params?: TranscriptionServicesListParams) => {
  return ['api', 'v2', 'transcription-services', ...(params ? [params] : [])] as const
}

export const getTranscriptionServicesListQueryOptions = <
  TData = Awaited<ReturnType<typeof transcriptionServicesList>>,
  TError = ErrorDetail,
>(
  params?: TranscriptionServicesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof transcriptionServicesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTranscriptionServicesListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof transcriptionServicesList>>> = ({ signal }) =>
    transcriptionServicesList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transcriptionServicesList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TranscriptionServicesListQueryResult = NonNullable<Awaited<ReturnType<typeof transcriptionServicesList>>>
export type TranscriptionServicesListQueryError = ErrorDetail

export function useTranscriptionServicesList<
  TData = Awaited<ReturnType<typeof transcriptionServicesList>>,
  TError = ErrorDetail,
>(
  params?: TranscriptionServicesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof transcriptionServicesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTranscriptionServicesListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## retrieve a transcription service

* `code` - is the unique identifier of a specific language

 */
export type transcriptionServicesRetrieveResponse200 = {
  data: TranscriptionService
  status: 200
}

export type transcriptionServicesRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type transcriptionServicesRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type transcriptionServicesRetrieveResponseComposite =
  | transcriptionServicesRetrieveResponse200
  | transcriptionServicesRetrieveResponse401
  | transcriptionServicesRetrieveResponse404

export type transcriptionServicesRetrieveResponse = transcriptionServicesRetrieveResponseComposite & {
  headers: Headers
}

export const getTranscriptionServicesRetrieveUrl = (code: string) => {
  return `/api/v2/transcription-services/${code}/`
}

export const transcriptionServicesRetrieve = async (
  code: string,
  options?: RequestInit,
): Promise<transcriptionServicesRetrieveResponse> => {
  return fetchWithAuth<transcriptionServicesRetrieveResponse>(getTranscriptionServicesRetrieveUrl(code), {
    ...options,
    method: 'GET',
  })
}

export const getTranscriptionServicesRetrieveQueryKey = (code: string) => {
  return ['api', 'v2', 'transcription-services', code] as const
}

export const getTranscriptionServicesRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof transcriptionServicesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  code: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof transcriptionServicesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTranscriptionServicesRetrieveQueryKey(code)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof transcriptionServicesRetrieve>>> = ({ signal }) =>
    transcriptionServicesRetrieve(code, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!code, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transcriptionServicesRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TranscriptionServicesRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof transcriptionServicesRetrieve>>
>
export type TranscriptionServicesRetrieveQueryError = ErrorDetail | ErrorObject

export function useTranscriptionServicesRetrieve<
  TData = Awaited<ReturnType<typeof transcriptionServicesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  code: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof transcriptionServicesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTranscriptionServicesRetrieveQueryOptions(code, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List the translation services accessible to requesting (authenticated) user.

Search can be made with `q` parameter to search for the term in names and codes.

Results are ordered by name.


 */
export type translationServicesListResponse200 = {
  data: PaginatedTranslationServiceList
  status: 200
}

export type translationServicesListResponse400 = {
  data: ErrorObject
  status: 400
}

export type translationServicesListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type translationServicesListResponseComposite =
  | translationServicesListResponse200
  | translationServicesListResponse400
  | translationServicesListResponse401

export type translationServicesListResponse = translationServicesListResponseComposite & {
  headers: Headers
}

export const getTranslationServicesListUrl = (params?: TranslationServicesListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/translation-services/?${stringifiedParams}`
    : `/api/v2/translation-services/`
}

export const translationServicesList = async (
  params?: TranslationServicesListParams,
  options?: RequestInit,
): Promise<translationServicesListResponse> => {
  return fetchWithAuth<translationServicesListResponse>(getTranslationServicesListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getTranslationServicesListQueryKey = (params?: TranslationServicesListParams) => {
  return ['api', 'v2', 'translation-services', ...(params ? [params] : [])] as const
}

export const getTranslationServicesListQueryOptions = <
  TData = Awaited<ReturnType<typeof translationServicesList>>,
  TError = ErrorObject | ErrorDetail,
>(
  params?: TranslationServicesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof translationServicesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTranslationServicesListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof translationServicesList>>> = ({ signal }) =>
    translationServicesList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof translationServicesList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TranslationServicesListQueryResult = NonNullable<Awaited<ReturnType<typeof translationServicesList>>>
export type TranslationServicesListQueryError = ErrorObject | ErrorDetail

export function useTranslationServicesList<
  TData = Awaited<ReturnType<typeof translationServicesList>>,
  TError = ErrorObject | ErrorDetail,
>(
  params?: TranslationServicesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof translationServicesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTranslationServicesListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a translation service

* `code` - is the unique identifier of a specific language

 */
export type translationServicesRetrieveResponse200 = {
  data: TranslationService
  status: 200
}

export type translationServicesRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type translationServicesRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type translationServicesRetrieveResponseComposite =
  | translationServicesRetrieveResponse200
  | translationServicesRetrieveResponse401
  | translationServicesRetrieveResponse404

export type translationServicesRetrieveResponse = translationServicesRetrieveResponseComposite & {
  headers: Headers
}

export const getTranslationServicesRetrieveUrl = (code: string) => {
  return `/api/v2/translation-services/${code}/`
}

export const translationServicesRetrieve = async (
  code: string,
  options?: RequestInit,
): Promise<translationServicesRetrieveResponse> => {
  return fetchWithAuth<translationServicesRetrieveResponse>(getTranslationServicesRetrieveUrl(code), {
    ...options,
    method: 'GET',
  })
}

export const getTranslationServicesRetrieveQueryKey = (code: string) => {
  return ['api', 'v2', 'translation-services', code] as const
}

export const getTranslationServicesRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof translationServicesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  code: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof translationServicesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTranslationServicesRetrieveQueryKey(code)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof translationServicesRetrieve>>> = ({ signal }) =>
    translationServicesRetrieve(code, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!code, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof translationServicesRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TranslationServicesRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof translationServicesRetrieve>>
>
export type TranslationServicesRetrieveQueryError = ErrorDetail | ErrorObject

export function useTranslationServicesRetrieve<
  TData = Awaited<ReturnType<typeof translationServicesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  code: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof translationServicesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTranslationServicesRetrieveQueryOptions(code, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
