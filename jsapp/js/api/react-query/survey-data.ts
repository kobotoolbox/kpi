/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * This page documents all KoboToolbox API endpoints.

The endpoints are grouped by area of intended use. Each category contains related endpoints, with detailed documentation on usage and configuration. Use this as a reference to quickly find the right endpoint for managing projects, forms, data, permissions, integrations, logs, and organizational resources.

**General note**: All projects (whether deployed or draft), as well as all library content (questions, blocks, templates, and collections) in the user-facing application are represented in the API as assets.
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AssetsDataAttachmentsListParams } from '../models/assetsDataAttachmentsListParams'

import type { AssetsDataListParams } from '../models/assetsDataListParams'

import type { AssetsDataRetrieveParams } from '../models/assetsDataRetrieveParams'

import type { AssetsExportSettingsDataRetrieveParams } from '../models/assetsExportSettingsDataRetrieveParams'

import type { AssetsExportSettingsListParams } from '../models/assetsExportSettingsListParams'

import type { AssetsExportsListParams } from '../models/assetsExportsListParams'

import type { AssetsFilesListParams } from '../models/assetsFilesListParams'

import type { AssetsPairedDataListParams } from '../models/assetsPairedDataListParams'

import type { AttachmentRetrieveParams } from '../models/attachmentRetrieveParams'

import type { CreateFilePayload } from '../models/createFilePayload'

import type { DataBulkDelete } from '../models/dataBulkDelete'

import type { DataBulkUpdateResponse } from '../models/dataBulkUpdateResponse'

import type { DataResponse } from '../models/dataResponse'

import type { DataStatusesUpdate } from '../models/dataStatusesUpdate'

import type { DataValidationStatusUpdateResponse } from '../models/dataValidationStatusUpdateResponse'

import type { EnketoEditResponse } from '../models/enketoEditResponse'

import type { EnketoViewResponse } from '../models/enketoViewResponse'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { ExportCreatePayload } from '../models/exportCreatePayload'

import type { ExportResponse } from '../models/exportResponse'

import type { ExportSettingCreatePayload } from '../models/exportSettingCreatePayload'

import type { ExportSettingResponse } from '../models/exportSettingResponse'

import type { ExternalResponse } from '../models/externalResponse'

import type { FilesResponse } from '../models/filesResponse'

import type { PaginatedDataResponseList } from '../models/paginatedDataResponseList'

import type { PaginatedExportResponseList } from '../models/paginatedExportResponseList'

import type { PaginatedExportSettingResponseList } from '../models/paginatedExportSettingResponseList'

import type { PaginatedFilesResponseList } from '../models/paginatedFilesResponseList'

import type { PaginatedPairedDataResponseList } from '../models/paginatedPairedDataResponseList'

import type { PairedData } from '../models/pairedData'

import type { PairedDataResponse } from '../models/pairedDataResponse'

import type { PatchedDataBulkUpdate } from '../models/patchedDataBulkUpdate'

import type { PatchedDataValidationStatusUpdatePayload } from '../models/patchedDataValidationStatusUpdatePayload'

import type { PatchedDataValidationStatusesUpdatePayload } from '../models/patchedDataValidationStatusesUpdatePayload'

import type { PatchedExportSettingUpdatePayload } from '../models/patchedExportSettingUpdatePayload'

import type { PatchedPairedDataPatchPayload } from '../models/patchedPairedDataPatchPayload'

import type { ReportResponse } from '../models/reportResponse'

import { fetchWithAuth } from '../orval.mutator'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
    }
  : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## Delete a specific attachment of an Asset

* `id` can only be the uid of attachment to be deleted

 */
export type assetsAttachmentsDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsAttachmentsDestroyResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsAttachmentsDestroyResponseComposite =
  | assetsAttachmentsDestroyResponse204
  | assetsAttachmentsDestroyResponse400

export type assetsAttachmentsDestroyResponse = assetsAttachmentsDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsAttachmentsDestroyUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/attachments/${id}/`
}

export const assetsAttachmentsDestroy = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsAttachmentsDestroyResponse> => {
  return fetchWithAuth<assetsAttachmentsDestroyResponse>(getAssetsAttachmentsDestroyUrl(uidAsset, id), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsAttachmentsDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsAttachmentsDestroy>>,
    TError,
    { uidAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsAttachmentsDestroy>>,
  TError,
  { uidAsset: string; id: number },
  TContext
> => {
  const mutationKey = ['assetsAttachmentsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsAttachmentsDestroy>>,
    { uidAsset: string; id: number }
  > = (props) => {
    const { uidAsset, id } = props ?? {}

    return assetsAttachmentsDestroy(uidAsset, id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsAttachmentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsAttachmentsDestroy>>>

export type AssetsAttachmentsDestroyMutationError = ErrorObject

export const useAssetsAttachmentsDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsAttachmentsDestroy>>,
    TError,
    { uidAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsAttachmentsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete all attachments from a list of submissions

```curl
  curl -X DELETE https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/attachments/bulk/
```

> **Payload**
>
>        {
>           "submission_root_uuids": [
>               "3ed2e8de-b493-4367-a78d-3463687239dc",
>               "ef18fe33-c71d-4638-84d6-dafcbd69c327"
>           ]
>        }

* Where: "submission_root_uuids" (required) is a list of submission root uuids on the asset
to delete


> **Response**
>
>        {
>           "message": "{number_of_attachment} attachments deleted"
>        }

* Where: "number_of_attachment" is the number of items that was deleted


### !! Due to current DRF-Spectacular limitations with AOS 3.1, DELETE operations do not display request or response bodies in this documentation (as payloads are not typically recommended for DELETE). This means direct testing is unavailable. However, example payloads and responses are provided for reference, and HTTP codes/error messages are accurate.  !!

 */
export type assetsAttachmentsBulkDestroyResponse202 = {
  data: void
  status: 202
}

export type assetsAttachmentsBulkDestroyResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsAttachmentsBulkDestroyResponseComposite =
  | assetsAttachmentsBulkDestroyResponse202
  | assetsAttachmentsBulkDestroyResponse400

export type assetsAttachmentsBulkDestroyResponse = assetsAttachmentsBulkDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsAttachmentsBulkDestroyUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/attachments/bulk/`
}

export const assetsAttachmentsBulkDestroy = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsAttachmentsBulkDestroyResponse> => {
  return fetchWithAuth<assetsAttachmentsBulkDestroyResponse>(getAssetsAttachmentsBulkDestroyUrl(uidAsset), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsAttachmentsBulkDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsAttachmentsBulkDestroy>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsAttachmentsBulkDestroy>>,
  TError,
  { uidAsset: string },
  TContext
> => {
  const mutationKey = ['assetsAttachmentsBulkDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsAttachmentsBulkDestroy>>, { uidAsset: string }> = (
    props,
  ) => {
    const { uidAsset } = props ?? {}

    return assetsAttachmentsBulkDestroy(uidAsset, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsAttachmentsBulkDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsAttachmentsBulkDestroy>>
>

export type AssetsAttachmentsBulkDestroyMutationError = ErrorObject

export const useAssetsAttachmentsBulkDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsAttachmentsBulkDestroy>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsAttachmentsBulkDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List of submissions for a specific asset

By default, JSON format is used, but XML and GeoJSON are also available:

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/
```

### Pagination
Two parameters can be used to control pagination.

* `start`: Index (zero-based) from which the results start
* `limit`: Number of results per page <span class='label label-warning'>Maximum results per page is **30000**</span>

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/?start=0&limit=10
```

### Query submitted data
Provides a list of submitted data for a specific form. Use `query`
parameter to apply form data specific, see
<a href="http://docs.mongodb.org/manual/reference/operator/query/">http://docs.mongodb.org/manual/reference/operator/query/</a>.

For more details see
<a href="https://github.com/SEL-Columbia/formhub/wiki/Formhub-Access-Points-(API)#api-parameters">API Parameters</a>.

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/?query={"__version__": "vWvkKzNE8xCtfApJvabfjG"}
curl https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/?query={"_submission_time": {"$gt": "2019-09-01T01:02:03"}}
```

### About the GeoJSON format
Requesting the `geojson` format returns a `FeatureCollection` where each
submission is a `Feature`. If your form has multiple geographic questions,
use the `geo_question_name` query parameter to determine which question's
responses populate the `geometry` for each `Feature`; otherwise, the first
geographic question is used.  All question/response pairs are included in
the `properties` of each `Feature`, but _repeating groups are omitted_.

Question types are mapped to GeoJSON geometry types as follows:

* `geopoint` to `Point`;
* `geotrace` to `LineString`;
* `geoshape` to `Polygon`.



### ‚ö†Ô∏è Note: DRF-Spectacular Limitation

Due to limitations in **DRF-Spectacular**, the `ACCEPT` headers do not sync properly with the request. As a result, all responses will default to `application/json`, regardless of the specified format.

This means that while alternative formats (like XML) are technically supported and will work via command-line tools (e.g., `curl`), **they will not work** when trying out the endpoint directly from the documentation page.

We‚Äôve still included the header to show supported formats, but keep in mind:
**Only `application/json` will be used in the docs UI.**


 */
export type assetsDataListResponse200 = {
  data: PaginatedDataResponseList
  status: 200
}

export type assetsDataListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataListResponseComposite = assetsDataListResponse200 | assetsDataListResponse404

export type assetsDataListResponse = assetsDataListResponseComposite & {
  headers: Headers
}

export const getAssetsDataListUrl = (uidAsset: string, params?: AssetsDataListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/data/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/data/`
}

export const assetsDataList = async (
  uidAsset: string,
  params?: AssetsDataListParams,
  options?: RequestInit,
): Promise<assetsDataListResponse> => {
  return fetchWithAuth<assetsDataListResponse>(getAssetsDataListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataListQueryKey = (uidAsset: string, params?: AssetsDataListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', ...(params ? [params] : [])] as const
}

export const getAssetsDataListQueryOptions = <TData = Awaited<ReturnType<typeof assetsDataList>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataList>>> = ({ signal }) =>
    assetsDataList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDataList>>>
export type AssetsDataListQueryError = ErrorObject

export function useAssetsDataList<TData = Awaited<ReturnType<typeof assetsDataList>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get a specific submission
It is also possible to specify the format.

`id` can be the primary key of the submission or its `uuid`.
Please note that using the `uuid` may match **several** submissions, only
the first match will be returned.

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}.xml
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}.json
```

or

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}/?format=xml
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}/?format=json
```


### ‚ö†Ô∏è Note: DRF-Spectacular Limitation

Due to limitations in **DRF-Spectacular**, the `ACCEPT` headers do not sync properly with the request. As a result, all responses will default to `application/json`, regardless of the specified format.

This means that while alternative formats (like XML) are technically supported and will work via command-line tools (e.g., `curl`), **they will not work** when trying out the endpoint directly from the documentation page.

We‚Äôve still included the header to show supported formats, but keep in mind:
**Only `application/json` will be used in the docs UI.**

 */
export type assetsDataRetrieveResponse200 = {
  data: DataResponse
  status: 200
}

export type assetsDataRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataRetrieveResponseComposite = assetsDataRetrieveResponse200 | assetsDataRetrieveResponse404

export type assetsDataRetrieveResponse = assetsDataRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataRetrieveUrl = (uidAsset: string, id: number, params?: AssetsDataRetrieveParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/data/${id}/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/data/${id}/`
}

export const assetsDataRetrieve = async (
  uidAsset: string,
  id: number,
  params?: AssetsDataRetrieveParams,
  options?: RequestInit,
): Promise<assetsDataRetrieveResponse> => {
  return fetchWithAuth<assetsDataRetrieveResponse>(getAssetsDataRetrieveUrl(uidAsset, id, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataRetrieveQueryKey = (uidAsset: string, id: number, params?: AssetsDataRetrieveParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', id, ...(params ? [params] : [])] as const
}

export const getAssetsDataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  id: number,
  params?: AssetsDataRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataRetrieveQueryKey(uidAsset, id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataRetrieve>>> = ({ signal }) =>
    assetsDataRetrieve(uidAsset, id, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDataRetrieve>>>
export type AssetsDataRetrieveQueryError = ErrorObject

export function useAssetsDataRetrieve<TData = Awaited<ReturnType<typeof assetsDataRetrieve>>, TError = ErrorObject>(
  uidAsset: string,
  id: number,
  params?: AssetsDataRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataRetrieveQueryOptions(uidAsset, id, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Deletes current submission

 */
export type assetsDataDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDataDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataDestroyResponseComposite = assetsDataDestroyResponse204 | assetsDataDestroyResponse404

export type assetsDataDestroyResponse = assetsDataDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataDestroyUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/`
}

export const assetsDataDestroy = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataDestroyResponse> => {
  return fetchWithAuth<assetsDataDestroyResponse>(getAssetsDataDestroyUrl(uidAsset, id), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsDataDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDestroy>>,
    TError,
    { uidAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataDestroy>>,
  TError,
  { uidAsset: string; id: number },
  TContext
> => {
  const mutationKey = ['assetsDataDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataDestroy>>,
    { uidAsset: string; id: number }
  > = (props) => {
    const { uidAsset, id } = props ?? {}

    return assetsDataDestroy(uidAsset, id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDataDestroy>>>

export type AssetsDataDestroyMutationError = ErrorObject

export const useAssetsDataDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDestroy>>,
    TError,
    { uidAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Duplicate submission
Duplicates the data of a submission

 */
export type assetsDataDuplicateCreateResponse200 = {
  data: DataResponse
  status: 200
}

export type assetsDataDuplicateCreateResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataDuplicateCreateResponseComposite =
  | assetsDataDuplicateCreateResponse200
  | assetsDataDuplicateCreateResponse404

export type assetsDataDuplicateCreateResponse = assetsDataDuplicateCreateResponseComposite & {
  headers: Headers
}

export const getAssetsDataDuplicateCreateUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/duplicate/`
}

export const assetsDataDuplicateCreate = async (
  uidAsset: string,
  id: number,
  dataBulkDelete: DataBulkDelete,
  options?: RequestInit,
): Promise<assetsDataDuplicateCreateResponse> => {
  return fetchWithAuth<assetsDataDuplicateCreateResponse>(getAssetsDataDuplicateCreateUrl(uidAsset, id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(dataBulkDelete),
  })
}

export const getAssetsDataDuplicateCreateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
    TError,
    { uidAsset: string; id: number; data: DataBulkDelete },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
  TError,
  { uidAsset: string; id: number; data: DataBulkDelete },
  TContext
> => {
  const mutationKey = ['assetsDataDuplicateCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
    { uidAsset: string; id: number; data: DataBulkDelete }
  > = (props) => {
    const { uidAsset, id, data } = props ?? {}

    return assetsDataDuplicateCreate(uidAsset, id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataDuplicateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDataDuplicateCreate>>>
export type AssetsDataDuplicateCreateMutationBody = DataBulkDelete
export type AssetsDataDuplicateCreateMutationError = ErrorObject

export const useAssetsDataDuplicateCreate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
    TError,
    { uidAsset: string; id: number; data: DataBulkDelete },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataDuplicateCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Get submission url of enketo in edit mode

Note: Some variation of this url exists:

`/api/v2/assets/{uid_asset}/data/{id}/edit/`: deprecated, use the next one.

`/api/v2/assets/{uid_asset}/data/{id}/enketo/edit/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{uid_asset}/data/{id}/enketo/redirect/edit/`: redirect to the enketo url submission with a 302 HTTP code.

 */
export type assetsDataEditRetrieveResponse200 = {
  data: EnketoEditResponse
  status: 200
}

export type assetsDataEditRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEditRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataEditRetrieveResponseComposite =
  | assetsDataEditRetrieveResponse200
  | assetsDataEditRetrieveResponse403
  | assetsDataEditRetrieveResponse404

export type assetsDataEditRetrieveResponse = assetsDataEditRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEditRetrieveUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/edit/`
}

export const assetsDataEditRetrieve = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEditRetrieveResponse> => {
  return fetchWithAuth<assetsDataEditRetrieveResponse>(getAssetsDataEditRetrieveUrl(uidAsset, id), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataEditRetrieveQueryKey = (uidAsset: string, id: number) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', id, 'edit'] as const
}

export const getAssetsDataEditRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEditRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEditRetrieveQueryKey(uidAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEditRetrieve>>> = ({ signal }) =>
    assetsDataEditRetrieve(uidAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEditRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEditRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDataEditRetrieve>>>
export type AssetsDataEditRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsDataEditRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEditRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEditRetrieveQueryOptions(uidAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in edit mode

Note: Some variation of this url exists:

`/api/v2/assets/{uid_asset}/data/{id}/edit/`: deprecated, use the next one.

`/api/v2/assets/{uid_asset}/data/{id}/enketo/edit/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{uid_asset}/data/{id}/enketo/redirect/edit/`: redirect to the enketo url submission with a 302 HTTP code.

 */
export type assetsDataEnketoEditRetrieveResponse200 = {
  data: EnketoEditResponse
  status: 200
}

export type assetsDataEnketoEditRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoEditRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataEnketoEditRetrieveResponseComposite =
  | assetsDataEnketoEditRetrieveResponse200
  | assetsDataEnketoEditRetrieveResponse403
  | assetsDataEnketoEditRetrieveResponse404

export type assetsDataEnketoEditRetrieveResponse = assetsDataEnketoEditRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoEditRetrieveUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/enketo/edit/`
}

export const assetsDataEnketoEditRetrieve = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoEditRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoEditRetrieveResponse>(getAssetsDataEnketoEditRetrieveUrl(uidAsset, id), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataEnketoEditRetrieveQueryKey = (uidAsset: string, id: number) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', id, 'enketo', 'edit'] as const
}

export const getAssetsDataEnketoEditRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoEditRetrieveQueryKey(uidAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>> = ({ signal }) =>
    assetsDataEnketoEditRetrieve(uidAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoEditRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>
>
export type AssetsDataEnketoEditRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsDataEnketoEditRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoEditRetrieveQueryOptions(uidAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in edit mode

Note: Some variation of this url exists:

`/api/v2/assets/{uid_asset}/data/{id}/edit/`: deprecated, use the next one.

`/api/v2/assets/{uid_asset}/data/{id}/enketo/edit/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{uid_asset}/data/{id}/enketo/redirect/edit/`: redirect to the enketo url submission with a 302 HTTP code.

 */
export type assetsDataEnketoRedirectEditRetrieveResponse200 = {
  data: EnketoEditResponse
  status: 200
}

export type assetsDataEnketoRedirectEditRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoRedirectEditRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataEnketoRedirectEditRetrieveResponseComposite =
  | assetsDataEnketoRedirectEditRetrieveResponse200
  | assetsDataEnketoRedirectEditRetrieveResponse403
  | assetsDataEnketoRedirectEditRetrieveResponse404

export type assetsDataEnketoRedirectEditRetrieveResponse = assetsDataEnketoRedirectEditRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoRedirectEditRetrieveUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/enketo/redirect/edit/`
}

export const assetsDataEnketoRedirectEditRetrieve = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoRedirectEditRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoRedirectEditRetrieveResponse>(
    getAssetsDataEnketoRedirectEditRetrieveUrl(uidAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataEnketoRedirectEditRetrieveQueryKey = (uidAsset: string, id: number) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', id, 'enketo', 'redirect', 'edit'] as const
}

export const getAssetsDataEnketoRedirectEditRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoRedirectEditRetrieveQueryKey(uidAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>> = ({ signal }) =>
    assetsDataEnketoRedirectEditRetrieve(uidAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoRedirectEditRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>
>
export type AssetsDataEnketoRedirectEditRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsDataEnketoRedirectEditRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoRedirectEditRetrieveQueryOptions(uidAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in preview mode

Note: Some variation of this url exists:

`/api/v2/assets/{uid_asset}/data/{id}/enketo/view/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{uid_asset}/data/{id}/enketo/redirect/view/`: redirect to the enketo url submission with a 302 code.

 */
export type assetsDataEnketoRedirectViewRetrieveResponse200 = {
  data: EnketoViewResponse
  status: 200
}

export type assetsDataEnketoRedirectViewRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoRedirectViewRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataEnketoRedirectViewRetrieveResponseComposite =
  | assetsDataEnketoRedirectViewRetrieveResponse200
  | assetsDataEnketoRedirectViewRetrieveResponse403
  | assetsDataEnketoRedirectViewRetrieveResponse404

export type assetsDataEnketoRedirectViewRetrieveResponse = assetsDataEnketoRedirectViewRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoRedirectViewRetrieveUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/enketo/redirect/view/`
}

export const assetsDataEnketoRedirectViewRetrieve = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoRedirectViewRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoRedirectViewRetrieveResponse>(
    getAssetsDataEnketoRedirectViewRetrieveUrl(uidAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataEnketoRedirectViewRetrieveQueryKey = (uidAsset: string, id: number) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', id, 'enketo', 'redirect', 'view'] as const
}

export const getAssetsDataEnketoRedirectViewRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoRedirectViewRetrieveQueryKey(uidAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>> = ({ signal }) =>
    assetsDataEnketoRedirectViewRetrieve(uidAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoRedirectViewRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>
>
export type AssetsDataEnketoRedirectViewRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsDataEnketoRedirectViewRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoRedirectViewRetrieveQueryOptions(uidAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in preview mode

Note: Some variation of this url exists:

`/api/v2/assets/{uid_asset}/data/{id}/enketo/view/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{uid_asset}/data/{id}/enketo/redirect/view/`: redirect to the enketo url submission with a 302 code.

 */
export type assetsDataEnketoViewRetrieveResponse200 = {
  data: EnketoViewResponse
  status: 200
}

export type assetsDataEnketoViewRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoViewRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataEnketoViewRetrieveResponseComposite =
  | assetsDataEnketoViewRetrieveResponse200
  | assetsDataEnketoViewRetrieveResponse403
  | assetsDataEnketoViewRetrieveResponse404

export type assetsDataEnketoViewRetrieveResponse = assetsDataEnketoViewRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoViewRetrieveUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/enketo/view/`
}

export const assetsDataEnketoViewRetrieve = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoViewRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoViewRetrieveResponse>(getAssetsDataEnketoViewRetrieveUrl(uidAsset, id), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataEnketoViewRetrieveQueryKey = (uidAsset: string, id: number) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', id, 'enketo', 'view'] as const
}

export const getAssetsDataEnketoViewRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoViewRetrieveQueryKey(uidAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>> = ({ signal }) =>
    assetsDataEnketoViewRetrieve(uidAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoViewRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>
>
export type AssetsDataEnketoViewRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsDataEnketoViewRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoViewRetrieveQueryOptions(uidAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get validation statuses
Retrieves the validation status of a submission.

 */
export type assetsDataValidationStatusRetrieveResponse200 = {
  data: DataValidationStatusUpdateResponse
  status: 200
}

export type assetsDataValidationStatusRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataValidationStatusRetrieveResponseComposite =
  | assetsDataValidationStatusRetrieveResponse200
  | assetsDataValidationStatusRetrieveResponse404

export type assetsDataValidationStatusRetrieveResponse = assetsDataValidationStatusRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataValidationStatusRetrieveUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/validation_status/`
}

export const assetsDataValidationStatusRetrieve = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataValidationStatusRetrieveResponse> => {
  return fetchWithAuth<assetsDataValidationStatusRetrieveResponse>(
    getAssetsDataValidationStatusRetrieveUrl(uidAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataValidationStatusRetrieveQueryKey = (uidAsset: string, id: number) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', id, 'validation_status'] as const
}

export const getAssetsDataValidationStatusRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataValidationStatusRetrieveQueryKey(uidAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>> = ({ signal }) =>
    assetsDataValidationStatusRetrieve(uidAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataValidationStatusRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>
>
export type AssetsDataValidationStatusRetrieveQueryError = ErrorObject

export function useAssetsDataValidationStatusRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataValidationStatusRetrieveQueryOptions(uidAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update the validation of a submission

The validation status of the submission can be updated. The `validation_status.uid` should be a `string`, and it must be one of the following values:

- `validation_status_approved`
- `validation_status_not_approved`
- `validation_status_on_hold`

 */
export type assetsDataValidationStatusPartialUpdateResponse200 = {
  data: DataValidationStatusUpdateResponse
  status: 200
}

export type assetsDataValidationStatusPartialUpdateResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataValidationStatusPartialUpdateResponseComposite =
  | assetsDataValidationStatusPartialUpdateResponse200
  | assetsDataValidationStatusPartialUpdateResponse404

export type assetsDataValidationStatusPartialUpdateResponse =
  assetsDataValidationStatusPartialUpdateResponseComposite & {
    headers: Headers
  }

export const getAssetsDataValidationStatusPartialUpdateUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/validation_status/`
}

export const assetsDataValidationStatusPartialUpdate = async (
  uidAsset: string,
  id: number,
  patchedDataValidationStatusUpdatePayload: PatchedDataValidationStatusUpdatePayload,
  options?: RequestInit,
): Promise<assetsDataValidationStatusPartialUpdateResponse> => {
  return fetchWithAuth<assetsDataValidationStatusPartialUpdateResponse>(
    getAssetsDataValidationStatusPartialUpdateUrl(uidAsset, id),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedDataValidationStatusUpdatePayload),
    },
  )
}

export const getAssetsDataValidationStatusPartialUpdateMutationOptions = <
  TError = ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
    TError,
    { uidAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
  TError,
  { uidAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
    { uidAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload }
  > = (props) => {
    const { uidAsset, id, data } = props ?? {}

    return assetsDataValidationStatusPartialUpdate(uidAsset, id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>
>
export type AssetsDataValidationStatusPartialUpdateMutationBody = PatchedDataValidationStatusUpdatePayload
export type AssetsDataValidationStatusPartialUpdateMutationError = ErrorObject

export const useAssetsDataValidationStatusPartialUpdate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
    TError,
    { uidAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete validation status

 */
export type assetsDataValidationStatusDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDataValidationStatusDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataValidationStatusDestroyResponseComposite =
  | assetsDataValidationStatusDestroyResponse204
  | assetsDataValidationStatusDestroyResponse404

export type assetsDataValidationStatusDestroyResponse = assetsDataValidationStatusDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataValidationStatusDestroyUrl = (uidAsset: string, id: number) => {
  return `/api/v2/assets/${uidAsset}/data/${id}/validation_status/`
}

export const assetsDataValidationStatusDestroy = async (
  uidAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataValidationStatusDestroyResponse> => {
  return fetchWithAuth<assetsDataValidationStatusDestroyResponse>(
    getAssetsDataValidationStatusDestroyUrl(uidAsset, id),
    {
      ...options,
      method: 'DELETE',
    },
  )
}

export const getAssetsDataValidationStatusDestroyMutationOptions = <
  TError = ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
    TError,
    { uidAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
  TError,
  { uidAsset: string; id: number },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
    { uidAsset: string; id: number }
  > = (props) => {
    const { uidAsset, id } = props ?? {}

    return assetsDataValidationStatusDestroy(uidAsset, id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>
>

export type AssetsDataValidationStatusDestroyMutationError = ErrorObject

export const useAssetsDataValidationStatusDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
    TError,
    { uidAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Get an asset's attachment using xpath

* `uid_data` can be the primary key of the submission or its `uuid`.
Please note that using the `uuid` may match **several** submissions, only
the first match will be returned.

Use the `xpath` property to retrieve an attachment.

```curl
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/451/attachment/?xpath=Upload_a_file
```

### Get an MP3 file from an audio or video file
Convert audio and video files. Only conversions to MP3 is supported for this feature

```curl
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/451/attachment/?xpath=Upload_a_file&format=mp3
```

 */
export type assetsDataAttachmentsListResponse200 = {
  data: void
  status: 200
}

export type assetsDataAttachmentsListResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsDataAttachmentsListResponseComposite =
  | assetsDataAttachmentsListResponse200
  | assetsDataAttachmentsListResponse400

export type assetsDataAttachmentsListResponse = assetsDataAttachmentsListResponseComposite & {
  headers: Headers
}

export const getAssetsDataAttachmentsListUrl = (
  uidAsset: string,
  uidData: string,
  params: AssetsDataAttachmentsListParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/data/${uidData}/attachments/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/data/${uidData}/attachments/`
}

export const assetsDataAttachmentsList = async (
  uidAsset: string,
  uidData: string,
  params: AssetsDataAttachmentsListParams,
  options?: RequestInit,
): Promise<assetsDataAttachmentsListResponse> => {
  return fetchWithAuth<assetsDataAttachmentsListResponse>(getAssetsDataAttachmentsListUrl(uidAsset, uidData, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataAttachmentsListQueryKey = (
  uidAsset: string,
  uidData: string,
  params: AssetsDataAttachmentsListParams,
) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', uidData, 'attachments', ...(params ? [params] : [])] as const
}

export const getAssetsDataAttachmentsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataAttachmentsList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidData: string,
  params: AssetsDataAttachmentsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataAttachmentsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataAttachmentsListQueryKey(uidAsset, uidData, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataAttachmentsList>>> = ({ signal }) =>
    assetsDataAttachmentsList(uidAsset, uidData, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidData), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataAttachmentsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataAttachmentsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDataAttachmentsList>>>
export type AssetsDataAttachmentsListQueryError = ErrorObject

export function useAssetsDataAttachmentsList<
  TData = Awaited<ReturnType<typeof assetsDataAttachmentsList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidData: string,
  params: AssetsDataAttachmentsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataAttachmentsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataAttachmentsListQueryOptions(uidAsset, uidData, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get an asset's attachment using the ID

* `uid_data` can be the primary key of the submission or its `uuid`.
Please note that using the `uuid` may match **several** submissions, only
the first match will be returned.

* `id` of attachment can be the primary key of the attachment or its `uid`.

Both examples works:
```curl
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/451/attachment/1/
```
Or, using the `UID`:
```curl
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/451/attachment/attwYwGxdtQPSqgmHk6wS6E6/
```

### Get an MP3 file from an audio or video file
Convert audio and video files. Only conversions to MP3 is supported for this feature

```curl
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/451/attachment/1/?format=mp3
```

 */
export type attachmentRetrieveResponse200 = {
  data: void
  status: 200
}

export type attachmentRetrieveResponse400 = {
  data: ErrorObject
  status: 400
}

export type attachmentRetrieveResponseComposite = attachmentRetrieveResponse200 | attachmentRetrieveResponse400

export type attachmentRetrieveResponse = attachmentRetrieveResponseComposite & {
  headers: Headers
}

export const getAttachmentRetrieveUrl = (
  uidAsset: string,
  uidData: string,
  id: number,
  params?: AttachmentRetrieveParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/data/${uidData}/attachments/${id}/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/data/${uidData}/attachments/${id}/`
}

export const attachmentRetrieve = async (
  uidAsset: string,
  uidData: string,
  id: number,
  params?: AttachmentRetrieveParams,
  options?: RequestInit,
): Promise<attachmentRetrieveResponse> => {
  return fetchWithAuth<attachmentRetrieveResponse>(getAttachmentRetrieveUrl(uidAsset, uidData, id, params), {
    ...options,
    method: 'GET',
  })
}

export const getAttachmentRetrieveQueryKey = (
  uidAsset: string,
  uidData: string,
  id: number,
  params?: AttachmentRetrieveParams,
) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', uidData, 'attachments', id, ...(params ? [params] : [])] as const
}

export const getAttachmentRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof attachmentRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidData: string,
  id: number,
  params?: AttachmentRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof attachmentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAttachmentRetrieveQueryKey(uidAsset, uidData, id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof attachmentRetrieve>>> = ({ signal }) =>
    attachmentRetrieve(uidAsset, uidData, id, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidData && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof attachmentRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AttachmentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof attachmentRetrieve>>>
export type AttachmentRetrieveQueryError = ErrorObject

export function useAttachmentRetrieve<TData = Awaited<ReturnType<typeof attachmentRetrieve>>, TError = ErrorObject>(
  uidAsset: string,
  uidData: string,
  id: number,
  params?: AttachmentRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof attachmentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAttachmentRetrieveQueryOptions(uidAsset, uidData, id, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get a specific size of the user's attachment (Only for images)

Available formats:
- `small`
- `medium`
- `large`

`id` of attachment can be the primary key of the attachment or its `uid`.

Both examples works:
```curl
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/451/attachment/1/small/
```
Or, using the `UID`:
```curl
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/451/attachment/attwYwGxdtQPSqgmHk6wS6E6/medium/
```

 */
export type attachmentThumbnailResponse200 = {
  data: void
  status: 200
}

export type attachmentThumbnailResponse404 = {
  data: ErrorObject
  status: 404
}

export type attachmentThumbnailResponseComposite = attachmentThumbnailResponse200 | attachmentThumbnailResponse404

export type attachmentThumbnailResponse = attachmentThumbnailResponseComposite & {
  headers: Headers
}

export const getAttachmentThumbnailUrl = (uidAsset: string, uidData: string, id: number, suffix: string) => {
  return `/api/v2/assets/${uidAsset}/data/${uidData}/attachments/${id}/${suffix}/`
}

export const attachmentThumbnail = async (
  uidAsset: string,
  uidData: string,
  id: number,
  suffix: string,
  options?: RequestInit,
): Promise<attachmentThumbnailResponse> => {
  return fetchWithAuth<attachmentThumbnailResponse>(getAttachmentThumbnailUrl(uidAsset, uidData, id, suffix), {
    ...options,
    method: 'GET',
  })
}

export const getAttachmentThumbnailQueryKey = (uidAsset: string, uidData: string, id: number, suffix: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'data', uidData, 'attachments', id, suffix] as const
}

export const getAttachmentThumbnailQueryOptions = <
  TData = Awaited<ReturnType<typeof attachmentThumbnail>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidData: string,
  id: number,
  suffix: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof attachmentThumbnail>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAttachmentThumbnailQueryKey(uidAsset, uidData, id, suffix)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof attachmentThumbnail>>> = ({ signal }) =>
    attachmentThumbnail(uidAsset, uidData, id, suffix, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidData && id && suffix), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof attachmentThumbnail>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AttachmentThumbnailQueryResult = NonNullable<Awaited<ReturnType<typeof attachmentThumbnail>>>
export type AttachmentThumbnailQueryError = ErrorObject

export function useAttachmentThumbnail<TData = Awaited<ReturnType<typeof attachmentThumbnail>>, TError = ErrorObject>(
  uidAsset: string,
  uidData: string,
  id: number,
  suffix: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof attachmentThumbnail>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAttachmentThumbnailQueryOptions(uidAsset, uidData, id, suffix, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Bulk updating of submissions

Where `<field_to_update_n>` is a string and should be an existing XML field value of the submissions.
If `<field_to_update_n>` is part of a group or nested group, the field must follow the group hierarchy
structure, i.e.:

If the field is within a group called `group_1`, the field name is `question_1` and the new value is `new value`,
the payload should contain an item with the following structure:

*"group_1/question_1": "new value"*


Similarly, if there are `N` nested groups, the structure will be:

*"group_1/sub_group_1/.../sub_group_n/question_1": "new value"*

 */
export type assetsDataBulkPartialUpdateResponse200 = {
  data: DataBulkUpdateResponse
  status: 200
}

export type assetsDataBulkPartialUpdateResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataBulkPartialUpdateResponseComposite =
  | assetsDataBulkPartialUpdateResponse200
  | assetsDataBulkPartialUpdateResponse404

export type assetsDataBulkPartialUpdateResponse = assetsDataBulkPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsDataBulkPartialUpdateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/data/bulk/`
}

export const assetsDataBulkPartialUpdate = async (
  uidAsset: string,
  patchedDataBulkUpdate: PatchedDataBulkUpdate,
  options?: RequestInit,
): Promise<assetsDataBulkPartialUpdateResponse> => {
  return fetchWithAuth<assetsDataBulkPartialUpdateResponse>(getAssetsDataBulkPartialUpdateUrl(uidAsset), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedDataBulkUpdate),
  })
}

export const getAssetsDataBulkPartialUpdateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedDataBulkUpdate },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
  TError,
  { uidAsset: string; data: PatchedDataBulkUpdate },
  TContext
> => {
  const mutationKey = ['assetsDataBulkPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
    { uidAsset: string; data: PatchedDataBulkUpdate }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsDataBulkPartialUpdate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataBulkPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>
>
export type AssetsDataBulkPartialUpdateMutationBody = PatchedDataBulkUpdate
export type AssetsDataBulkPartialUpdateMutationError = ErrorObject

export const useAssetsDataBulkPartialUpdate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedDataBulkUpdate },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataBulkPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Bulk delete submissions

```curl
  curl -X DELETE https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/bulk/
```

**Payload**
```json
{
           "submissions_ids": [
               1,
               2
           ]
        }
```
* Where: `submissions_ids` (required) is a list of submission root id on the data
to delete


**Response**
```json
{
           "detail": "{number_of_submissions} submissions have been deleted"
}
```
* Where: `number_of_submissions` is the number of items that was deleted


### !! Due to limitations with DRF-Spectacular current version not fully supporting AOS 3.1, DELETE actions do not support showing a request body OR a response body. This is due to the 'vague' nature of the action which generally does *not* recommend the use of a payload. To still document this endpoint, example for the payload and response will be included but it will not be possible to test this endpoint. The HTTP code and the errors example are, for their part, factual and can be considered when working with the endpoint. !!

 */
export type assetsDataBulkDestroyResponse200 = {
  data: void
  status: 200
}

export type assetsDataBulkDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataBulkDestroyResponseComposite = assetsDataBulkDestroyResponse200 | assetsDataBulkDestroyResponse404

export type assetsDataBulkDestroyResponse = assetsDataBulkDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataBulkDestroyUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/data/bulk/`
}

export const assetsDataBulkDestroy = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsDataBulkDestroyResponse> => {
  return fetchWithAuth<assetsDataBulkDestroyResponse>(getAssetsDataBulkDestroyUrl(uidAsset), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsDataBulkDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkDestroy>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof assetsDataBulkDestroy>>, TError, { uidAsset: string }, TContext> => {
  const mutationKey = ['assetsDataBulkDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsDataBulkDestroy>>, { uidAsset: string }> = (
    props,
  ) => {
    const { uidAsset } = props ?? {}

    return assetsDataBulkDestroy(uidAsset, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataBulkDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDataBulkDestroy>>>

export type AssetsDataBulkDestroyMutationError = ErrorObject

export const useAssetsDataBulkDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkDestroy>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataBulkDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Bulk update submissions status

* Where: "submissions_ids" (required) is a list of submission root id on the data
to delete
* Where: "validation_status.uid" (required)  is a string and can be one of these values:
  * `validation_status_approved`
  * `validation_status_not_approved`
  * `validation_status_on_hold`

Will return the number of submission updated as such:
> **Response**
>
>        {
>           "detail": "{number_of_submissions} submissions have been updated"
>        }

 */
export type assetsDataValidationStatusesPartialUpdateResponse200 = {
  data: DataStatusesUpdate
  status: 200
}

export type assetsDataValidationStatusesPartialUpdateResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataValidationStatusesPartialUpdateResponseComposite =
  | assetsDataValidationStatusesPartialUpdateResponse200
  | assetsDataValidationStatusesPartialUpdateResponse404

export type assetsDataValidationStatusesPartialUpdateResponse =
  assetsDataValidationStatusesPartialUpdateResponseComposite & {
    headers: Headers
  }

export const getAssetsDataValidationStatusesPartialUpdateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/data/validation_statuses/`
}

export const assetsDataValidationStatusesPartialUpdate = async (
  uidAsset: string,
  patchedDataValidationStatusesUpdatePayload: PatchedDataValidationStatusesUpdatePayload,
  options?: RequestInit,
): Promise<assetsDataValidationStatusesPartialUpdateResponse> => {
  return fetchWithAuth<assetsDataValidationStatusesPartialUpdateResponse>(
    getAssetsDataValidationStatusesPartialUpdateUrl(uidAsset),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedDataValidationStatusesUpdatePayload),
    },
  )
}

export const getAssetsDataValidationStatusesPartialUpdateMutationOptions = <
  TError = ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedDataValidationStatusesUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
  TError,
  { uidAsset: string; data: PatchedDataValidationStatusesUpdatePayload },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusesPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
    { uidAsset: string; data: PatchedDataValidationStatusesUpdatePayload }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsDataValidationStatusesPartialUpdate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusesPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>
>
export type AssetsDataValidationStatusesPartialUpdateMutationBody = PatchedDataValidationStatusesUpdatePayload
export type AssetsDataValidationStatusesPartialUpdateMutationError = ErrorObject

export const useAssetsDataValidationStatusesPartialUpdate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedDataValidationStatusesUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusesPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Bulk delete submissions status

```curl
  curl -X DELETE https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/validation_statuses/
```

**Payload**
```json
{
  "payload": {
    "submission_ids": [
        1,
        2
      ],
    "validation_status.uid": "validation_status"
  }
}
```
* Where: "submissions_ids" (required) is a list of submission root id on the data
to delete

The validation status of the submission can be updated. The `validation_status.uid` should be a `string`, and it must be one of the following values:
- `validation_status_approved`
- `validation_status_not_approved`
- `validation_status_on_hold`

**Response**
```json
{
           "detail": "{number_of_submissions} submissions have been updated"
}
```

### !! Due to limitations with DRF-Spectacular current version not fully supporting AOS 3.1, DELETE actions do not support showing a request body OR a response body. This is due to the 'vague' nature of the action which generally does *not* recommend the use of a payload. To still document this endpoint, example for the payload and response will be included but it will not be possible to test this endpoint. The HTTP code and the errors example are, for their part, factual and can be considered when working with the endpoint. !!

 */
export type assetsDataValidationStatusesDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDataValidationStatusesDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDataValidationStatusesDestroyResponseComposite =
  | assetsDataValidationStatusesDestroyResponse204
  | assetsDataValidationStatusesDestroyResponse404

export type assetsDataValidationStatusesDestroyResponse = assetsDataValidationStatusesDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataValidationStatusesDestroyUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/data/validation_statuses/`
}

export const assetsDataValidationStatusesDestroy = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsDataValidationStatusesDestroyResponse> => {
  return fetchWithAuth<assetsDataValidationStatusesDestroyResponse>(
    getAssetsDataValidationStatusesDestroyUrl(uidAsset),
    {
      ...options,
      method: 'DELETE',
    },
  )
}

export const getAssetsDataValidationStatusesDestroyMutationOptions = <
  TError = ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
  TError,
  { uidAsset: string },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusesDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
    { uidAsset: string }
  > = (props) => {
    const { uidAsset } = props ?? {}

    return assetsDataValidationStatusesDestroy(uidAsset, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusesDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>
>

export type AssetsDataValidationStatusesDestroyMutationError = ErrorObject

export const useAssetsDataValidationStatusesDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusesDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List of export settings for a specific asset

<sup>*</sup> _Required permissions: `view_submissions` (View submissions)_

 */
export type assetsExportSettingsListResponse200 = {
  data: PaginatedExportSettingResponseList
  status: 200
}

export type assetsExportSettingsListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportSettingsListResponseComposite =
  | assetsExportSettingsListResponse200
  | assetsExportSettingsListResponse404

export type assetsExportSettingsListResponse = assetsExportSettingsListResponseComposite & {
  headers: Headers
}

export const getAssetsExportSettingsListUrl = (uidAsset: string, params?: AssetsExportSettingsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/export-settings/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/export-settings/`
}

export const assetsExportSettingsList = async (
  uidAsset: string,
  params?: AssetsExportSettingsListParams,
  options?: RequestInit,
): Promise<assetsExportSettingsListResponse> => {
  return fetchWithAuth<assetsExportSettingsListResponse>(getAssetsExportSettingsListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsExportSettingsListQueryKey = (uidAsset: string, params?: AssetsExportSettingsListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'export-settings', ...(params ? [params] : [])] as const
}

export const getAssetsExportSettingsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsExportSettingsList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  params?: AssetsExportSettingsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportSettingsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsExportSettingsListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsExportSettingsList>>> = ({ signal }) =>
    assetsExportSettingsList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsExportSettingsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsExportSettingsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsExportSettingsList>>>
export type AssetsExportSettingsListQueryError = ErrorObject

export function useAssetsExportSettingsList<
  TData = Awaited<ReturnType<typeof assetsExportSettingsList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  params?: AssetsExportSettingsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportSettingsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsExportSettingsListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export setting for an asset

<sup>*</sup> _Required permissions: `manage_asset` (Manage project)_

Where:

* `name` (required) is the name of the export setting displayed in the UI
* `export_settings` (required) is a map of defined settings containing the following valid options:
    * `fields` (optional) is an array of column names to be included in the export (including their group hierarchy). Valid inputs include:
        * An array containing any string value that matches the XML column name
        * An empty array which will result in all columns being included
        * If `fields` is not included in the `export_settings`, all columns will be included in the export
* `flatten` (optional) is a boolean value and only relevant when exporting to `geojson` format.
* `fields_from_all_versions` (required) is a boolean to specify whether fields from all form versions will be included in the export.
* `group_sep` (required) is a value used to separate the names in a hierarchy of groups. Valid inputs include:
    * Non-empty value
* `hierarchy_in_labels` (required) is a boolean to specify whether the group hierarchy will be displayed in labels
* `multiple_select` (required) is a value to specify the display of multiple-select-type responses. Valid inputs include:
    * `both`,
    * `summary`, or
    * `details`
* `type` (required) specifies the export format. Valid export formats include:
    * `csv`,
    * `geojson`,
    * `spss_labels`, or
    * `xls`
* `xls_types_as_text` (optional) is a boolean value that defaults to `false` and only affects `xls` export types.
* `include_media_url` (optional) is a boolean value that defaults to `false` and only affects `xls` and `csv` export types.
* `submission_ids` (optional) is an array of submission ids that will filter exported submissions to only the specified array of ids. Valid inputs include:
    * An array containing integer values
    * An empty array (no filtering)
* `query` (optional) is a JSON object containing a Mongo filter query for filtering exported submissions. Valid inputs include:
    * A JSON object containing a valid Mongo query
    * An empty JSON object (no filtering)

**Note that the following behaviour can be expected when specifying a value for the `multiple_select` field:**

* `summary`: Includes one column per question, with all selected choices separated by spaces;
* `details`: Expands each multiple-select question to one column per choice, with each of those columns having a binary 1 or 0 to indicate whether that choice was chosen;
* `both`: Includes the format of `summary` _and_ `details` in the export

 */
export type assetsExportSettingsCreateResponse201 = {
  data: ExportSettingResponse
  status: 201
}

export type assetsExportSettingsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsExportSettingsCreateResponseComposite =
  | assetsExportSettingsCreateResponse201
  | assetsExportSettingsCreateResponse400

export type assetsExportSettingsCreateResponse = assetsExportSettingsCreateResponseComposite & {
  headers: Headers
}

export const getAssetsExportSettingsCreateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/export-settings/`
}

export const assetsExportSettingsCreate = async (
  uidAsset: string,
  exportSettingCreatePayload: ExportSettingCreatePayload,
  options?: RequestInit,
): Promise<assetsExportSettingsCreateResponse> => {
  return fetchWithAuth<assetsExportSettingsCreateResponse>(getAssetsExportSettingsCreateUrl(uidAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(exportSettingCreatePayload),
  })
}

export const getAssetsExportSettingsCreateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportSettingsCreate>>,
    TError,
    { uidAsset: string; data: ExportSettingCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsExportSettingsCreate>>,
  TError,
  { uidAsset: string; data: ExportSettingCreatePayload },
  TContext
> => {
  const mutationKey = ['assetsExportSettingsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsExportSettingsCreate>>,
    { uidAsset: string; data: ExportSettingCreatePayload }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsExportSettingsCreate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsExportSettingsCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsExportSettingsCreate>>
>
export type AssetsExportSettingsCreateMutationBody = ExportSettingCreatePayload
export type AssetsExportSettingsCreateMutationError = ErrorObject

export const useAssetsExportSettingsCreate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportSettingsCreate>>,
    TError,
    { uidAsset: string; data: ExportSettingCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsExportSettingsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve a specific export setting

<sup>*</sup> _Required permissions: `view_submissions` (View submissions)_

 */
export type assetsExportSettingsRetrieveResponse200 = {
  data: ExportSettingResponse
  status: 200
}

export type assetsExportSettingsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportSettingsRetrieveResponseComposite =
  | assetsExportSettingsRetrieveResponse200
  | assetsExportSettingsRetrieveResponse404

export type assetsExportSettingsRetrieveResponse = assetsExportSettingsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsExportSettingsRetrieveUrl = (uidAsset: string, uidExportSetting: string) => {
  return `/api/v2/assets/${uidAsset}/export-settings/${uidExportSetting}/`
}

export const assetsExportSettingsRetrieve = async (
  uidAsset: string,
  uidExportSetting: string,
  options?: RequestInit,
): Promise<assetsExportSettingsRetrieveResponse> => {
  return fetchWithAuth<assetsExportSettingsRetrieveResponse>(
    getAssetsExportSettingsRetrieveUrl(uidAsset, uidExportSetting),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsExportSettingsRetrieveQueryKey = (uidAsset: string, uidExportSetting: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'export-settings', uidExportSetting] as const
}

export const getAssetsExportSettingsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsExportSettingsRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidExportSetting: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportSettingsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsExportSettingsRetrieveQueryKey(uidAsset, uidExportSetting)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsExportSettingsRetrieve>>> = ({ signal }) =>
    assetsExportSettingsRetrieve(uidAsset, uidExportSetting, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidExportSetting), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsExportSettingsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsExportSettingsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsExportSettingsRetrieve>>
>
export type AssetsExportSettingsRetrieveQueryError = ErrorObject

export function useAssetsExportSettingsRetrieve<
  TData = Awaited<ReturnType<typeof assetsExportSettingsRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidExportSetting: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportSettingsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsExportSettingsRetrieveQueryOptions(uidAsset, uidExportSetting, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update the current export setting

<sup>*</sup> _Required permissions: `manage_asset` (Manage project)_

 */
export type assetsExportSettingsPartialUpdateResponse200 = {
  data: ExportSettingResponse
  status: 200
}

export type assetsExportSettingsPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsExportSettingsPartialUpdateResponseComposite =
  | assetsExportSettingsPartialUpdateResponse200
  | assetsExportSettingsPartialUpdateResponse400

export type assetsExportSettingsPartialUpdateResponse = assetsExportSettingsPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsExportSettingsPartialUpdateUrl = (uidAsset: string, uidExportSetting: string) => {
  return `/api/v2/assets/${uidAsset}/export-settings/${uidExportSetting}/`
}

export const assetsExportSettingsPartialUpdate = async (
  uidAsset: string,
  uidExportSetting: string,
  patchedExportSettingUpdatePayload: PatchedExportSettingUpdatePayload,
  options?: RequestInit,
): Promise<assetsExportSettingsPartialUpdateResponse> => {
  return fetchWithAuth<assetsExportSettingsPartialUpdateResponse>(
    getAssetsExportSettingsPartialUpdateUrl(uidAsset, uidExportSetting),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedExportSettingUpdatePayload),
    },
  )
}

export const getAssetsExportSettingsPartialUpdateMutationOptions = <
  TError = ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportSettingsPartialUpdate>>,
    TError,
    { uidAsset: string; uidExportSetting: string; data: PatchedExportSettingUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsExportSettingsPartialUpdate>>,
  TError,
  { uidAsset: string; uidExportSetting: string; data: PatchedExportSettingUpdatePayload },
  TContext
> => {
  const mutationKey = ['assetsExportSettingsPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsExportSettingsPartialUpdate>>,
    { uidAsset: string; uidExportSetting: string; data: PatchedExportSettingUpdatePayload }
  > = (props) => {
    const { uidAsset, uidExportSetting, data } = props ?? {}

    return assetsExportSettingsPartialUpdate(uidAsset, uidExportSetting, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsExportSettingsPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsExportSettingsPartialUpdate>>
>
export type AssetsExportSettingsPartialUpdateMutationBody = PatchedExportSettingUpdatePayload
export type AssetsExportSettingsPartialUpdateMutationError = ErrorObject

export const useAssetsExportSettingsPartialUpdate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportSettingsPartialUpdate>>,
    TError,
    { uidAsset: string; uidExportSetting: string; data: PatchedExportSettingUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsExportSettingsPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete current export setting

<sup>*</sup> _Required permissions: `manage_asset` (Manage project)_


 */
export type assetsExportSettingsDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsExportSettingsDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportSettingsDestroyResponseComposite =
  | assetsExportSettingsDestroyResponse204
  | assetsExportSettingsDestroyResponse404

export type assetsExportSettingsDestroyResponse = assetsExportSettingsDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsExportSettingsDestroyUrl = (uidAsset: string, uidExportSetting: string) => {
  return `/api/v2/assets/${uidAsset}/export-settings/${uidExportSetting}/`
}

export const assetsExportSettingsDestroy = async (
  uidAsset: string,
  uidExportSetting: string,
  options?: RequestInit,
): Promise<assetsExportSettingsDestroyResponse> => {
  return fetchWithAuth<assetsExportSettingsDestroyResponse>(
    getAssetsExportSettingsDestroyUrl(uidAsset, uidExportSetting),
    {
      ...options,
      method: 'DELETE',
    },
  )
}

export const getAssetsExportSettingsDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportSettingsDestroy>>,
    TError,
    { uidAsset: string; uidExportSetting: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsExportSettingsDestroy>>,
  TError,
  { uidAsset: string; uidExportSetting: string },
  TContext
> => {
  const mutationKey = ['assetsExportSettingsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsExportSettingsDestroy>>,
    { uidAsset: string; uidExportSetting: string }
  > = (props) => {
    const { uidAsset, uidExportSetting } = props ?? {}

    return assetsExportSettingsDestroy(uidAsset, uidExportSetting, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsExportSettingsDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsExportSettingsDestroy>>
>

export type AssetsExportSettingsDestroyMutationError = ErrorObject

export const useAssetsExportSettingsDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportSettingsDestroy>>,
    TError,
    { uidAsset: string; uidExportSetting: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsExportSettingsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Synchronously export data

To retrieve data synchronously in CSV and XLSX format according to a
particular instance of export settings.

Processing time of synchronous exports is substantially limited compared to
asynchronous exports, which are available at `/api/v2/assets/{asset_uid}/exports/`.

 */
export type assetsExportSettingsDataRetrieveResponse200 = {
  data: void
  status: 200
}

export type assetsExportSettingsDataRetrieveResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsExportSettingsDataRetrieveResponseComposite =
  | assetsExportSettingsDataRetrieveResponse200
  | assetsExportSettingsDataRetrieveResponse400

export type assetsExportSettingsDataRetrieveResponse = assetsExportSettingsDataRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsExportSettingsDataRetrieveUrl = (
  uidAsset: string,
  uidExportSetting: string,
  params: AssetsExportSettingsDataRetrieveParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/export-settings/${uidExportSetting}/data/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/export-settings/${uidExportSetting}/data/`
}

export const assetsExportSettingsDataRetrieve = async (
  uidAsset: string,
  uidExportSetting: string,
  params: AssetsExportSettingsDataRetrieveParams,
  options?: RequestInit,
): Promise<assetsExportSettingsDataRetrieveResponse> => {
  return fetchWithAuth<assetsExportSettingsDataRetrieveResponse>(
    getAssetsExportSettingsDataRetrieveUrl(uidAsset, uidExportSetting, params),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsExportSettingsDataRetrieveQueryKey = (
  uidAsset: string,
  uidExportSetting: string,
  params: AssetsExportSettingsDataRetrieveParams,
) => {
  return [
    'api',
    'v2',
    'assets',
    uidAsset,
    'export-settings',
    uidExportSetting,
    'data',
    ...(params ? [params] : []),
  ] as const
}

export const getAssetsExportSettingsDataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsExportSettingsDataRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidExportSetting: string,
  params: AssetsExportSettingsDataRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportSettingsDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAssetsExportSettingsDataRetrieveQueryKey(uidAsset, uidExportSetting, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsExportSettingsDataRetrieve>>> = ({ signal }) =>
    assetsExportSettingsDataRetrieve(uidAsset, uidExportSetting, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidExportSetting), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsExportSettingsDataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsExportSettingsDataRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsExportSettingsDataRetrieve>>
>
export type AssetsExportSettingsDataRetrieveQueryError = ErrorObject

export function useAssetsExportSettingsDataRetrieve<
  TData = Awaited<ReturnType<typeof assetsExportSettingsDataRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidExportSetting: string,
  params: AssetsExportSettingsDataRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportSettingsDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsExportSettingsDataRetrieveQueryOptions(uidAsset, uidExportSetting, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List of export tasks endpoints

Lists the export tasks accessible to requesting user, for anonymous access
nothing is returned.

<sup>*</sup> _Required permissions: `view_submissions` (View submissions)_

Otherwise, the search can be more specific:

**Exports matching `uid`s:**
```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{asset_uid}/exports/?q=uid__in:ehZUwRctkhp9QfJgvEWGg OR uid__in:ehZUwRctkhp9QfJgvDnjud
```

 */
export type assetsExportsListResponse200 = {
  data: PaginatedExportResponseList
  status: 200
}

export type assetsExportsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportsListResponseComposite =
  | assetsExportsListResponse200
  | assetsExportsListResponse403
  | assetsExportsListResponse404

export type assetsExportsListResponse = assetsExportsListResponseComposite & {
  headers: Headers
}

export const getAssetsExportsListUrl = (uidAsset: string, params?: AssetsExportsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/exports/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/exports/`
}

export const assetsExportsList = async (
  uidAsset: string,
  params?: AssetsExportsListParams,
  options?: RequestInit,
): Promise<assetsExportsListResponse> => {
  return fetchWithAuth<assetsExportsListResponse>(getAssetsExportsListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsExportsListQueryKey = (uidAsset: string, params?: AssetsExportsListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'exports', ...(params ? [params] : [])] as const
}

export const getAssetsExportsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsExportsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  params?: AssetsExportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsExportsListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsExportsList>>> = ({ signal }) =>
    assetsExportsList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsExportsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsExportsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsExportsList>>>
export type AssetsExportsListQueryError = ErrorDetail | ErrorObject

export function useAssetsExportsList<
  TData = Awaited<ReturnType<typeof assetsExportsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  params?: AssetsExportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsExportsListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Creates an export task

Where:
* `fields_from_all_versions` (required) is a boolean to specify whether fields from all form versions will be included in the export.
    * `group_sep` (required) is a value used to separate the names in a hierarchy of groups. Valid inputs include:
        * Non-empty value
    * `hierarchy_in_labels` (required) is a boolean to specify whether the group hierarchy will be displayed in labels
    * `lang` (required) is a string that can be set to:
        * `_xml` to have XML values and headers, or
        * Any translation specified in the form such as `English (en)`, etc.
    * `multiple_select` (required) is a value to specify the display of `multiple_select-type` responses. Valid inputs include:
        * `both`,
        * `summary`, or
        * `details`
    * "`type`" (required) specifies the export format. Valid export formats include:
        * `csv`,
        * `geojson`,
        * `spss_labels`, or
        * `xls`
    * `fields` (optional) is an array of column names to be included in the export (including their group hierarchy). Valid inputs include:
        * An array containing any string value that matches the XML column name
        * An empty array which will result in all columns being included
        * If `fields` is not included in the `export_settings`, all columns will be included in the export
    * `flatten` (optional) is a boolean value and only relevant when exporting to "geojson" format.
    * `xls_types_as_text` (optional) is a boolean value that defaults to `false` and only affects `xls` export types.
    * `include_media_url` (optional) is a boolean value that defaults to `false` and only affects `xls` and "csv" export types. This will include an additional column for media-type questions (`question_name_URL`) with the URL link to the hosted file.
    * `submission_ids` (optional) is an array of submission ids that will filter exported submissions to only the specified array of ids. Valid inputs include:
        * An array containing integer values
        * An empty array (no filtering)
    * `query` (optional) is a JSON object containing a Mongo filter query for filtering exported submissions. Valid inputs include:
        * A JSON object containing a valid Mongo query
        * An empty JSON object (no filtering)

 */
export type assetsExportsCreateResponse201 = {
  data: ExportResponse
  status: 201
}

export type assetsExportsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsExportsCreateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsCreateResponseComposite =
  | assetsExportsCreateResponse201
  | assetsExportsCreateResponse400
  | assetsExportsCreateResponse403

export type assetsExportsCreateResponse = assetsExportsCreateResponseComposite & {
  headers: Headers
}

export const getAssetsExportsCreateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/exports/`
}

export const assetsExportsCreate = async (
  uidAsset: string,
  exportCreatePayload: ExportCreatePayload,
  options?: RequestInit,
): Promise<assetsExportsCreateResponse> => {
  return fetchWithAuth<assetsExportsCreateResponse>(getAssetsExportsCreateUrl(uidAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(exportCreatePayload),
  })
}

export const getAssetsExportsCreateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsCreate>>,
    TError,
    { uidAsset: string; data: ExportCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsExportsCreate>>,
  TError,
  { uidAsset: string; data: ExportCreatePayload },
  TContext
> => {
  const mutationKey = ['assetsExportsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsExportsCreate>>,
    { uidAsset: string; data: ExportCreatePayload }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsExportsCreate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsExportsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsExportsCreate>>>
export type AssetsExportsCreateMutationBody = ExportCreatePayload
export type AssetsExportsCreateMutationError = ErrorObject | ErrorDetail

export const useAssetsExportsCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsCreate>>,
    TError,
    { uidAsset: string; data: ExportCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsExportsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieves current export task

 */
export type assetsExportsRetrieveResponse200 = {
  data: ExportResponse
  status: 200
}

export type assetsExportsRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportsRetrieveResponseComposite =
  | assetsExportsRetrieveResponse200
  | assetsExportsRetrieveResponse403
  | assetsExportsRetrieveResponse404

export type assetsExportsRetrieveResponse = assetsExportsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsExportsRetrieveUrl = (uidAsset: string, uidExport: string) => {
  return `/api/v2/assets/${uidAsset}/exports/${uidExport}/`
}

export const assetsExportsRetrieve = async (
  uidAsset: string,
  uidExport: string,
  options?: RequestInit,
): Promise<assetsExportsRetrieveResponse> => {
  return fetchWithAuth<assetsExportsRetrieveResponse>(getAssetsExportsRetrieveUrl(uidAsset, uidExport), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsExportsRetrieveQueryKey = (uidAsset: string, uidExport: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'exports', uidExport] as const
}

export const getAssetsExportsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsExportsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  uidExport: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsExportsRetrieveQueryKey(uidAsset, uidExport)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsExportsRetrieve>>> = ({ signal }) =>
    assetsExportsRetrieve(uidAsset, uidExport, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidExport), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsExportsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsExportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsExportsRetrieve>>>
export type AssetsExportsRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsExportsRetrieve<
  TData = Awaited<ReturnType<typeof assetsExportsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  uidExport: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsExportsRetrieveQueryOptions(uidAsset, uidExport, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Deletes current export task

 */
export type assetsExportsDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsExportsDestroyResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportsDestroyResponseComposite =
  | assetsExportsDestroyResponse204
  | assetsExportsDestroyResponse403
  | assetsExportsDestroyResponse404

export type assetsExportsDestroyResponse = assetsExportsDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsExportsDestroyUrl = (uidAsset: string, uidExport: string) => {
  return `/api/v2/assets/${uidAsset}/exports/${uidExport}/`
}

export const assetsExportsDestroy = async (
  uidAsset: string,
  uidExport: string,
  options?: RequestInit,
): Promise<assetsExportsDestroyResponse> => {
  return fetchWithAuth<assetsExportsDestroyResponse>(getAssetsExportsDestroyUrl(uidAsset, uidExport), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsExportsDestroyMutationOptions = <
  TError = ErrorDetail | ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsDestroy>>,
    TError,
    { uidAsset: string; uidExport: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsExportsDestroy>>,
  TError,
  { uidAsset: string; uidExport: string },
  TContext
> => {
  const mutationKey = ['assetsExportsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsExportsDestroy>>,
    { uidAsset: string; uidExport: string }
  > = (props) => {
    const { uidAsset, uidExport } = props ?? {}

    return assetsExportsDestroy(uidAsset, uidExport, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsExportsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsExportsDestroy>>>

export type AssetsExportsDestroyMutationError = ErrorDetail | ErrorObject

export const useAssetsExportsDestroy = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsDestroy>>,
    TError,
    { uidAsset: string; uidExport: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsExportsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve current asset files

Results can be narrowed down with a filter by type:
```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/files/?collections_first=true&ordering=-name
```

 */
export type assetsFilesListResponse200 = {
  data: PaginatedFilesResponseList
  status: 200
}

export type assetsFilesListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsFilesListResponseComposite = assetsFilesListResponse200 | assetsFilesListResponse404

export type assetsFilesListResponse = assetsFilesListResponseComposite & {
  headers: Headers
}

export const getAssetsFilesListUrl = (uidAsset: string, params?: AssetsFilesListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/files/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/files/`
}

export const assetsFilesList = async (
  uidAsset: string,
  params?: AssetsFilesListParams,
  options?: RequestInit,
): Promise<assetsFilesListResponse> => {
  return fetchWithAuth<assetsFilesListResponse>(getAssetsFilesListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsFilesListQueryKey = (uidAsset: string, params?: AssetsFilesListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'files', ...(params ? [params] : [])] as const
}

export const getAssetsFilesListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsFilesList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  params?: AssetsFilesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsFilesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsFilesListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsFilesList>>> = ({ signal }) =>
    assetsFilesList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsFilesList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsFilesListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsFilesList>>>
export type AssetsFilesListQueryError = ErrorObject

export function useAssetsFilesList<TData = Awaited<ReturnType<typeof assetsFilesList>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsFilesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsFilesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsFilesListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create a new file on current asset

Fields:

- `asset` (required)
- `user` (required)
- `description` (required)
- `file_type` (required)
- `content` (as binary) (optional)
- `metadata` JSON (optional)

_Notes:_

1. Files can have different types:
    - `map_layer`
    - `form_media`
2. Files can be created with three different ways
    - `POST` a file with `content` parameter
    - `POST` a base64 encoded string with `base64Encoded` parameter<sup>1</sup>
    - `POST` an URL with `metadata` parameter<sup>2</sup>

<sup>1)</sup> `metadata` becomes mandatory and must contain `filename` property<br>
<sup>2)</sup> `metadata` becomes mandatory and must contain `redirect_url` property

**Files with `form_media` type must have unique `filename` per asset**

 */
export type assetsFilesCreateResponse201 = {
  data: FilesResponse
  status: 201
}

export type assetsFilesCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsFilesCreateResponseComposite = assetsFilesCreateResponse201 | assetsFilesCreateResponse400

export type assetsFilesCreateResponse = assetsFilesCreateResponseComposite & {
  headers: Headers
}

export const getAssetsFilesCreateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/files/`
}

export const assetsFilesCreate = async (
  uidAsset: string,
  createFilePayload: CreateFilePayload,
  options?: RequestInit,
): Promise<assetsFilesCreateResponse> => {
  return fetchWithAuth<assetsFilesCreateResponse>(getAssetsFilesCreateUrl(uidAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createFilePayload),
  })
}

export const getAssetsFilesCreateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsFilesCreate>>,
    TError,
    { uidAsset: string; data: CreateFilePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsFilesCreate>>,
  TError,
  { uidAsset: string; data: CreateFilePayload },
  TContext
> => {
  const mutationKey = ['assetsFilesCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsFilesCreate>>,
    { uidAsset: string; data: CreateFilePayload }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsFilesCreate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsFilesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsFilesCreate>>>
export type AssetsFilesCreateMutationBody = CreateFilePayload
export type AssetsFilesCreateMutationError = ErrorObject

export const useAssetsFilesCreate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsFilesCreate>>,
    TError,
    { uidAsset: string; data: CreateFilePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsFilesCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve a file from current asset

 */
export type assetsFilesRetrieveResponse200 = {
  data: FilesResponse
  status: 200
}

export type assetsFilesRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsFilesRetrieveResponseComposite = assetsFilesRetrieveResponse200 | assetsFilesRetrieveResponse404

export type assetsFilesRetrieveResponse = assetsFilesRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsFilesRetrieveUrl = (uidAsset: string, uidFile: string) => {
  return `/api/v2/assets/${uidAsset}/files/${uidFile}/`
}

export const assetsFilesRetrieve = async (
  uidAsset: string,
  uidFile: string,
  options?: RequestInit,
): Promise<assetsFilesRetrieveResponse> => {
  return fetchWithAuth<assetsFilesRetrieveResponse>(getAssetsFilesRetrieveUrl(uidAsset, uidFile), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsFilesRetrieveQueryKey = (uidAsset: string, uidFile: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'files', uidFile] as const
}

export const getAssetsFilesRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsFilesRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidFile: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsFilesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsFilesRetrieveQueryKey(uidAsset, uidFile)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsFilesRetrieve>>> = ({ signal }) =>
    assetsFilesRetrieve(uidAsset, uidFile, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidFile), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsFilesRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsFilesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsFilesRetrieve>>>
export type AssetsFilesRetrieveQueryError = ErrorObject

export function useAssetsFilesRetrieve<TData = Awaited<ReturnType<typeof assetsFilesRetrieve>>, TError = ErrorObject>(
  uidAsset: string,
  uidFile: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsFilesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsFilesRetrieveQueryOptions(uidAsset, uidFile, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Delete a file from current asset

 */
export type assetsFilesDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsFilesDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsFilesDestroyResponseComposite = assetsFilesDestroyResponse204 | assetsFilesDestroyResponse404

export type assetsFilesDestroyResponse = assetsFilesDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsFilesDestroyUrl = (uidAsset: string, uidFile: string) => {
  return `/api/v2/assets/${uidAsset}/files/${uidFile}/`
}

export const assetsFilesDestroy = async (
  uidAsset: string,
  uidFile: string,
  options?: RequestInit,
): Promise<assetsFilesDestroyResponse> => {
  return fetchWithAuth<assetsFilesDestroyResponse>(getAssetsFilesDestroyUrl(uidAsset, uidFile), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsFilesDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsFilesDestroy>>,
    TError,
    { uidAsset: string; uidFile: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsFilesDestroy>>,
  TError,
  { uidAsset: string; uidFile: string },
  TContext
> => {
  const mutationKey = ['assetsFilesDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsFilesDestroy>>,
    { uidAsset: string; uidFile: string }
  > = (props) => {
    const { uidAsset, uidFile } = props ?? {}

    return assetsFilesDestroy(uidAsset, uidFile, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsFilesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsFilesDestroy>>>

export type AssetsFilesDestroyMutationError = ErrorObject

export const useAssetsFilesDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsFilesDestroy>>,
    TError,
    { uidAsset: string; uidFile: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsFilesDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Download the asset file

 */
export type assetsFilesContentRetrieveResponse200 = {
  data: void
  status: 200
}

export type assetsFilesContentRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsFilesContentRetrieveResponseComposite =
  | assetsFilesContentRetrieveResponse200
  | assetsFilesContentRetrieveResponse404

export type assetsFilesContentRetrieveResponse = assetsFilesContentRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsFilesContentRetrieveUrl = (uidAsset: string, uidFile: string) => {
  return `/api/v2/assets/${uidAsset}/files/${uidFile}/content/`
}

export const assetsFilesContentRetrieve = async (
  uidAsset: string,
  uidFile: string,
  options?: RequestInit,
): Promise<assetsFilesContentRetrieveResponse> => {
  return fetchWithAuth<assetsFilesContentRetrieveResponse>(getAssetsFilesContentRetrieveUrl(uidAsset, uidFile), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsFilesContentRetrieveQueryKey = (uidAsset: string, uidFile: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'files', uidFile, 'content'] as const
}

export const getAssetsFilesContentRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsFilesContentRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidFile: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsFilesContentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsFilesContentRetrieveQueryKey(uidAsset, uidFile)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsFilesContentRetrieve>>> = ({ signal }) =>
    assetsFilesContentRetrieve(uidAsset, uidFile, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidFile), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsFilesContentRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsFilesContentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsFilesContentRetrieve>>>
export type AssetsFilesContentRetrieveQueryError = ErrorObject

export function useAssetsFilesContentRetrieve<
  TData = Awaited<ReturnType<typeof assetsFilesContentRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidFile: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsFilesContentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsFilesContentRetrieveQueryOptions(uidAsset, uidFile, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List paired project endpoints

This endpoint is paginated and accepts these parameters:
- `offset`: The initial index from which to return the results
- `limit`: Number of results to return per page

 */
export type assetsPairedDataListResponse200 = {
  data: PaginatedPairedDataResponseList
  status: 200
}

export type assetsPairedDataListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsPairedDataListResponseComposite = assetsPairedDataListResponse200 | assetsPairedDataListResponse404

export type assetsPairedDataListResponse = assetsPairedDataListResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataListUrl = (uidAsset: string, params?: AssetsPairedDataListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/paired-data/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/paired-data/`
}

export const assetsPairedDataList = async (
  uidAsset: string,
  params?: AssetsPairedDataListParams,
  options?: RequestInit,
): Promise<assetsPairedDataListResponse> => {
  return fetchWithAuth<assetsPairedDataListResponse>(getAssetsPairedDataListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsPairedDataListQueryKey = (uidAsset: string, params?: AssetsPairedDataListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'paired-data', ...(params ? [params] : [])] as const
}

export const getAssetsPairedDataListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsPairedDataList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  params?: AssetsPairedDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsPairedDataListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsPairedDataList>>> = ({ signal }) =>
    assetsPairedDataList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsPairedDataList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsPairedDataListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataList>>>
export type AssetsPairedDataListQueryError = ErrorObject

export function useAssetsPairedDataList<TData = Awaited<ReturnType<typeof assetsPairedDataList>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsPairedDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsPairedDataListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create a connection between two projects

* `fields`: Optional. List of questions whose responses will be retrieved
        from the source data. If missing or empty, all responses will be
        retrieved. Questions must be identified by full group path separated by
        slashes, e.g. `group/subgroup/question_name`.
* `filename`: Must be unique among all asset files. Only accepts letters, numbers and '-'.

 */
export type assetsPairedDataCreateResponse201 = {
  data: PairedDataResponse
  status: 201
}

export type assetsPairedDataCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsPairedDataCreateResponseComposite =
  | assetsPairedDataCreateResponse201
  | assetsPairedDataCreateResponse400

export type assetsPairedDataCreateResponse = assetsPairedDataCreateResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataCreateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/paired-data/`
}

export const assetsPairedDataCreate = async (
  uidAsset: string,
  pairedData: NonReadonly<PairedData>,
  options?: RequestInit,
): Promise<assetsPairedDataCreateResponse> => {
  return fetchWithAuth<assetsPairedDataCreateResponse>(getAssetsPairedDataCreateUrl(uidAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(pairedData),
  })
}

export const getAssetsPairedDataCreateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataCreate>>,
    TError,
    { uidAsset: string; data: NonReadonly<PairedData> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPairedDataCreate>>,
  TError,
  { uidAsset: string; data: NonReadonly<PairedData> },
  TContext
> => {
  const mutationKey = ['assetsPairedDataCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPairedDataCreate>>,
    { uidAsset: string; data: NonReadonly<PairedData> }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsPairedDataCreate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPairedDataCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataCreate>>>
export type AssetsPairedDataCreateMutationBody = NonReadonly<PairedData>
export type AssetsPairedDataCreateMutationError = ErrorObject

export const useAssetsPairedDataCreate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataCreate>>,
    TError,
    { uidAsset: string; data: NonReadonly<PairedData> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPairedDataCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve a connection between two projects

 */
export type assetsPairedDataRetrieveResponse200 = {
  data: PairedDataResponse
  status: 200
}

export type assetsPairedDataRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsPairedDataRetrieveResponseComposite =
  | assetsPairedDataRetrieveResponse200
  | assetsPairedDataRetrieveResponse404

export type assetsPairedDataRetrieveResponse = assetsPairedDataRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataRetrieveUrl = (uidAsset: string, uidPairedData: string) => {
  return `/api/v2/assets/${uidAsset}/paired-data/${uidPairedData}/`
}

export const assetsPairedDataRetrieve = async (
  uidAsset: string,
  uidPairedData: string,
  options?: RequestInit,
): Promise<assetsPairedDataRetrieveResponse> => {
  return fetchWithAuth<assetsPairedDataRetrieveResponse>(getAssetsPairedDataRetrieveUrl(uidAsset, uidPairedData), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsPairedDataRetrieveQueryKey = (uidAsset: string, uidPairedData: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'paired-data', uidPairedData] as const
}

export const getAssetsPairedDataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsPairedDataRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidPairedData: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsPairedDataRetrieveQueryKey(uidAsset, uidPairedData)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>> = ({ signal }) =>
    assetsPairedDataRetrieve(uidAsset, uidPairedData, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidPairedData), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsPairedDataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsPairedDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>>
export type AssetsPairedDataRetrieveQueryError = ErrorObject

export function useAssetsPairedDataRetrieve<
  TData = Awaited<ReturnType<typeof assetsPairedDataRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidPairedData: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsPairedDataRetrieveQueryOptions(uidAsset, uidPairedData, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update a connection between two projects

_Notes: `source` cannot be changed_

 */
export type assetsPairedDataPartialUpdateResponse200 = {
  data: PairedDataResponse
  status: 200
}

export type assetsPairedDataPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsPairedDataPartialUpdateResponseComposite =
  | assetsPairedDataPartialUpdateResponse200
  | assetsPairedDataPartialUpdateResponse400

export type assetsPairedDataPartialUpdateResponse = assetsPairedDataPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataPartialUpdateUrl = (uidAsset: string, uidPairedData: string) => {
  return `/api/v2/assets/${uidAsset}/paired-data/${uidPairedData}/`
}

export const assetsPairedDataPartialUpdate = async (
  uidAsset: string,
  uidPairedData: string,
  patchedPairedDataPatchPayload: PatchedPairedDataPatchPayload,
  options?: RequestInit,
): Promise<assetsPairedDataPartialUpdateResponse> => {
  return fetchWithAuth<assetsPairedDataPartialUpdateResponse>(
    getAssetsPairedDataPartialUpdateUrl(uidAsset, uidPairedData),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedPairedDataPatchPayload),
    },
  )
}

export const getAssetsPairedDataPartialUpdateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
    TError,
    { uidAsset: string; uidPairedData: string; data: PatchedPairedDataPatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
  TError,
  { uidAsset: string; uidPairedData: string; data: PatchedPairedDataPatchPayload },
  TContext
> => {
  const mutationKey = ['assetsPairedDataPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
    { uidAsset: string; uidPairedData: string; data: PatchedPairedDataPatchPayload }
  > = (props) => {
    const { uidAsset, uidPairedData, data } = props ?? {}

    return assetsPairedDataPartialUpdate(uidAsset, uidPairedData, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPairedDataPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>
>
export type AssetsPairedDataPartialUpdateMutationBody = PatchedPairedDataPatchPayload
export type AssetsPairedDataPartialUpdateMutationError = ErrorObject

export const useAssetsPairedDataPartialUpdate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
    TError,
    { uidAsset: string; uidPairedData: string; data: PatchedPairedDataPatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPairedDataPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Remove a connection between two projects

 */
export type assetsPairedDataDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsPairedDataDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsPairedDataDestroyResponseComposite =
  | assetsPairedDataDestroyResponse204
  | assetsPairedDataDestroyResponse404

export type assetsPairedDataDestroyResponse = assetsPairedDataDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataDestroyUrl = (uidAsset: string, uidPairedData: string) => {
  return `/api/v2/assets/${uidAsset}/paired-data/${uidPairedData}/`
}

export const assetsPairedDataDestroy = async (
  uidAsset: string,
  uidPairedData: string,
  options?: RequestInit,
): Promise<assetsPairedDataDestroyResponse> => {
  return fetchWithAuth<assetsPairedDataDestroyResponse>(getAssetsPairedDataDestroyUrl(uidAsset, uidPairedData), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsPairedDataDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
    TError,
    { uidAsset: string; uidPairedData: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
  TError,
  { uidAsset: string; uidPairedData: string },
  TContext
> => {
  const mutationKey = ['assetsPairedDataDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
    { uidAsset: string; uidPairedData: string }
  > = (props) => {
    const { uidAsset, uidPairedData } = props ?? {}

    return assetsPairedDataDestroy(uidAsset, uidPairedData, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPairedDataDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataDestroy>>>

export type AssetsPairedDataDestroyMutationError = ErrorObject

export const useAssetsPairedDataDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
    TError,
    { uidAsset: string; uidPairedData: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPairedDataDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Return an XML which contains data submitted to paired asset

Creates the endpoints
- /api/v2/assets/<uid_asset>/paired-data/<uid_paired_data>/external/
- /api/v2/assets/<uid_asset>/paired-data/<uid_paired_data>/external.xml/

 */
export type assetsPairedDataExternalRetrieveResponse200 = {
  data: ExternalResponse
  status: 200
}

export type assetsPairedDataExternalRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsPairedDataExternalRetrieveResponseComposite =
  | assetsPairedDataExternalRetrieveResponse200
  | assetsPairedDataExternalRetrieveResponse404

export type assetsPairedDataExternalRetrieveResponse = assetsPairedDataExternalRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataExternalRetrieveUrl = (uidAsset: string, uidPairedData: string) => {
  return `/api/v2/assets/${uidAsset}/paired-data/${uidPairedData}/external/`
}

export const assetsPairedDataExternalRetrieve = async (
  uidAsset: string,
  uidPairedData: string,
  options?: RequestInit,
): Promise<assetsPairedDataExternalRetrieveResponse> => {
  return fetchWithAuth<assetsPairedDataExternalRetrieveResponse>(
    getAssetsPairedDataExternalRetrieveUrl(uidAsset, uidPairedData),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsPairedDataExternalRetrieveQueryKey = (uidAsset: string, uidPairedData: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'paired-data', uidPairedData, 'external'] as const
}

export const getAssetsPairedDataExternalRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidPairedData: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsPairedDataExternalRetrieveQueryKey(uidAsset, uidPairedData)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>> = ({ signal }) =>
    assetsPairedDataExternalRetrieve(uidAsset, uidPairedData, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidPairedData), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsPairedDataExternalRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>
>
export type AssetsPairedDataExternalRetrieveQueryError = ErrorObject

export function useAssetsPairedDataExternalRetrieve<
  TData = Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidPairedData: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsPairedDataExternalRetrieveQueryOptions(uidAsset, uidPairedData, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Report of a user's asset

Returns the submission data for all deployments of a survey.
This data is grouped by answers, and does not show the data for individual submissions.
The endpoint will return a **404 NOT FOUND** error if the asset is not deployed and will only return the data for the most recently deployed version.

 */
export type assetsReportsRetrieveResponse200 = {
  data: ReportResponse
  status: 200
}

export type assetsReportsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsReportsRetrieveResponseComposite = assetsReportsRetrieveResponse200 | assetsReportsRetrieveResponse404

export type assetsReportsRetrieveResponse = assetsReportsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsReportsRetrieveUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/reports/`
}

export const assetsReportsRetrieve = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsReportsRetrieveResponse> => {
  return fetchWithAuth<assetsReportsRetrieveResponse>(getAssetsReportsRetrieveUrl(uidAsset), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsReportsRetrieveQueryKey = (uidAsset: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'reports'] as const
}

export const getAssetsReportsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsReportsRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsReportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsReportsRetrieveQueryKey(uidAsset)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsReportsRetrieve>>> = ({ signal }) =>
    assetsReportsRetrieve(uidAsset, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsReportsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsReportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsReportsRetrieve>>>
export type AssetsReportsRetrieveQueryError = ErrorObject

export function useAssetsReportsRetrieve<
  TData = Awaited<ReturnType<typeof assetsReportsRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsReportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsReportsRetrieveQueryOptions(uidAsset, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
