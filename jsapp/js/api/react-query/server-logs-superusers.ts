/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox Primary API
 * This page documents all KoboToolbox API endpoints, except for those implementing the OpenRosa protocol, which are [documented separately](/api/openrosa/docs/).

The endpoints are grouped by area of intended use. Each category contains related endpoints, with detailed documentation on usage and configuration. Use this as a reference to quickly find the right endpoint for managing projects, forms, data, permissions, integrations, logs, and organizational resources.

**General note**: All projects (whether deployed or draft), as well as all library content (questions, blocks, templates, and collections) in the user-facing application are represented in the API as "assets".
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AccessLogsListParams } from '../models/accessLogsListParams'

import type { AuditLogsListParams } from '../models/auditLogsListParams'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { ExportCreateResponse } from '../models/exportCreateResponse'

import type { ExportHistoryResponse } from '../models/exportHistoryResponse'

import type { ExportListResponse } from '../models/exportListResponse'

import type { PaginatedAccessLogResponseList } from '../models/paginatedAccessLogResponseList'

import type { PaginatedAuditLogResponseList } from '../models/paginatedAuditLogResponseList'

import type { PaginatedProjectHistoryLogResponseList } from '../models/paginatedProjectHistoryLogResponseList'

import type { PaginatedUserReportsListResponseList } from '../models/paginatedUserReportsListResponseList'

import type { ProjectHistoryLogsListParams } from '../models/projectHistoryLogsListParams'

import type { UserReportsListParams } from '../models/userReportsListParams'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List all access logs for all users

‚ö†Ô∏è _Only available to superusers_

Submissions will be grouped together by user by hour

**Filterable fields:**

- date_created
- user_uid
- user__username
- metadata__source
- metadata__auth_type
- metadata__ip_address

**Some examples:**

1. All logs from a specific IP address
    `api/v2/access-logs/?q=metadata__ip_address:"127.0.0.1"`

2. All logs created after Jan 1, 2025
    `api/v2/access-logs/?q=date_created__gte:"2025-01-01"`

*Notes: Do not forget to wrap search terms in double-quotes if they contain spaces
(e.g. date and time "2022-11-15 20:34")*

 */
export type accessLogsListResponse200 = {
  data: PaginatedAccessLogResponseList
  status: 200
}

export type accessLogsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type accessLogsListResponseComposite = accessLogsListResponse200 | accessLogsListResponse403

export type accessLogsListResponse = accessLogsListResponseComposite & {
  headers: Headers
}

export const getAccessLogsListUrl = (params?: AccessLogsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/access-logs/?${stringifiedParams}` : `/api/v2/access-logs/`
}

export const accessLogsList = async (
  params?: AccessLogsListParams,
  options?: RequestInit,
): Promise<accessLogsListResponse> => {
  return fetchWithAuth<accessLogsListResponse>(getAccessLogsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsListQueryKey = (params?: AccessLogsListParams) => {
  return ['api', 'v2', 'access-logs', ...(params ? [params] : [])] as const
}

export const getAccessLogsListQueryOptions = <TData = Awaited<ReturnType<typeof accessLogsList>>, TError = ErrorDetail>(
  params?: AccessLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsList>>> = ({ signal }) =>
    accessLogsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsList>>>
export type AccessLogsListQueryError = ErrorDetail

export function useAccessLogsList<TData = Awaited<ReturnType<typeof accessLogsList>>, TError = ErrorDetail>(
  params?: AccessLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List all access logs export tasks for all users

‚ö†Ô∏è _Only available to superusers_

 */
export type accessLogsExportListResponse200 = {
  data: ExportListResponse[]
  status: 200
}

export type accessLogsExportListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type accessLogsExportListResponseComposite = accessLogsExportListResponse200 | accessLogsExportListResponse403

export type accessLogsExportListResponse = accessLogsExportListResponseComposite & {
  headers: Headers
}

export const getAccessLogsExportListUrl = () => {
  return `/api/v2/access-logs/export/`
}

export const accessLogsExportList = async (options?: RequestInit): Promise<accessLogsExportListResponse> => {
  return fetchWithAuth<accessLogsExportListResponse>(getAccessLogsExportListUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsExportListQueryKey = () => {
  return ['api', 'v2', 'access-logs', 'export'] as const
}

export const getAccessLogsExportListQueryOptions = <
  TData = Awaited<ReturnType<typeof accessLogsExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsExportListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsExportList>>> = ({ signal }) =>
    accessLogsExportList({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsExportList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsExportListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsExportList>>>
export type AccessLogsExportListQueryError = ErrorDetail

export function useAccessLogsExportList<
  TData = Awaited<ReturnType<typeof accessLogsExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsExportListQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export task for all users

‚ö†Ô∏è _Only available to superusers_

 */
export type accessLogsExportCreateResponse202 = {
  data: ExportCreateResponse
  status: 202
}

export type accessLogsExportCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsExportCreateResponseComposite =
  | accessLogsExportCreateResponse202
  | accessLogsExportCreateResponse401

export type accessLogsExportCreateResponse = accessLogsExportCreateResponseComposite & {
  headers: Headers
}

export const getAccessLogsExportCreateUrl = () => {
  return `/api/v2/access-logs/export/`
}

export const accessLogsExportCreate = async (options?: RequestInit): Promise<accessLogsExportCreateResponse> => {
  return fetchWithAuth<accessLogsExportCreateResponse>(getAccessLogsExportCreateUrl(), {
    ...options,
    method: 'POST',
  })
}

export const getAccessLogsExportCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof accessLogsExportCreate>>, TError, void, TContext> => {
  const mutationKey = ['accessLogsExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof accessLogsExportCreate>>, void> = () => {
    return accessLogsExportCreate(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AccessLogsExportCreateMutationResult = NonNullable<Awaited<ReturnType<typeof accessLogsExportCreate>>>

export type AccessLogsExportCreateMutationError = ErrorDetail

export const useAccessLogsExportCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAccessLogsExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List actions performed by users.

‚ö†Ô∏è _Only available to superusers_

Results from this endpoint can be filtered by a Boolean query specified in the `q` parameter.

**Filterable fields:**

* app_label
* model_name
* action
  Available actions:
   * create
   * delete
   * in-trash
   * put-back
   * remove
   * update
   * auth
* log_type
  Available log types:
    * access
    * project-history
    * data-editing
    * submission-management
    * user-management
    * asset-management
* date_created
* user_uid
* user__username
* user__email
* user__is_superuser
* metadata__asset_uid
* metadata__auth_type

*Notes: Some logs may have additional filterable fields in the metadata*

**Some examples:**

* All deleted submissions
    `api/v2/audit-logs/?q=action:delete`
* All deleted submissions of a specific project `aTJ3vi2KRGYj2NytSzBPp7`
    `api/v2/audit-logs/?q=action:delete AND metadata__asset_uid:aTJ3vi2KRGYj2NytSzBPp7`
* All submissions deleted by a specific user `my_username`
    `api/v2/audit-logs/?q=action:delete AND user__username:my_username`
* All deleted submissions submitted after a specific date
    `/api/v2/audit-logs/?q=action:delete AND date_created__gte:2022-11-15`
* All deleted submissions submitted after a specific date **and time**
    `/api/v2/audit-logs/?q=action:delete AND date_created__gte:"2022-11-15 20:34"`
* All authentications from superusers
    `api/v2/audit-logs/?q=action:auth AND user__is_superuser:True`

*Notes: Do not forget to wrap search terms in double-quotes if they contain spaces
(e.g. date and time "2022-11-15 20:34")*

 */
export type auditLogsListResponse200 = {
  data: PaginatedAuditLogResponseList
  status: 200
}

export type auditLogsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type auditLogsListResponseComposite = auditLogsListResponse200 | auditLogsListResponse403

export type auditLogsListResponse = auditLogsListResponseComposite & {
  headers: Headers
}

export const getAuditLogsListUrl = (params?: AuditLogsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/audit-logs/?${stringifiedParams}` : `/api/v2/audit-logs/`
}

export const auditLogsList = async (
  params?: AuditLogsListParams,
  options?: RequestInit,
): Promise<auditLogsListResponse> => {
  return fetchWithAuth<auditLogsListResponse>(getAuditLogsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAuditLogsListQueryKey = (params?: AuditLogsListParams) => {
  return ['api', 'v2', 'audit-logs', ...(params ? [params] : [])] as const
}

export const getAuditLogsListQueryOptions = <TData = Awaited<ReturnType<typeof auditLogsList>>, TError = ErrorDetail>(
  params?: AuditLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof auditLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAuditLogsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof auditLogsList>>> = ({ signal }) =>
    auditLogsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof auditLogsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AuditLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof auditLogsList>>>
export type AuditLogsListQueryError = ErrorDetail

export function useAuditLogsList<TData = Awaited<ReturnType<typeof auditLogsList>>, TError = ErrorDetail>(
  params?: AuditLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof auditLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAuditLogsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List all project history logs for all projects.

‚ö†Ô∏è_Only available to superusers_

Results from this endpoint can be filtered by a Boolean query
specified in the `q` parameter.

**Filterable fields for all project history logs:**

* date_created
* user_uid
* user__username
* user__email
* user__is_superuser
* metadata__source
* metadata__ip_address
* metadata__asset_uid
* metadata__log_subtype
    * available subtypes: "project", "permission"
* action

available actions:

>       add-media
>       add-submission
>       allow-anonymous-submissions
>       archive
>       clone-permissions
>       connect-project
>       delete-media
>       delete-service
>       delete-submission
>       deploy
>       disable-sharing
>       disallow-anonymous-submissions
>       disconnect-project
>       enable-sharing
>       export
>       modify-imported-fields
>       modify-qa-data
>       modify-service
>       modify-sharing
>       modify-submission
>       modify-user-permissions
>       redeploy
>       register-service
>       replace-form
>       share-data-publicly
>       share-form-publicly
>       transfer
>       unarchive
>       unshare-data-publicly
>       unshare-form-publicly
>       update-content
>       update-name
>       update-settings
>       update-qa

**Filterable fields by action:**

* add-media

    a. metadata__asset-file__uid

    b. metadata__asset-file__filename

* add-submission

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

* archive

    a. metadata__latest_version_uid

* clone-permissions

    a. metadata__cloned_from

* connect-project

    a. metadata__paired-data__source_uid

    b. metadata__paired-data__source_name

* delete-media

    a. metadata__asset-file__uid

    b. metadata__asset-file__filename

* delete-service

    a. metadata__hook__uid

    b. metadata__hook__endpoint

    c. metadata__hook__active

* delete-submission

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

* deploy

    a. metadata__latest_version_uid

    b. metadata__latest_deployed_version_uid

* disconnect-project

    a. metadata__paired-data__source_uid

    b. metadata__paired-data__source_name

* modify-imported-fields

    a. metadata__paired-data__source_uid

    b. metadata__paired-data__source_name

* modify-qa-data

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

* modify-service

    a. metadata__hook__uid

    b. metadata__hook__endpoint

    c. metadata__hook__active

* modify-submission

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

    b. metadata__submission__status (only present if changed)

* modify-user-permissions

    a. metadata__permissions__username

* redeploy

    a. metadata__latest_version_uid

    b. metadata__latest_deployed_version_uid

* register-service

    a. metadata__hook__uid

    b. metadata__hook__endpoint

    c. metadata__hook__active

* transfer

    a. metadata__username

* unarchive

    a. metadata__latest_version_uid

* update-name

    a. metadata__name__old

    b. metadata__name__new

* update-settings

    a. metadata__settings__description__old

    b. metadata__settings__description__new

This endpoint can be paginated with 'offset' and 'limit' parameters

 */
export type projectHistoryLogsListResponse200 = {
  data: PaginatedProjectHistoryLogResponseList
  status: 200
}

export type projectHistoryLogsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectHistoryLogsListResponseComposite =
  | projectHistoryLogsListResponse200
  | projectHistoryLogsListResponse403

export type projectHistoryLogsListResponse = projectHistoryLogsListResponseComposite & {
  headers: Headers
}

export const getProjectHistoryLogsListUrl = (params?: ProjectHistoryLogsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/project-history-logs/?${stringifiedParams}`
    : `/api/v2/project-history-logs/`
}

export const projectHistoryLogsList = async (
  params?: ProjectHistoryLogsListParams,
  options?: RequestInit,
): Promise<projectHistoryLogsListResponse> => {
  return fetchWithAuth<projectHistoryLogsListResponse>(getProjectHistoryLogsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getProjectHistoryLogsListQueryKey = (params?: ProjectHistoryLogsListParams) => {
  return ['api', 'v2', 'project-history-logs', ...(params ? [params] : [])] as const
}

export const getProjectHistoryLogsListQueryOptions = <
  TData = Awaited<ReturnType<typeof projectHistoryLogsList>>,
  TError = ErrorDetail,
>(
  params?: ProjectHistoryLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectHistoryLogsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectHistoryLogsList>>> = ({ signal }) =>
    projectHistoryLogsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectHistoryLogsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectHistoryLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof projectHistoryLogsList>>>
export type ProjectHistoryLogsListQueryError = ErrorDetail

export function useProjectHistoryLogsList<
  TData = Awaited<ReturnType<typeof projectHistoryLogsList>>,
  TError = ErrorDetail,
>(
  params?: ProjectHistoryLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectHistoryLogsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List of Project History Exports

‚ö†Ô∏è _Only available to superusers_

 */
export type projectHistoryLogsExportRetrieveResponse202 = {
  data: ExportHistoryResponse
  status: 202
}

export type projectHistoryLogsExportRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectHistoryLogsExportRetrieveResponseComposite =
  | projectHistoryLogsExportRetrieveResponse202
  | projectHistoryLogsExportRetrieveResponse403

export type projectHistoryLogsExportRetrieveResponse = projectHistoryLogsExportRetrieveResponseComposite & {
  headers: Headers
}

export const getProjectHistoryLogsExportRetrieveUrl = () => {
  return `/api/v2/project-history-logs/export/`
}

export const projectHistoryLogsExportRetrieve = async (
  options?: RequestInit,
): Promise<projectHistoryLogsExportRetrieveResponse> => {
  return fetchWithAuth<projectHistoryLogsExportRetrieveResponse>(getProjectHistoryLogsExportRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getProjectHistoryLogsExportRetrieveQueryKey = () => {
  return ['api', 'v2', 'project-history-logs', 'export'] as const
}

export const getProjectHistoryLogsExportRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectHistoryLogsExportRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>> = ({ signal }) =>
    projectHistoryLogsExportRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectHistoryLogsExportRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>
>
export type ProjectHistoryLogsExportRetrieveQueryError = ErrorDetail

export function useProjectHistoryLogsExportRetrieve<
  TData = Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectHistoryLogsExportRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export of projects history logs

‚ö†Ô∏è _Only available to superusers_

Export project history logs and send it by email to the requesting user.

 */
export type projectHistoryLogsExportCreateResponse202 = {
  data: ExportHistoryResponse
  status: 202
}

export type projectHistoryLogsExportCreateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectHistoryLogsExportCreateResponseComposite =
  | projectHistoryLogsExportCreateResponse202
  | projectHistoryLogsExportCreateResponse403

export type projectHistoryLogsExportCreateResponse = projectHistoryLogsExportCreateResponseComposite & {
  headers: Headers
}

export const getProjectHistoryLogsExportCreateUrl = () => {
  return `/api/v2/project-history-logs/export/`
}

export const projectHistoryLogsExportCreate = async (
  options?: RequestInit,
): Promise<projectHistoryLogsExportCreateResponse> => {
  return fetchWithAuth<projectHistoryLogsExportCreateResponse>(getProjectHistoryLogsExportCreateUrl(), {
    ...options,
    method: 'POST',
  })
}

export const getProjectHistoryLogsExportCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, TError, void, TContext> => {
  const mutationKey = ['projectHistoryLogsExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, void> = () => {
    return projectHistoryLogsExportCreate(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProjectHistoryLogsExportCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>
>

export type ProjectHistoryLogsExportCreateMutationError = ErrorDetail

export const useProjectHistoryLogsExportCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getProjectHistoryLogsExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * # List user reports

‚ö†Ô∏è _Only available to superusers_

## Filterable fields by string:

Supports partial filtering
- username
- first_name
- last_name
- email
- user_uid
- organization__name
- organization__role (e.g., admin, member, owner)
- extra_details__data__organization_type
- `extra_details__data__<field>` (other string fields, e.g., name, sector, country...)

## Filterable fields by int:

Supports exact matching and range operators (e.g., gte, lte)

**Total NLP Usage**
- service_usage__total_nlp_usage__asr_seconds_all_time
- service_usage__total_nlp_usage__mt_characters_all_time
- service_usage__total_nlp_usage__asr_seconds_current_period
- service_usage__total_nlp_usage__mt_characters_current_period

**Total Storage/Submissions**
- service_usage__total_storage_bytes
- service_usage__total_submission_count__all_time
- service_usage__total_submission_count__current_period

**Service Usage Balances**

Prefix: `service_usage__balances__<metric>__<value>`

Metric:
- submission
- asr_seconds
- mt_characters
- storage_bytes

Value:
- balance_value
- balance_percent
- effective_limit

Ex: `service_usage__balances__submission__balance_value`

**Asset Count**
- asset_count
- deployed_asset_count

## Filterable fields by date:
Supports exact matching and range operators (e.g., gte, lte)

- date_joined
- last_login
- extra_details__date_removal_requested
- extra_details__date_removed
- extra_details_password_date_changed

## Filterable fields by boolean:

- is_superuser
- is_staff
- is_active
- validated_email
- extra_details__validated_password
- mfa_is_active
- sso_is_active
- accepted_tos
- extra_details__data__newsletter_subscription
- extra_details__data__done_storage_limits_check
- service_usage__balances__*metric*__exceeded (metric: submission, asr_seconds, mt_characters, storage_bytes)
- account_restricted

## Filterable fields by list:

Subscription filtering:

Has subscriptions

`?q=subscriptions__0__id__isnull:False`

No subscriptions

`?q=subscriptions__0__id__isnull:True`

Subscription id

`?q=subscriptions[]__id:sub_1QwPItAR39rDI89stzLJ040p`

Active subscriptions

`?q=subscriptions[]__status:active`

 */
export type userReportsListResponse200 = {
  data: PaginatedUserReportsListResponseList
  status: 200
}

export type userReportsListResponse400 = {
  data: ErrorObject
  status: 400
}

export type userReportsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type userReportsListResponseComposite =
  | userReportsListResponse200
  | userReportsListResponse400
  | userReportsListResponse403

export type userReportsListResponse = userReportsListResponseComposite & {
  headers: Headers
}

export const getUserReportsListUrl = (params?: UserReportsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/user-reports/?${stringifiedParams}` : `/api/v2/user-reports/`
}

export const userReportsList = async (
  params?: UserReportsListParams,
  options?: RequestInit,
): Promise<userReportsListResponse> => {
  return fetchWithAuth<userReportsListResponse>(getUserReportsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getUserReportsListQueryKey = (params?: UserReportsListParams) => {
  return ['api', 'v2', 'user-reports', ...(params ? [params] : [])] as const
}

export const getUserReportsListQueryOptions = <
  TData = Awaited<ReturnType<typeof userReportsList>>,
  TError = ErrorObject | ErrorDetail,
>(
  params?: UserReportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof userReportsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getUserReportsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userReportsList>>> = ({ signal }) =>
    userReportsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userReportsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type UserReportsListQueryResult = NonNullable<Awaited<ReturnType<typeof userReportsList>>>
export type UserReportsListQueryError = ErrorObject | ErrorDetail

export function useUserReportsList<
  TData = Awaited<ReturnType<typeof userReportsList>>,
  TError = ErrorObject | ErrorDetail,
>(
  params?: UserReportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof userReportsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUserReportsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
