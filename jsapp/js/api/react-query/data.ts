/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AssetsDataListParams } from '../models/assetsDataListParams'

import type { AssetsDataRetrieveParams } from '../models/assetsDataRetrieveParams'

import type { DataBulkDelete } from '../models/dataBulkDelete'

import type { DataBulkUpdateResponse } from '../models/dataBulkUpdateResponse'

import type { DataResponse } from '../models/dataResponse'

import type { DataStatusesUpdate } from '../models/dataStatusesUpdate'

import type { DataValidationStatusUpdateResponse } from '../models/dataValidationStatusUpdateResponse'

import type { EnketoEditResponse } from '../models/enketoEditResponse'

import type { EnketoViewResponse } from '../models/enketoViewResponse'

import type { ErrorDetail } from '../models/errorDetail'

import type { PaginatedDataResponseList } from '../models/paginatedDataResponseList'

import type { PatchedDataBulkUpdate } from '../models/patchedDataBulkUpdate'

import type { PatchedDataValidationStatusUpdatePayload } from '../models/patchedDataValidationStatusUpdatePayload'

import type { PatchedDataValidationStatusesUpdatePayload } from '../models/patchedDataValidationStatusesUpdatePayload'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List of submissions for a specific asset

By default, JSON format is used, but XML and GeoJSON are also available:

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/
```

### Pagination
Two parameters can be used to control pagination.

* `start`: Index (zero-based) from which the results start
* `limit`: Number of results per page <span class='label label-warning'>Maximum results per page is **30000**</span>

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/?start=0&limit=10
```

### Query submitted data
Provides a list of submitted data for a specific form. Use `query`
parameter to apply form data specific, see
<a href="http://docs.mongodb.org/manual/reference/operator/query/">http://docs.mongodb.org/manual/reference/operator/query/</a>.

For more details see
<a href="https://github.com/SEL-Columbia/formhub/wiki/Formhub-Access-Points-(API)#api-parameters">API Parameters</a>.

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/?query={"__version__": "vWvkKzNE8xCtfApJvabfjG"}
curl https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/?query={"_submission_time": {"$gt": "2019-09-01T01:02:03"}}
```

### About the GeoJSON format
Requesting the `geojson` format returns a `FeatureCollection` where each
submission is a `Feature`. If your form has multiple geographic questions,
use the `geo_question_name` query parameter to determine which question's
responses populate the `geometry` for each `Feature`; otherwise, the first
geographic question is used.  All question/response pairs are included in
the `properties` of each `Feature`, but _repeating groups are omitted_.

Question types are mapped to GeoJSON geometry types as follows:

* `geopoint` to `Point`;
* `geotrace` to `LineString`;
* `geoshape` to `Polygon`.



### ‚ö†Ô∏è Note: DRF-Spectacular Limitation

Due to limitations in **DRF-Spectacular**, the `ACCEPT` headers do not sync properly with the request. As a result, all responses will default to `application/json`, regardless of the specified format.

This means that while alternative formats (like XML) are technically supported and will work via command-line tools (e.g., `curl`), **they will not work** when trying out the endpoint directly from the documentation page.

We‚Äôve still included the header to show supported formats, but keep in mind:
**Only `application/json` will be used in the docs UI.**


 */
export type assetsDataListResponse200 = {
  data: PaginatedDataResponseList
  status: 200
}

export type assetsDataListResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataListResponseComposite = assetsDataListResponse200 | assetsDataListResponse404

export type assetsDataListResponse = assetsDataListResponseComposite & {
  headers: Headers
}

export const getAssetsDataListUrl = (parentLookupAsset: string, params?: AssetsDataListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${parentLookupAsset}/data/?${stringifiedParams}`
    : `/api/v2/assets/${parentLookupAsset}/data/`
}

export const assetsDataList = async (
  parentLookupAsset: string,
  params?: AssetsDataListParams,
  options?: RequestInit,
): Promise<assetsDataListResponse> => {
  return fetchWithAuth<assetsDataListResponse>(getAssetsDataListUrl(parentLookupAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataListQueryKey = (parentLookupAsset: string, params?: AssetsDataListParams) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', ...(params ? [params] : [])] as const
}

export const getAssetsDataListQueryOptions = <TData = Awaited<ReturnType<typeof assetsDataList>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  params?: AssetsDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataListQueryKey(parentLookupAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataList>>> = ({ signal }) =>
    assetsDataList(parentLookupAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!parentLookupAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDataList>>>
export type AssetsDataListQueryError = ErrorDetail

export function useAssetsDataList<TData = Awaited<ReturnType<typeof assetsDataList>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  params?: AssetsDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataListQueryOptions(parentLookupAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get a specific submission
It is also possible to specify the format.

`id` can be the primary key of the submission or its `uuid`.
Please note that using the `uuid` may match **several** submissions, only
the first match will be returned.

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}.xml
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}.json
```

or

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}/?format=xml
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{uid}/data/{id}/?format=json
```


### ‚ö†Ô∏è Note: DRF-Spectacular Limitation

Due to limitations in **DRF-Spectacular**, the `ACCEPT` headers do not sync properly with the request. As a result, all responses will default to `application/json`, regardless of the specified format.

This means that while alternative formats (like XML) are technically supported and will work via command-line tools (e.g., `curl`), **they will not work** when trying out the endpoint directly from the documentation page.

We‚Äôve still included the header to show supported formats, but keep in mind:
**Only `application/json` will be used in the docs UI.**

 */
export type assetsDataRetrieveResponse200 = {
  data: DataResponse
  status: 200
}

export type assetsDataRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataRetrieveResponseComposite = assetsDataRetrieveResponse200 | assetsDataRetrieveResponse404

export type assetsDataRetrieveResponse = assetsDataRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataRetrieveUrl = (parentLookupAsset: string, id: number, params?: AssetsDataRetrieveParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${parentLookupAsset}/data/${id}/?${stringifiedParams}`
    : `/api/v2/assets/${parentLookupAsset}/data/${id}/`
}

export const assetsDataRetrieve = async (
  parentLookupAsset: string,
  id: number,
  params?: AssetsDataRetrieveParams,
  options?: RequestInit,
): Promise<assetsDataRetrieveResponse> => {
  return fetchWithAuth<assetsDataRetrieveResponse>(getAssetsDataRetrieveUrl(parentLookupAsset, id, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataRetrieveQueryKey = (
  parentLookupAsset: string,
  id: number,
  params?: AssetsDataRetrieveParams,
) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', id, ...(params ? [params] : [])] as const
}

export const getAssetsDataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  params?: AssetsDataRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataRetrieveQueryKey(parentLookupAsset, id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataRetrieve>>> = ({ signal }) =>
    assetsDataRetrieve(parentLookupAsset, id, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDataRetrieve>>>
export type AssetsDataRetrieveQueryError = ErrorDetail

export function useAssetsDataRetrieve<TData = Awaited<ReturnType<typeof assetsDataRetrieve>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  id: number,
  params?: AssetsDataRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataRetrieveQueryOptions(parentLookupAsset, id, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Deletes current submission

 */
export type assetsDataDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDataDestroyResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataDestroyResponseComposite = assetsDataDestroyResponse204 | assetsDataDestroyResponse404

export type assetsDataDestroyResponse = assetsDataDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataDestroyUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/`
}

export const assetsDataDestroy = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataDestroyResponse> => {
  return fetchWithAuth<assetsDataDestroyResponse>(getAssetsDataDestroyUrl(parentLookupAsset, id), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsDataDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDestroy>>,
    TError,
    { parentLookupAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataDestroy>>,
  TError,
  { parentLookupAsset: string; id: number },
  TContext
> => {
  const mutationKey = ['assetsDataDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataDestroy>>,
    { parentLookupAsset: string; id: number }
  > = (props) => {
    const { parentLookupAsset, id } = props ?? {}

    return assetsDataDestroy(parentLookupAsset, id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDataDestroy>>>

export type AssetsDataDestroyMutationError = ErrorDetail

export const useAssetsDataDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDestroy>>,
    TError,
    { parentLookupAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Duplicate submission
Duplicates the data of a submission

 */
export type assetsDataDuplicateCreateResponse200 = {
  data: DataResponse
  status: 200
}

export type assetsDataDuplicateCreateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataDuplicateCreateResponseComposite =
  | assetsDataDuplicateCreateResponse200
  | assetsDataDuplicateCreateResponse404

export type assetsDataDuplicateCreateResponse = assetsDataDuplicateCreateResponseComposite & {
  headers: Headers
}

export const getAssetsDataDuplicateCreateUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/duplicate/`
}

export const assetsDataDuplicateCreate = async (
  parentLookupAsset: string,
  id: number,
  dataBulkDelete: DataBulkDelete,
  options?: RequestInit,
): Promise<assetsDataDuplicateCreateResponse> => {
  return fetchWithAuth<assetsDataDuplicateCreateResponse>(getAssetsDataDuplicateCreateUrl(parentLookupAsset, id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(dataBulkDelete),
  })
}

export const getAssetsDataDuplicateCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
    TError,
    { parentLookupAsset: string; id: number; data: DataBulkDelete },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
  TError,
  { parentLookupAsset: string; id: number; data: DataBulkDelete },
  TContext
> => {
  const mutationKey = ['assetsDataDuplicateCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
    { parentLookupAsset: string; id: number; data: DataBulkDelete }
  > = (props) => {
    const { parentLookupAsset, id, data } = props ?? {}

    return assetsDataDuplicateCreate(parentLookupAsset, id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataDuplicateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDataDuplicateCreate>>>
export type AssetsDataDuplicateCreateMutationBody = DataBulkDelete
export type AssetsDataDuplicateCreateMutationError = ErrorDetail

export const useAssetsDataDuplicateCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataDuplicateCreate>>,
    TError,
    { parentLookupAsset: string; id: number; data: DataBulkDelete },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataDuplicateCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Get submission url of enketo in edit mode

Note: Some variation of this url exists:

`/api/v2/assets/{parent_lookup_asset}/data/{id}/edit/`: deprecated, use the next one.

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/edit/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/redirect/edit/`: redirect to the enketo url submission with a 302 HTTP code.

 */
export type assetsDataEditRetrieveResponse200 = {
  data: EnketoEditResponse
  status: 200
}

export type assetsDataEditRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEditRetrieveResponseComposite =
  | assetsDataEditRetrieveResponse200
  | assetsDataEditRetrieveResponse403

export type assetsDataEditRetrieveResponse = assetsDataEditRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEditRetrieveUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/edit/`
}

export const assetsDataEditRetrieve = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEditRetrieveResponse> => {
  return fetchWithAuth<assetsDataEditRetrieveResponse>(getAssetsDataEditRetrieveUrl(parentLookupAsset, id), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDataEditRetrieveQueryKey = (parentLookupAsset: string, id: number) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', id, 'edit'] as const
}

export const getAssetsDataEditRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEditRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEditRetrieveQueryKey(parentLookupAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEditRetrieve>>> = ({ signal }) =>
    assetsDataEditRetrieve(parentLookupAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEditRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEditRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDataEditRetrieve>>>
export type AssetsDataEditRetrieveQueryError = ErrorDetail

export function useAssetsDataEditRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEditRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEditRetrieveQueryOptions(parentLookupAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in edit mode

Note: Some variation of this url exists:

`/api/v2/assets/{parent_lookup_asset}/data/{id}/edit/`: deprecated, use the next one.

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/edit/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/redirect/edit/`: redirect to the enketo url submission with a 302 HTTP code.

 */
export type assetsDataEnketoEditRetrieveResponse200 = {
  data: EnketoEditResponse
  status: 200
}

export type assetsDataEnketoEditRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoEditRetrieveResponseComposite =
  | assetsDataEnketoEditRetrieveResponse200
  | assetsDataEnketoEditRetrieveResponse403

export type assetsDataEnketoEditRetrieveResponse = assetsDataEnketoEditRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoEditRetrieveUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/enketo/edit/`
}

export const assetsDataEnketoEditRetrieve = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoEditRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoEditRetrieveResponse>(
    getAssetsDataEnketoEditRetrieveUrl(parentLookupAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataEnketoEditRetrieveQueryKey = (parentLookupAsset: string, id: number) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', id, 'enketo', 'edit'] as const
}

export const getAssetsDataEnketoEditRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoEditRetrieveQueryKey(parentLookupAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>> = ({ signal }) =>
    assetsDataEnketoEditRetrieve(parentLookupAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoEditRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>
>
export type AssetsDataEnketoEditRetrieveQueryError = ErrorDetail

export function useAssetsDataEnketoEditRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoEditRetrieveQueryOptions(parentLookupAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in edit mode

Note: Some variation of this url exists:

`/api/v2/assets/{parent_lookup_asset}/data/{id}/edit/`: deprecated, use the next one.

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/edit/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/redirect/edit/`: redirect to the enketo url submission with a 302 HTTP code.

 */
export type assetsDataEnketoRedirectEditRetrieveResponse200 = {
  data: EnketoEditResponse
  status: 200
}

export type assetsDataEnketoRedirectEditRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoRedirectEditRetrieveResponseComposite =
  | assetsDataEnketoRedirectEditRetrieveResponse200
  | assetsDataEnketoRedirectEditRetrieveResponse403

export type assetsDataEnketoRedirectEditRetrieveResponse = assetsDataEnketoRedirectEditRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoRedirectEditRetrieveUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/enketo/redirect/edit/`
}

export const assetsDataEnketoRedirectEditRetrieve = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoRedirectEditRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoRedirectEditRetrieveResponse>(
    getAssetsDataEnketoRedirectEditRetrieveUrl(parentLookupAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataEnketoRedirectEditRetrieveQueryKey = (parentLookupAsset: string, id: number) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', id, 'enketo', 'redirect', 'edit'] as const
}

export const getAssetsDataEnketoRedirectEditRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoRedirectEditRetrieveQueryKey(parentLookupAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>> = ({ signal }) =>
    assetsDataEnketoRedirectEditRetrieve(parentLookupAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoRedirectEditRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>
>
export type AssetsDataEnketoRedirectEditRetrieveQueryError = ErrorDetail

export function useAssetsDataEnketoRedirectEditRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectEditRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoRedirectEditRetrieveQueryOptions(parentLookupAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in preview mode

Note: Some variation of this url exists:

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/view/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/redirect/view/`: redirect to the enketo url submission with a 302 code.

 */
export type assetsDataEnketoRedirectViewRetrieveResponse200 = {
  data: EnketoViewResponse
  status: 200
}

export type assetsDataEnketoRedirectViewRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoRedirectViewRetrieveResponseComposite =
  | assetsDataEnketoRedirectViewRetrieveResponse200
  | assetsDataEnketoRedirectViewRetrieveResponse403

export type assetsDataEnketoRedirectViewRetrieveResponse = assetsDataEnketoRedirectViewRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoRedirectViewRetrieveUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/enketo/redirect/view/`
}

export const assetsDataEnketoRedirectViewRetrieve = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoRedirectViewRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoRedirectViewRetrieveResponse>(
    getAssetsDataEnketoRedirectViewRetrieveUrl(parentLookupAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataEnketoRedirectViewRetrieveQueryKey = (parentLookupAsset: string, id: number) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', id, 'enketo', 'redirect', 'view'] as const
}

export const getAssetsDataEnketoRedirectViewRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoRedirectViewRetrieveQueryKey(parentLookupAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>> = ({ signal }) =>
    assetsDataEnketoRedirectViewRetrieve(parentLookupAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoRedirectViewRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>
>
export type AssetsDataEnketoRedirectViewRetrieveQueryError = ErrorDetail

export function useAssetsDataEnketoRedirectViewRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoRedirectViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoRedirectViewRetrieveQueryOptions(parentLookupAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get submission url of enketo in preview mode

Note: Some variation of this url exists:

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/view/`: return the url of the enketo submission (as seen in the response example).

`/api/v2/assets/{parent_lookup_asset}/data/{id}/enketo/redirect/view/`: redirect to the enketo url submission with a 302 code.

 */
export type assetsDataEnketoViewRetrieveResponse200 = {
  data: EnketoViewResponse
  status: 200
}

export type assetsDataEnketoViewRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsDataEnketoViewRetrieveResponseComposite =
  | assetsDataEnketoViewRetrieveResponse200
  | assetsDataEnketoViewRetrieveResponse403

export type assetsDataEnketoViewRetrieveResponse = assetsDataEnketoViewRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataEnketoViewRetrieveUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/enketo/view/`
}

export const assetsDataEnketoViewRetrieve = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataEnketoViewRetrieveResponse> => {
  return fetchWithAuth<assetsDataEnketoViewRetrieveResponse>(
    getAssetsDataEnketoViewRetrieveUrl(parentLookupAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataEnketoViewRetrieveQueryKey = (parentLookupAsset: string, id: number) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', id, 'enketo', 'view'] as const
}

export const getAssetsDataEnketoViewRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataEnketoViewRetrieveQueryKey(parentLookupAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>> = ({ signal }) =>
    assetsDataEnketoViewRetrieve(parentLookupAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataEnketoViewRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>
>
export type AssetsDataEnketoViewRetrieveQueryError = ErrorDetail

export function useAssetsDataEnketoViewRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataEnketoViewRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataEnketoViewRetrieveQueryOptions(parentLookupAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get validation statuses
Retrieves the validation status of a submission.

 */
export type assetsDataValidationStatusRetrieveResponse200 = {
  data: DataValidationStatusUpdateResponse
  status: 200
}

export type assetsDataValidationStatusRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataValidationStatusRetrieveResponseComposite =
  | assetsDataValidationStatusRetrieveResponse200
  | assetsDataValidationStatusRetrieveResponse404

export type assetsDataValidationStatusRetrieveResponse = assetsDataValidationStatusRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDataValidationStatusRetrieveUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/validation_status/`
}

export const assetsDataValidationStatusRetrieve = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataValidationStatusRetrieveResponse> => {
  return fetchWithAuth<assetsDataValidationStatusRetrieveResponse>(
    getAssetsDataValidationStatusRetrieveUrl(parentLookupAsset, id),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsDataValidationStatusRetrieveQueryKey = (parentLookupAsset: string, id: number) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'data', id, 'validation_status'] as const
}

export const getAssetsDataValidationStatusRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDataValidationStatusRetrieveQueryKey(parentLookupAsset, id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>> = ({ signal }) =>
    assetsDataValidationStatusRetrieve(parentLookupAsset, id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && id), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDataValidationStatusRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>
>
export type AssetsDataValidationStatusRetrieveQueryError = ErrorDetail

export function useAssetsDataValidationStatusRetrieve<
  TData = Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDataValidationStatusRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDataValidationStatusRetrieveQueryOptions(parentLookupAsset, id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update the validation of a submission

The validation status of the submission can be updated. The `validation_status.uid` should be a `string`, and it must be one of the following values:

- `validation_status_approved`
- `validation_status_not_approved`
- `validation_status_on_hold`

 */
export type assetsDataValidationStatusPartialUpdateResponse200 = {
  data: DataValidationStatusUpdateResponse
  status: 200
}

export type assetsDataValidationStatusPartialUpdateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataValidationStatusPartialUpdateResponseComposite =
  | assetsDataValidationStatusPartialUpdateResponse200
  | assetsDataValidationStatusPartialUpdateResponse404

export type assetsDataValidationStatusPartialUpdateResponse =
  assetsDataValidationStatusPartialUpdateResponseComposite & {
    headers: Headers
  }

export const getAssetsDataValidationStatusPartialUpdateUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/validation_status/`
}

export const assetsDataValidationStatusPartialUpdate = async (
  parentLookupAsset: string,
  id: number,
  patchedDataValidationStatusUpdatePayload: PatchedDataValidationStatusUpdatePayload,
  options?: RequestInit,
): Promise<assetsDataValidationStatusPartialUpdateResponse> => {
  return fetchWithAuth<assetsDataValidationStatusPartialUpdateResponse>(
    getAssetsDataValidationStatusPartialUpdateUrl(parentLookupAsset, id),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedDataValidationStatusUpdatePayload),
    },
  )
}

export const getAssetsDataValidationStatusPartialUpdateMutationOptions = <
  TError = ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
    TError,
    { parentLookupAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
  TError,
  { parentLookupAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
    { parentLookupAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload }
  > = (props) => {
    const { parentLookupAsset, id, data } = props ?? {}

    return assetsDataValidationStatusPartialUpdate(parentLookupAsset, id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>
>
export type AssetsDataValidationStatusPartialUpdateMutationBody = PatchedDataValidationStatusUpdatePayload
export type AssetsDataValidationStatusPartialUpdateMutationError = ErrorDetail

export const useAssetsDataValidationStatusPartialUpdate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusPartialUpdate>>,
    TError,
    { parentLookupAsset: string; id: number; data: PatchedDataValidationStatusUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete validation status

 */
export type assetsDataValidationStatusDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDataValidationStatusDestroyResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataValidationStatusDestroyResponseComposite =
  | assetsDataValidationStatusDestroyResponse204
  | assetsDataValidationStatusDestroyResponse404

export type assetsDataValidationStatusDestroyResponse = assetsDataValidationStatusDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataValidationStatusDestroyUrl = (parentLookupAsset: string, id: number) => {
  return `/api/v2/assets/${parentLookupAsset}/data/${id}/validation_status/`
}

export const assetsDataValidationStatusDestroy = async (
  parentLookupAsset: string,
  id: number,
  options?: RequestInit,
): Promise<assetsDataValidationStatusDestroyResponse> => {
  return fetchWithAuth<assetsDataValidationStatusDestroyResponse>(
    getAssetsDataValidationStatusDestroyUrl(parentLookupAsset, id),
    {
      ...options,
      method: 'DELETE',
    },
  )
}

export const getAssetsDataValidationStatusDestroyMutationOptions = <
  TError = ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
    TError,
    { parentLookupAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
  TError,
  { parentLookupAsset: string; id: number },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
    { parentLookupAsset: string; id: number }
  > = (props) => {
    const { parentLookupAsset, id } = props ?? {}

    return assetsDataValidationStatusDestroy(parentLookupAsset, id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>
>

export type AssetsDataValidationStatusDestroyMutationError = ErrorDetail

export const useAssetsDataValidationStatusDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusDestroy>>,
    TError,
    { parentLookupAsset: string; id: number },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Bulk updating of submissions

Where `<field_to_update_n>` is a string and should be an existing XML field value of the submissions.
If `<field_to_update_n>` is part of a group or nested group, the field must follow the group hierarchy
structure, i.e.:

If the field is within a group called `group_1`, the field name is `question_1` and the new value is `new value`,
the payload should contain an item with the following structure:

*"group_1/question_1": "new value"*


Similarly, if there are `N` nested groups, the structure will be:

*"group_1/sub_group_1/.../sub_group_n/question_1": "new value"*

 */
export type assetsDataBulkPartialUpdateResponse200 = {
  data: DataBulkUpdateResponse
  status: 200
}

export type assetsDataBulkPartialUpdateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataBulkPartialUpdateResponseComposite =
  | assetsDataBulkPartialUpdateResponse200
  | assetsDataBulkPartialUpdateResponse404

export type assetsDataBulkPartialUpdateResponse = assetsDataBulkPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsDataBulkPartialUpdateUrl = (parentLookupAsset: string) => {
  return `/api/v2/assets/${parentLookupAsset}/data/bulk/`
}

export const assetsDataBulkPartialUpdate = async (
  parentLookupAsset: string,
  patchedDataBulkUpdate: PatchedDataBulkUpdate,
  options?: RequestInit,
): Promise<assetsDataBulkPartialUpdateResponse> => {
  return fetchWithAuth<assetsDataBulkPartialUpdateResponse>(getAssetsDataBulkPartialUpdateUrl(parentLookupAsset), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedDataBulkUpdate),
  })
}

export const getAssetsDataBulkPartialUpdateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
    TError,
    { parentLookupAsset: string; data: PatchedDataBulkUpdate },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
  TError,
  { parentLookupAsset: string; data: PatchedDataBulkUpdate },
  TContext
> => {
  const mutationKey = ['assetsDataBulkPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
    { parentLookupAsset: string; data: PatchedDataBulkUpdate }
  > = (props) => {
    const { parentLookupAsset, data } = props ?? {}

    return assetsDataBulkPartialUpdate(parentLookupAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataBulkPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>
>
export type AssetsDataBulkPartialUpdateMutationBody = PatchedDataBulkUpdate
export type AssetsDataBulkPartialUpdateMutationError = ErrorDetail

export const useAssetsDataBulkPartialUpdate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkPartialUpdate>>,
    TError,
    { parentLookupAsset: string; data: PatchedDataBulkUpdate },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataBulkPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Bulk delete submissions

```curl
  curl -X DELETE https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/bulk/
```

**Payload**
```json
{
           "submissions_ids": [
               1,
               2
           ]
        }
```
* Where: `submissions_ids` (required) is a list of submission root id on the data
to delete


**Response**
```json
{
           "detail": "{number_of_submissions} submissions have been deleted"
}
```
* Where: `number_of_submissions` is the number of items that was deleted


### !! Due to limitations with DRF-Spectacular current version not fully supporting AOS 3.1, DELETE actions do not support showing a request body OR a response body. This is due to the 'vague' nature of the action which generally does *not* recommend the use of a payload. To still document this endpoint, example for the payload and response will be included but it will not be possible to test this endpoint. The HTTP code and the errors example are, for their part, factual and can be considered when working with the endpoint. !!

 */
export type assetsDataBulkDestroyResponse200 = {
  data: void
  status: 200
}

export type assetsDataBulkDestroyResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataBulkDestroyResponseComposite = assetsDataBulkDestroyResponse200 | assetsDataBulkDestroyResponse404

export type assetsDataBulkDestroyResponse = assetsDataBulkDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataBulkDestroyUrl = (parentLookupAsset: string) => {
  return `/api/v2/assets/${parentLookupAsset}/data/bulk/`
}

export const assetsDataBulkDestroy = async (
  parentLookupAsset: string,
  options?: RequestInit,
): Promise<assetsDataBulkDestroyResponse> => {
  return fetchWithAuth<assetsDataBulkDestroyResponse>(getAssetsDataBulkDestroyUrl(parentLookupAsset), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsDataBulkDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkDestroy>>,
    TError,
    { parentLookupAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataBulkDestroy>>,
  TError,
  { parentLookupAsset: string },
  TContext
> => {
  const mutationKey = ['assetsDataBulkDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataBulkDestroy>>,
    { parentLookupAsset: string }
  > = (props) => {
    const { parentLookupAsset } = props ?? {}

    return assetsDataBulkDestroy(parentLookupAsset, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataBulkDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDataBulkDestroy>>>

export type AssetsDataBulkDestroyMutationError = ErrorDetail

export const useAssetsDataBulkDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataBulkDestroy>>,
    TError,
    { parentLookupAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataBulkDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Bulk update submissions status

* Where: "submissions_ids" (required) is a list of submission root id on the data
to delete
* Where: "validation_status.uid" (required)  is a string and can be one of these values:
  * `validation_status_approved`
  * `validation_status_not_approved`
  * `validation_status_on_hold`

Will return the number of submission updated as such:
> **Response**
>
>        {
>           "detail": "{number_of_submissions} submissions have been updated"
>        }

 */
export type assetsDataValidationStatusesPartialUpdateResponse200 = {
  data: DataStatusesUpdate
  status: 200
}

export type assetsDataValidationStatusesPartialUpdateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataValidationStatusesPartialUpdateResponseComposite =
  | assetsDataValidationStatusesPartialUpdateResponse200
  | assetsDataValidationStatusesPartialUpdateResponse404

export type assetsDataValidationStatusesPartialUpdateResponse =
  assetsDataValidationStatusesPartialUpdateResponseComposite & {
    headers: Headers
  }

export const getAssetsDataValidationStatusesPartialUpdateUrl = (parentLookupAsset: string) => {
  return `/api/v2/assets/${parentLookupAsset}/data/validation_statuses/`
}

export const assetsDataValidationStatusesPartialUpdate = async (
  parentLookupAsset: string,
  patchedDataValidationStatusesUpdatePayload: PatchedDataValidationStatusesUpdatePayload,
  options?: RequestInit,
): Promise<assetsDataValidationStatusesPartialUpdateResponse> => {
  return fetchWithAuth<assetsDataValidationStatusesPartialUpdateResponse>(
    getAssetsDataValidationStatusesPartialUpdateUrl(parentLookupAsset),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedDataValidationStatusesUpdatePayload),
    },
  )
}

export const getAssetsDataValidationStatusesPartialUpdateMutationOptions = <
  TError = ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
    TError,
    { parentLookupAsset: string; data: PatchedDataValidationStatusesUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
  TError,
  { parentLookupAsset: string; data: PatchedDataValidationStatusesUpdatePayload },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusesPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
    { parentLookupAsset: string; data: PatchedDataValidationStatusesUpdatePayload }
  > = (props) => {
    const { parentLookupAsset, data } = props ?? {}

    return assetsDataValidationStatusesPartialUpdate(parentLookupAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusesPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>
>
export type AssetsDataValidationStatusesPartialUpdateMutationBody = PatchedDataValidationStatusesUpdatePayload
export type AssetsDataValidationStatusesPartialUpdateMutationError = ErrorDetail

export const useAssetsDataValidationStatusesPartialUpdate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesPartialUpdate>>,
    TError,
    { parentLookupAsset: string; data: PatchedDataValidationStatusesUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusesPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Bulk delete submissions status

```curl
  curl -X DELETE https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/data/validation_statuses/
```

**Payload**
```json
{
  "payload": {
    "submission_ids": [
        1,
        2
      ],
    "validation_status.uid": "validation_status"
  }
}
```
* Where: "submissions_ids" (required) is a list of submission root id on the data
to delete

The validation status of the submission can be updated. The `validation_status.uid` should be a `string`, and it must be one of the following values:
- `validation_status_approved`
- `validation_status_not_approved`
- `validation_status_on_hold`

**Response**
```json
{
           "detail": "{number_of_submissions} submissions have been updated"
}
```

### !! Due to limitations with DRF-Spectacular current version not fully supporting AOS 3.1, DELETE actions do not support showing a request body OR a response body. This is due to the 'vague' nature of the action which generally does *not* recommend the use of a payload. To still document this endpoint, example for the payload and response will be included but it will not be possible to test this endpoint. The HTTP code and the errors example are, for their part, factual and can be considered when working with the endpoint. !!

 */
export type assetsDataValidationStatusesDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDataValidationStatusesDestroyResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsDataValidationStatusesDestroyResponseComposite =
  | assetsDataValidationStatusesDestroyResponse204
  | assetsDataValidationStatusesDestroyResponse404

export type assetsDataValidationStatusesDestroyResponse = assetsDataValidationStatusesDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDataValidationStatusesDestroyUrl = (parentLookupAsset: string) => {
  return `/api/v2/assets/${parentLookupAsset}/data/validation_statuses/`
}

export const assetsDataValidationStatusesDestroy = async (
  parentLookupAsset: string,
  options?: RequestInit,
): Promise<assetsDataValidationStatusesDestroyResponse> => {
  return fetchWithAuth<assetsDataValidationStatusesDestroyResponse>(
    getAssetsDataValidationStatusesDestroyUrl(parentLookupAsset),
    {
      ...options,
      method: 'DELETE',
    },
  )
}

export const getAssetsDataValidationStatusesDestroyMutationOptions = <
  TError = ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
    TError,
    { parentLookupAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
  TError,
  { parentLookupAsset: string },
  TContext
> => {
  const mutationKey = ['assetsDataValidationStatusesDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
    { parentLookupAsset: string }
  > = (props) => {
    const { parentLookupAsset } = props ?? {}

    return assetsDataValidationStatusesDestroy(parentLookupAsset, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDataValidationStatusesDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>
>

export type AssetsDataValidationStatusesDestroyMutationError = ErrorDetail

export const useAssetsDataValidationStatusesDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDataValidationStatusesDestroy>>,
    TError,
    { parentLookupAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDataValidationStatusesDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
