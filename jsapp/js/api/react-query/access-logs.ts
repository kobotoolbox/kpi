/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AccessLogsListParams } from '../models/accessLogsListParams'

import type { AccessLogsMeListParams } from '../models/accessLogsMeListParams'

import type { ErrorDetail } from '../models/errorDetail'

import type { ExportCreateResponse } from '../models/exportCreateResponse'

import type { ExportListResponse } from '../models/exportListResponse'

import type { PaginatedAccessLogResponseList } from '../models/paginatedAccessLogResponseList'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List all access logs for all users

<sup>Note</sup> _Only available to superusers_

Submissions will be grouped together by user by hour

**Filterable fields:**

1. date_created
2. user_uid
3. user__username
4. metadata__source
5. metadata__auth_type
6. metadata__ip_address

**Some examples:**

1. All logs from a specific IP address
    `api/v2/access-logs/?q=metadata__ip_address:"127.0.0.1"`

2. All logs created after Jan 1, 2025
    `api/v2/access-logs/?q=date_created__gte:"2025-01-01"`

*Notes: Do not forget to wrap search terms in double-quotes if they contain spaces
(e.g. date and time "2022-11-15 20:34")*

 */
export type accessLogsListResponse200 = {
  data: PaginatedAccessLogResponseList
  status: 200
}

export type accessLogsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type accessLogsListResponseComposite = accessLogsListResponse200 | accessLogsListResponse403

export type accessLogsListResponse = accessLogsListResponseComposite & {
  headers: Headers
}

export const getAccessLogsListUrl = (params?: AccessLogsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/access-logs/?${stringifiedParams}` : `/api/v2/access-logs/`
}

export const accessLogsList = async (
  params?: AccessLogsListParams,
  options?: RequestInit,
): Promise<accessLogsListResponse> => {
  return fetchWithAuth<accessLogsListResponse>(getAccessLogsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsListQueryKey = (params?: AccessLogsListParams) => {
  return ['api', 'v2', 'access-logs', ...(params ? [params] : [])] as const
}

export const getAccessLogsListQueryOptions = <TData = Awaited<ReturnType<typeof accessLogsList>>, TError = ErrorDetail>(
  params?: AccessLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsList>>> = ({ signal }) =>
    accessLogsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsList>>>
export type AccessLogsListQueryError = ErrorDetail

export function useAccessLogsList<TData = Awaited<ReturnType<typeof accessLogsList>>, TError = ErrorDetail>(
  params?: AccessLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List all access logs export tasks for all users

<sup>Note</sup> _Only available to superusers_

 */
export type accessLogsExportListResponse200 = {
  data: ExportListResponse[]
  status: 200
}

export type accessLogsExportListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type accessLogsExportListResponseComposite = accessLogsExportListResponse200 | accessLogsExportListResponse403

export type accessLogsExportListResponse = accessLogsExportListResponseComposite & {
  headers: Headers
}

export const getAccessLogsExportListUrl = () => {
  return `/api/v2/access-logs/export/`
}

export const accessLogsExportList = async (options?: RequestInit): Promise<accessLogsExportListResponse> => {
  return fetchWithAuth<accessLogsExportListResponse>(getAccessLogsExportListUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsExportListQueryKey = () => {
  return ['api', 'v2', 'access-logs', 'export'] as const
}

export const getAccessLogsExportListQueryOptions = <
  TData = Awaited<ReturnType<typeof accessLogsExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsExportListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsExportList>>> = ({ signal }) =>
    accessLogsExportList({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsExportList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsExportListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsExportList>>>
export type AccessLogsExportListQueryError = ErrorDetail

export function useAccessLogsExportList<
  TData = Awaited<ReturnType<typeof accessLogsExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsExportListQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export task for all users

<sup>Note</sup> _Only available to superusers_

 */
export type accessLogsExportCreateResponse202 = {
  data: ExportCreateResponse
  status: 202
}

export type accessLogsExportCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsExportCreateResponseComposite =
  | accessLogsExportCreateResponse202
  | accessLogsExportCreateResponse401

export type accessLogsExportCreateResponse = accessLogsExportCreateResponseComposite & {
  headers: Headers
}

export const getAccessLogsExportCreateUrl = () => {
  return `/api/v2/access-logs/export/`
}

export const accessLogsExportCreate = async (options?: RequestInit): Promise<accessLogsExportCreateResponse> => {
  return fetchWithAuth<accessLogsExportCreateResponse>(getAccessLogsExportCreateUrl(), {
    ...options,
    method: 'POST',
  })
}

export const getAccessLogsExportCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof accessLogsExportCreate>>, TError, void, TContext> => {
  const mutationKey = ['accessLogsExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof accessLogsExportCreate>>, void> = () => {
    return accessLogsExportCreate(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AccessLogsExportCreateMutationResult = NonNullable<Awaited<ReturnType<typeof accessLogsExportCreate>>>

export type AccessLogsExportCreateMutationError = ErrorDetail

export const useAccessLogsExportCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAccessLogsExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List all access logs for the authenticated user

Submissions will be grouped together by hour

Results from this endpoint can be filtered by a boolean query specified in the `q` parameter.

**Filterable fields:**

1. date_created
2. metadata__source
3. metadata__auth_type
4. metadata__ip_address

**Some examples:**

1. All logs from a specific IP address
    `api/v2/access-logs/?q=metadata__ip_address:"127.0.0.1"`

2. All logs created after Jan, 1 2025
    `api/v2/access-logs/?q=date_created__date__gte:"2025-01-01"`

*Notes: Do not forget to wrap search terms in double-quotes if they contain spaces
(e.g. date and time "2022-11-15 20:34")*

 */
export type accessLogsMeListResponse200 = {
  data: PaginatedAccessLogResponseList
  status: 200
}

export type accessLogsMeListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsMeListResponseComposite = accessLogsMeListResponse200 | accessLogsMeListResponse401

export type accessLogsMeListResponse = accessLogsMeListResponseComposite & {
  headers: Headers
}

export const getAccessLogsMeListUrl = (params?: AccessLogsMeListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/access-logs/me/?${stringifiedParams}` : `/api/v2/access-logs/me/`
}

export const accessLogsMeList = async (
  params?: AccessLogsMeListParams,
  options?: RequestInit,
): Promise<accessLogsMeListResponse> => {
  return fetchWithAuth<accessLogsMeListResponse>(getAccessLogsMeListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsMeListQueryKey = (params?: AccessLogsMeListParams) => {
  return ['api', 'v2', 'access-logs', 'me', ...(params ? [params] : [])] as const
}

export const getAccessLogsMeListQueryOptions = <
  TData = Awaited<ReturnType<typeof accessLogsMeList>>,
  TError = ErrorDetail,
>(
  params?: AccessLogsMeListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsMeListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsMeList>>> = ({ signal }) =>
    accessLogsMeList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsMeList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsMeListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsMeList>>>
export type AccessLogsMeListQueryError = ErrorDetail

export function useAccessLogsMeList<TData = Awaited<ReturnType<typeof accessLogsMeList>>, TError = ErrorDetail>(
  params?: AccessLogsMeListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsMeListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List all access logs export tasks for the authenticated user

 */
export type accessLogsMeExportListResponse200 = {
  data: ExportListResponse[]
  status: 200
}

export type accessLogsMeExportListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsMeExportListResponseComposite =
  | accessLogsMeExportListResponse200
  | accessLogsMeExportListResponse401

export type accessLogsMeExportListResponse = accessLogsMeExportListResponseComposite & {
  headers: Headers
}

export const getAccessLogsMeExportListUrl = () => {
  return `/api/v2/access-logs/me/export/`
}

export const accessLogsMeExportList = async (options?: RequestInit): Promise<accessLogsMeExportListResponse> => {
  return fetchWithAuth<accessLogsMeExportListResponse>(getAccessLogsMeExportListUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsMeExportListQueryKey = () => {
  return ['api', 'v2', 'access-logs', 'me', 'export'] as const
}

export const getAccessLogsMeExportListQueryOptions = <
  TData = Awaited<ReturnType<typeof accessLogsMeExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsMeExportListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsMeExportList>>> = ({ signal }) =>
    accessLogsMeExportList({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsMeExportList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsMeExportListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsMeExportList>>>
export type AccessLogsMeExportListQueryError = ErrorDetail

export function useAccessLogsMeExportList<
  TData = Awaited<ReturnType<typeof accessLogsMeExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsMeExportListQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export task for the authenticated user

 */
export type accessLogsMeExportCreateResponse202 = {
  data: ExportCreateResponse
  status: 202
}

export type accessLogsMeExportCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsMeExportCreateResponseComposite =
  | accessLogsMeExportCreateResponse202
  | accessLogsMeExportCreateResponse401

export type accessLogsMeExportCreateResponse = accessLogsMeExportCreateResponseComposite & {
  headers: Headers
}

export const getAccessLogsMeExportCreateUrl = () => {
  return `/api/v2/access-logs/me/export/`
}

export const accessLogsMeExportCreate = async (options?: RequestInit): Promise<accessLogsMeExportCreateResponse> => {
  return fetchWithAuth<accessLogsMeExportCreateResponse>(getAccessLogsMeExportCreateUrl(), {
    ...options,
    method: 'POST',
  })
}

export const getAccessLogsMeExportCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, TError, void, TContext> => {
  const mutationKey = ['accessLogsMeExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, void> = () => {
    return accessLogsMeExportCreate(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AccessLogsMeExportCreateMutationResult = NonNullable<Awaited<ReturnType<typeof accessLogsMeExportCreate>>>

export type AccessLogsMeExportCreateMutationError = ErrorDetail

export const useAccessLogsMeExportCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAccessLogsMeExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
