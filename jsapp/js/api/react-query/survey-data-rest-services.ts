/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * This page documents all KoboToolbox API endpoints.

The endpoints are grouped by area of intended use. Each category contains related endpoints, with detailed documentation on usage and configuration. Use this as a reference to quickly find the right endpoint for managing projects, forms, data, permissions, integrations, logs, and organizational resources.

**General note**: All projects (whether deployed or draft), as well as all library content (questions, blocks, templates, and collections) in the user-facing application are represented in the API as assets.
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AssetsHooksListParams } from '../models/assetsHooksListParams'

import type { AssetsHooksLogsListParams } from '../models/assetsHooksLogsListParams'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { Hook } from '../models/hook'

import type { HookLog } from '../models/hookLog'

import type { HookRetryResponse } from '../models/hookRetryResponse'

import type { LogsRetryResponse } from '../models/logsRetryResponse'

import type { PaginatedHookList } from '../models/paginatedHookList'

import type { PaginatedHookLogList } from '../models/paginatedHookLogList'

import type { PatchedHook } from '../models/patchedHook'

import type { PatchedHookLog } from '../models/patchedHookLog'

import { fetchWithAuth } from '../orval.mutator'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
    }
  : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List external services

Lists the external services endpoints accessible to requesting user

 */
export type assetsHooksListResponse200 = {
  data: PaginatedHookList
  status: 200
}

export type assetsHooksListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsHooksListResponseComposite = assetsHooksListResponse200 | assetsHooksListResponse404

export type assetsHooksListResponse = assetsHooksListResponseComposite & {
  headers: Headers
}

export const getAssetsHooksListUrl = (uidAsset: string, params?: AssetsHooksListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/hooks/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/hooks/`
}

export const assetsHooksList = async (
  uidAsset: string,
  params?: AssetsHooksListParams,
  options?: RequestInit,
): Promise<assetsHooksListResponse> => {
  return fetchWithAuth<assetsHooksListResponse>(getAssetsHooksListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHooksListQueryKey = (uidAsset: string, params?: AssetsHooksListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'hooks', ...(params ? [params] : [])] as const
}

export const getAssetsHooksListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  params?: AssetsHooksListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHooksListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksList>>> = ({ signal }) =>
    assetsHooksList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHooksList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHooksListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksList>>>
export type AssetsHooksListQueryError = ErrorObject

export function useAssetsHooksList<TData = Awaited<ReturnType<typeof assetsHooksList>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsHooksListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Add an external service to asset.

Where:

* `name` and `endpoint` are required
* `active` is True by default
* `export_type` must be one of these values:

    1. `json` (_default_)
    2. `xml`

* `email_notification` is a boolean. If true, User will be notified when request to remote server has failed.
* `auth_level` must be one of these values:

    1. `no_auth` (_default_)
    2. `basic_auth`

* `subset_fields` is the list of fields of the form definition. Only these fields should be present in data sent to remote server
* `settings`.`custom_headers` is dictionary of `custom header`: `value`

For example:
>         "settings": {
>             "customer_headers": {
>                 "Authorization" : "Token 1af538baa9045a84c0e889f672baf83ff24"
>             }

* `payload_template` is a custom wrapper around `%SUBMISSION%` when sending data to remote server.
   It can be used only with JSON submission format.

For example:
>         "payload_template": '{"fields": %SUBMISSION%}'

 */
export type assetsHooksCreateResponse201 = {
  data: Hook
  status: 201
}

export type assetsHooksCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsHooksCreateResponseComposite = assetsHooksCreateResponse201 | assetsHooksCreateResponse400

export type assetsHooksCreateResponse = assetsHooksCreateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksCreateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/hooks/`
}

export const assetsHooksCreate = async (
  uidAsset: string,
  hook: NonReadonly<Hook>,
  options?: RequestInit,
): Promise<assetsHooksCreateResponse> => {
  return fetchWithAuth<assetsHooksCreateResponse>(getAssetsHooksCreateUrl(uidAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(hook),
  })
}

export const getAssetsHooksCreateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksCreate>>,
    TError,
    { uidAsset: string; data: NonReadonly<Hook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksCreate>>,
  TError,
  { uidAsset: string; data: NonReadonly<Hook> },
  TContext
> => {
  const mutationKey = ['assetsHooksCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksCreate>>,
    { uidAsset: string; data: NonReadonly<Hook> }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsHooksCreate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsHooksCreate>>>
export type AssetsHooksCreateMutationBody = NonReadonly<Hook>
export type AssetsHooksCreateMutationError = ErrorObject

export const useAssetsHooksCreate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksCreate>>,
    TError,
    { uidAsset: string; data: NonReadonly<Hook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve an external service

 */
export type assetsHooksRetrieveResponse200 = {
  data: Hook
  status: 200
}

export type assetsHooksRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsHooksRetrieveResponseComposite = assetsHooksRetrieveResponse200 | assetsHooksRetrieveResponse404

export type assetsHooksRetrieveResponse = assetsHooksRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsHooksRetrieveUrl = (uidAsset: string, uidHook: string) => {
  return `/api/v2/assets/${uidAsset}/hooks/${uidHook}/`
}

export const assetsHooksRetrieve = async (
  uidAsset: string,
  uidHook: string,
  options?: RequestInit,
): Promise<assetsHooksRetrieveResponse> => {
  return fetchWithAuth<assetsHooksRetrieveResponse>(getAssetsHooksRetrieveUrl(uidAsset, uidHook), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHooksRetrieveQueryKey = (uidAsset: string, uidHook: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'hooks', uidHook] as const
}

export const getAssetsHooksRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidHook: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHooksRetrieveQueryKey(uidAsset, uidHook)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksRetrieve>>> = ({ signal }) =>
    assetsHooksRetrieve(uidAsset, uidHook, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidHook), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHooksRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHooksRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksRetrieve>>>
export type AssetsHooksRetrieveQueryError = ErrorObject

export function useAssetsHooksRetrieve<TData = Awaited<ReturnType<typeof assetsHooksRetrieve>>, TError = ErrorObject>(
  uidAsset: string,
  uidHook: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksRetrieveQueryOptions(uidAsset, uidHook, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update an external service.

 */
export type assetsHooksPartialUpdateResponse200 = {
  data: Hook
  status: 200
}

export type assetsHooksPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsHooksPartialUpdateResponseComposite =
  | assetsHooksPartialUpdateResponse200
  | assetsHooksPartialUpdateResponse400

export type assetsHooksPartialUpdateResponse = assetsHooksPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksPartialUpdateUrl = (uidAsset: string, uidHook: string) => {
  return `/api/v2/assets/${uidAsset}/hooks/${uidHook}/`
}

export const assetsHooksPartialUpdate = async (
  uidAsset: string,
  uidHook: string,
  patchedHook: NonReadonly<PatchedHook>,
  options?: RequestInit,
): Promise<assetsHooksPartialUpdateResponse> => {
  return fetchWithAuth<assetsHooksPartialUpdateResponse>(getAssetsHooksPartialUpdateUrl(uidAsset, uidHook), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedHook),
  })
}

export const getAssetsHooksPartialUpdateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
    TError,
    { uidAsset: string; uidHook: string; data: NonReadonly<PatchedHook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
  TError,
  { uidAsset: string; uidHook: string; data: NonReadonly<PatchedHook> },
  TContext
> => {
  const mutationKey = ['assetsHooksPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
    { uidAsset: string; uidHook: string; data: NonReadonly<PatchedHook> }
  > = (props) => {
    const { uidAsset, uidHook, data } = props ?? {}

    return assetsHooksPartialUpdate(uidAsset, uidHook, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsHooksPartialUpdate>>>
export type AssetsHooksPartialUpdateMutationBody = NonReadonly<PatchedHook>
export type AssetsHooksPartialUpdateMutationError = ErrorObject

export const useAssetsHooksPartialUpdate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
    TError,
    { uidAsset: string; uidHook: string; data: NonReadonly<PatchedHook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete an external service.

 */
export type assetsHooksDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsHooksDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsHooksDestroyResponseComposite = assetsHooksDestroyResponse204 | assetsHooksDestroyResponse404

export type assetsHooksDestroyResponse = assetsHooksDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsHooksDestroyUrl = (uidAsset: string, uidHook: string) => {
  return `/api/v2/assets/${uidAsset}/hooks/${uidHook}/`
}

export const assetsHooksDestroy = async (
  uidAsset: string,
  uidHook: string,
  options?: RequestInit,
): Promise<assetsHooksDestroyResponse> => {
  return fetchWithAuth<assetsHooksDestroyResponse>(getAssetsHooksDestroyUrl(uidAsset, uidHook), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsHooksDestroyMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksDestroy>>,
    TError,
    { uidAsset: string; uidHook: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksDestroy>>,
  TError,
  { uidAsset: string; uidHook: string },
  TContext
> => {
  const mutationKey = ['assetsHooksDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksDestroy>>,
    { uidAsset: string; uidHook: string }
  > = (props) => {
    const { uidAsset, uidHook } = props ?? {}

    return assetsHooksDestroy(uidAsset, uidHook, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsHooksDestroy>>>

export type AssetsHooksDestroyMutationError = ErrorObject

export const useAssetsHooksDestroy = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksDestroy>>,
    TError,
    { uidAsset: string; uidHook: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List logs of an external services endpoints accessible to requesting user

Where:
* `asset_uid` - is the unique identifier of a specific asset
* `hook_uid` - is the unique identifier of a specific external service
* `uid` - is the unique identifier of a specific log

Use the `status` query parameter to filter logs by numeric status:
* `status=0`: hook has failed after exhausting all retries
* `status=1`: hook is still pending
* `status=2`: hook has succeeded

Use the `start` and `end` query parameters to filter logs by date range, providing ISO-8601 date strings (e.g. '2022-01-14', '2022-01-21 06:51:04', '2022-01-21T06:51:08.144004+02:00').
Note that `start` is inclusive, while `end` is exclusive.
Time zone is assumed to be UTC. If provided, it needs to be in '+00:00' format ('Z' is not supported). Watch out for url encoding for the '+' character (%2B).

 */
export type assetsHooksLogsListResponse200 = {
  data: PaginatedHookLogList
  status: 200
}

export type assetsHooksLogsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHooksLogsListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsHooksLogsListResponseComposite =
  | assetsHooksLogsListResponse200
  | assetsHooksLogsListResponse403
  | assetsHooksLogsListResponse404

export type assetsHooksLogsListResponse = assetsHooksLogsListResponseComposite & {
  headers: Headers
}

export const getAssetsHooksLogsListUrl = (uidAsset: string, uidHook: string, params?: AssetsHooksLogsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/hooks/${uidHook}/logs/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/hooks/${uidHook}/logs/`
}

export const assetsHooksLogsList = async (
  uidAsset: string,
  uidHook: string,
  params?: AssetsHooksLogsListParams,
  options?: RequestInit,
): Promise<assetsHooksLogsListResponse> => {
  return fetchWithAuth<assetsHooksLogsListResponse>(getAssetsHooksLogsListUrl(uidAsset, uidHook, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHooksLogsListQueryKey = (
  uidAsset: string,
  uidHook: string,
  params?: AssetsHooksLogsListParams,
) => {
  return ['api', 'v2', 'assets', uidAsset, 'hooks', uidHook, 'logs', ...(params ? [params] : [])] as const
}

export const getAssetsHooksLogsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksLogsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  uidHook: string,
  params?: AssetsHooksLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHooksLogsListQueryKey(uidAsset, uidHook, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksLogsList>>> = ({ signal }) =>
    assetsHooksLogsList(uidAsset, uidHook, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidHook), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHooksLogsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHooksLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksLogsList>>>
export type AssetsHooksLogsListQueryError = ErrorDetail | ErrorObject

export function useAssetsHooksLogsList<
  TData = Awaited<ReturnType<typeof assetsHooksLogsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  uidHook: string,
  params?: AssetsHooksLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksLogsListQueryOptions(uidAsset, uidHook, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve an external service endpoint log

 */
export type assetsHooksLogsRetrieveResponse200 = {
  data: HookLog
  status: 200
}

export type assetsHooksLogsRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHooksLogsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsHooksLogsRetrieveResponseComposite =
  | assetsHooksLogsRetrieveResponse200
  | assetsHooksLogsRetrieveResponse403
  | assetsHooksLogsRetrieveResponse404

export type assetsHooksLogsRetrieveResponse = assetsHooksLogsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsHooksLogsRetrieveUrl = (uidAsset: string, uidHook: string, uidLog: string) => {
  return `/api/v2/assets/${uidAsset}/hooks/${uidHook}/logs/${uidLog}/`
}

export const assetsHooksLogsRetrieve = async (
  uidAsset: string,
  uidHook: string,
  uidLog: string,
  options?: RequestInit,
): Promise<assetsHooksLogsRetrieveResponse> => {
  return fetchWithAuth<assetsHooksLogsRetrieveResponse>(getAssetsHooksLogsRetrieveUrl(uidAsset, uidHook, uidLog), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHooksLogsRetrieveQueryKey = (uidAsset: string, uidHook: string, uidLog: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'hooks', uidHook, 'logs', uidLog] as const
}

export const getAssetsHooksLogsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  uidHook: string,
  uidLog: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHooksLogsRetrieveQueryKey(uidAsset, uidHook, uidLog)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>> = ({ signal }) =>
    assetsHooksLogsRetrieve(uidAsset, uidHook, uidLog, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidHook && uidLog), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHooksLogsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>>
export type AssetsHooksLogsRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsHooksLogsRetrieve<
  TData = Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  uidHook: string,
  uidLog: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksLogsRetrieveQueryOptions(uidAsset, uidHook, uidLog, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retry a failed submission attempt

 */
export type assetsHooksLogsRetryPartialUpdateResponse200 = {
  data: LogsRetryResponse
  status: 200
}

export type assetsHooksLogsRetryPartialUpdateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHooksLogsRetryPartialUpdateResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsHooksLogsRetryPartialUpdateResponseComposite =
  | assetsHooksLogsRetryPartialUpdateResponse200
  | assetsHooksLogsRetryPartialUpdateResponse403
  | assetsHooksLogsRetryPartialUpdateResponse404

export type assetsHooksLogsRetryPartialUpdateResponse = assetsHooksLogsRetryPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksLogsRetryPartialUpdateUrl = (uidAsset: string, uidHook: string, uidLog: string) => {
  return `/api/v2/assets/${uidAsset}/hooks/${uidHook}/logs/${uidLog}/retry/`
}

export const assetsHooksLogsRetryPartialUpdate = async (
  uidAsset: string,
  uidHook: string,
  uidLog: string,
  patchedHookLog: NonReadonly<PatchedHookLog>,
  options?: RequestInit,
): Promise<assetsHooksLogsRetryPartialUpdateResponse> => {
  return fetchWithAuth<assetsHooksLogsRetryPartialUpdateResponse>(
    getAssetsHooksLogsRetryPartialUpdateUrl(uidAsset, uidHook, uidLog),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedHookLog),
    },
  )
}

export const getAssetsHooksLogsRetryPartialUpdateMutationOptions = <
  TError = ErrorDetail | ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
    TError,
    { uidAsset: string; uidHook: string; uidLog: string; data: NonReadonly<PatchedHookLog> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
  TError,
  { uidAsset: string; uidHook: string; uidLog: string; data: NonReadonly<PatchedHookLog> },
  TContext
> => {
  const mutationKey = ['assetsHooksLogsRetryPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
    { uidAsset: string; uidHook: string; uidLog: string; data: NonReadonly<PatchedHookLog> }
  > = (props) => {
    const { uidAsset, uidHook, uidLog, data } = props ?? {}

    return assetsHooksLogsRetryPartialUpdate(uidAsset, uidHook, uidLog, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksLogsRetryPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>
>
export type AssetsHooksLogsRetryPartialUpdateMutationBody = NonReadonly<PatchedHookLog>
export type AssetsHooksLogsRetryPartialUpdateMutationError = ErrorDetail | ErrorObject

export const useAssetsHooksLogsRetryPartialUpdate = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
    TError,
    { uidAsset: string; uidHook: string; uidLog: string; data: NonReadonly<PatchedHookLog> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksLogsRetryPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retries all failed attempts

**This call is asynchronous. Job is sent to Celery to be run in background**

It returns all logs `uid`s that are being retried.

 */
export type assetsHooksRetryPartialUpdateResponse200 = {
  data: HookRetryResponse
  status: 200
}

export type assetsHooksRetryPartialUpdateResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsHooksRetryPartialUpdateResponseComposite =
  | assetsHooksRetryPartialUpdateResponse200
  | assetsHooksRetryPartialUpdateResponse404

export type assetsHooksRetryPartialUpdateResponse = assetsHooksRetryPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksRetryPartialUpdateUrl = (uidAsset: string, uidHook: string) => {
  return `/api/v2/assets/${uidAsset}/hooks/${uidHook}/retry/`
}

export const assetsHooksRetryPartialUpdate = async (
  uidAsset: string,
  uidHook: string,
  options?: RequestInit,
): Promise<assetsHooksRetryPartialUpdateResponse> => {
  return fetchWithAuth<assetsHooksRetryPartialUpdateResponse>(getAssetsHooksRetryPartialUpdateUrl(uidAsset, uidHook), {
    ...options,
    method: 'PATCH',
  })
}

export const getAssetsHooksRetryPartialUpdateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
    TError,
    { uidAsset: string; uidHook: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
  TError,
  { uidAsset: string; uidHook: string },
  TContext
> => {
  const mutationKey = ['assetsHooksRetryPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
    { uidAsset: string; uidHook: string }
  > = (props) => {
    const { uidAsset, uidHook } = props ?? {}

    return assetsHooksRetryPartialUpdate(uidAsset, uidHook, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksRetryPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>
>

export type AssetsHooksRetryPartialUpdateMutationError = ErrorObject

export const useAssetsHooksRetryPartialUpdate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
    TError,
    { uidAsset: string; uidHook: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksRetryPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
