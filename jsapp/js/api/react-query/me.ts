/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { EmailAddress } from '../models/emailAddress'

import type { EmailRequestPayload } from '../models/emailRequestPayload'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { MeEmailsListParams } from '../models/meEmailsListParams'

import type { MeListResponse } from '../models/meListResponse'

import type { MeSocialAccountsListParams } from '../models/meSocialAccountsListParams'

import type { PaginatedEmailAddressList } from '../models/paginatedEmailAddressList'

import type { PaginatedSocialAccountList } from '../models/paginatedSocialAccountList'

import type { PatchedCurrentUser } from '../models/patchedCurrentUser'

import type { SocialAccount } from '../models/socialAccount'

import { fetchWithAuth } from '../orval.mutator'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
    }
  : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## Retrieve current user profile

 */
export type meRetrieveResponse200 = {
  data: MeListResponse
  status: 200
}

export type meRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meRetrieveResponseComposite = meRetrieveResponse200 | meRetrieveResponse401

export type meRetrieveResponse = meRetrieveResponseComposite & {
  headers: Headers
}

export const getMeRetrieveUrl = () => {
  return `/me/`
}

export const meRetrieve = async (options?: RequestInit): Promise<meRetrieveResponse> => {
  return fetchWithAuth<meRetrieveResponse>(getMeRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getMeRetrieveQueryKey = () => {
  return ['me'] as const
}

export const getMeRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof meRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof meRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meRetrieve>>> = ({ signal }) =>
    meRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof meRetrieve>>>
export type MeRetrieveQueryError = ErrorDetail

export function useMeRetrieve<TData = Awaited<ReturnType<typeof meRetrieve>>, TError = ErrorDetail>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof meRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update current user infos

 */
export type mePartialUpdateResponse200 = {
  data: MeListResponse
  status: 200
}

export type mePartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type mePartialUpdateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type mePartialUpdateResponseComposite =
  | mePartialUpdateResponse200
  | mePartialUpdateResponse400
  | mePartialUpdateResponse401

export type mePartialUpdateResponse = mePartialUpdateResponseComposite & {
  headers: Headers
}

export const getMePartialUpdateUrl = () => {
  return `/me/`
}

export const mePartialUpdate = async (
  patchedCurrentUser: NonReadonly<PatchedCurrentUser>,
  options?: RequestInit,
): Promise<mePartialUpdateResponse> => {
  return fetchWithAuth<mePartialUpdateResponse>(getMePartialUpdateUrl(), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedCurrentUser),
  })
}

export const getMePartialUpdateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mePartialUpdate>>,
    TError,
    { data: NonReadonly<PatchedCurrentUser> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof mePartialUpdate>>,
  TError,
  { data: NonReadonly<PatchedCurrentUser> },
  TContext
> => {
  const mutationKey = ['mePartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mePartialUpdate>>,
    { data: NonReadonly<PatchedCurrentUser> }
  > = (props) => {
    const { data } = props ?? {}

    return mePartialUpdate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof mePartialUpdate>>>
export type MePartialUpdateMutationBody = NonReadonly<PatchedCurrentUser>
export type MePartialUpdateMutationError = ErrorObject | ErrorDetail

export const useMePartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mePartialUpdate>>,
    TError,
    { data: NonReadonly<PatchedCurrentUser> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMePartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete current user

> Payload Example:
>
>       {
>           "confirm": "user__extra_details__uid",
>       }


### !! Due to current DRF-Spectacular limitations with AOS 3.1, DELETE operations do not display request or response bodies in this documentation (as payloads are not typically recommended for DELETE). This means direct testing is unavailable. However, example payloads and responses are provided for reference, and HTTP codes/error messages are accurate.  !!

 */
export type meDestroyResponse204 = {
  data: void
  status: 204
}

export type meDestroyResponse400 = {
  data: ErrorObject
  status: 400
}

export type meDestroyResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meDestroyResponseComposite = meDestroyResponse204 | meDestroyResponse400 | meDestroyResponse401

export type meDestroyResponse = meDestroyResponseComposite & {
  headers: Headers
}

export const getMeDestroyUrl = () => {
  return `/me/`
}

export const meDestroy = async (options?: RequestInit): Promise<meDestroyResponse> => {
  return fetchWithAuth<meDestroyResponse>(getMeDestroyUrl(), {
    ...options,
    method: 'DELETE',
  })
}

export const getMeDestroyMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof meDestroy>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof meDestroy>>, TError, void, TContext> => {
  const mutationKey = ['meDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof meDestroy>>, void> = () => {
    return meDestroy(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MeDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof meDestroy>>>

export type MeDestroyMutationError = ErrorObject | ErrorDetail

export const useMeDestroy = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof meDestroy>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMeDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## View current user's email

 */
export type meEmailsListResponse200 = {
  data: PaginatedEmailAddressList
  status: 200
}

export type meEmailsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meEmailsListResponseComposite = meEmailsListResponse200 | meEmailsListResponse401

export type meEmailsListResponse = meEmailsListResponseComposite & {
  headers: Headers
}

export const getMeEmailsListUrl = (params?: MeEmailsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/me/emails/?${stringifiedParams}` : `/me/emails/`
}

export const meEmailsList = async (
  params?: MeEmailsListParams,
  options?: RequestInit,
): Promise<meEmailsListResponse> => {
  return fetchWithAuth<meEmailsListResponse>(getMeEmailsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getMeEmailsListQueryKey = (params?: MeEmailsListParams) => {
  return ['me', 'emails', ...(params ? [params] : [])] as const
}

export const getMeEmailsListQueryOptions = <TData = Awaited<ReturnType<typeof meEmailsList>>, TError = ErrorDetail>(
  params?: MeEmailsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meEmailsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeEmailsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meEmailsList>>> = ({ signal }) =>
    meEmailsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meEmailsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeEmailsListQueryResult = NonNullable<Awaited<ReturnType<typeof meEmailsList>>>
export type MeEmailsListQueryError = ErrorDetail

export function useMeEmailsList<TData = Awaited<ReturnType<typeof meEmailsList>>, TError = ErrorDetail>(
  params?: MeEmailsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meEmailsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeEmailsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Set a new email

The new email will be unverified and replace existing unverified, non-primary emails.
New email is not usable until verified.

 */
export type meEmailsCreateResponse201 = {
  data: EmailAddress
  status: 201
}

export type meEmailsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type meEmailsCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meEmailsCreateResponseComposite =
  | meEmailsCreateResponse201
  | meEmailsCreateResponse400
  | meEmailsCreateResponse401

export type meEmailsCreateResponse = meEmailsCreateResponseComposite & {
  headers: Headers
}

export const getMeEmailsCreateUrl = () => {
  return `/me/emails/`
}

export const meEmailsCreate = async (
  emailRequestPayload: EmailRequestPayload,
  options?: RequestInit,
): Promise<meEmailsCreateResponse> => {
  return fetchWithAuth<meEmailsCreateResponse>(getMeEmailsCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(emailRequestPayload),
  })
}

export const getMeEmailsCreateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meEmailsCreate>>,
    TError,
    { data: EmailRequestPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof meEmailsCreate>>, TError, { data: EmailRequestPayload }, TContext> => {
  const mutationKey = ['meEmailsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof meEmailsCreate>>, { data: EmailRequestPayload }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return meEmailsCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MeEmailsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meEmailsCreate>>>
export type MeEmailsCreateMutationBody = EmailRequestPayload
export type MeEmailsCreateMutationError = ErrorObject | ErrorDetail

export const useMeEmailsCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meEmailsCreate>>,
    TError,
    { data: EmailRequestPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMeEmailsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List user's social accounts

 */
export type meSocialAccountsListResponse200 = {
  data: PaginatedSocialAccountList
  status: 200
}

export type meSocialAccountsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meSocialAccountsListResponseComposite = meSocialAccountsListResponse200 | meSocialAccountsListResponse401

export type meSocialAccountsListResponse = meSocialAccountsListResponseComposite & {
  headers: Headers
}

export const getMeSocialAccountsListUrl = (params?: MeSocialAccountsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/me/social-accounts/?${stringifiedParams}` : `/me/social-accounts/`
}

export const meSocialAccountsList = async (
  params?: MeSocialAccountsListParams,
  options?: RequestInit,
): Promise<meSocialAccountsListResponse> => {
  return fetchWithAuth<meSocialAccountsListResponse>(getMeSocialAccountsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getMeSocialAccountsListQueryKey = (params?: MeSocialAccountsListParams) => {
  return ['me', 'social-accounts', ...(params ? [params] : [])] as const
}

export const getMeSocialAccountsListQueryOptions = <
  TData = Awaited<ReturnType<typeof meSocialAccountsList>>,
  TError = ErrorDetail,
>(
  params?: MeSocialAccountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeSocialAccountsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meSocialAccountsList>>> = ({ signal }) =>
    meSocialAccountsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meSocialAccountsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeSocialAccountsListQueryResult = NonNullable<Awaited<ReturnType<typeof meSocialAccountsList>>>
export type MeSocialAccountsListQueryError = ErrorDetail

export function useMeSocialAccountsList<TData = Awaited<ReturnType<typeof meSocialAccountsList>>, TError = ErrorDetail>(
  params?: MeSocialAccountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeSocialAccountsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a social account provider

 */
export type meSocialAccountsRetrieveResponse200 = {
  data: SocialAccount
  status: 200
}

export type meSocialAccountsRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meSocialAccountsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type meSocialAccountsRetrieveResponseComposite =
  | meSocialAccountsRetrieveResponse200
  | meSocialAccountsRetrieveResponse401
  | meSocialAccountsRetrieveResponse404

export type meSocialAccountsRetrieveResponse = meSocialAccountsRetrieveResponseComposite & {
  headers: Headers
}

export const getMeSocialAccountsRetrieveUrl = (provider: string, uid: string) => {
  return `/me/social-accounts/${provider}/${uid}/`
}

export const meSocialAccountsRetrieve = async (
  provider: string,
  uid: string,
  options?: RequestInit,
): Promise<meSocialAccountsRetrieveResponse> => {
  return fetchWithAuth<meSocialAccountsRetrieveResponse>(getMeSocialAccountsRetrieveUrl(provider, uid), {
    ...options,
    method: 'GET',
  })
}

export const getMeSocialAccountsRetrieveQueryKey = (provider: string, uid: string) => {
  return ['me', 'social-accounts', provider, uid] as const
}

export const getMeSocialAccountsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof meSocialAccountsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  provider: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeSocialAccountsRetrieveQueryKey(provider, uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>> = ({ signal }) =>
    meSocialAccountsRetrieve(provider, uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(provider && uid), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meSocialAccountsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeSocialAccountsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>>
export type MeSocialAccountsRetrieveQueryError = ErrorDetail | ErrorObject

export function useMeSocialAccountsRetrieve<
  TData = Awaited<ReturnType<typeof meSocialAccountsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  provider: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeSocialAccountsRetrieveQueryOptions(provider, uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Delete a social account provider

 */
export type meSocialAccountsDestroyResponse204 = {
  data: void
  status: 204
}

export type meSocialAccountsDestroyResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meSocialAccountsDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type meSocialAccountsDestroyResponseComposite =
  | meSocialAccountsDestroyResponse204
  | meSocialAccountsDestroyResponse401
  | meSocialAccountsDestroyResponse404

export type meSocialAccountsDestroyResponse = meSocialAccountsDestroyResponseComposite & {
  headers: Headers
}

export const getMeSocialAccountsDestroyUrl = (provider: string, uid: string) => {
  return `/me/social-accounts/${provider}/${uid}/`
}

export const meSocialAccountsDestroy = async (
  provider: string,
  uid: string,
  options?: RequestInit,
): Promise<meSocialAccountsDestroyResponse> => {
  return fetchWithAuth<meSocialAccountsDestroyResponse>(getMeSocialAccountsDestroyUrl(provider, uid), {
    ...options,
    method: 'DELETE',
  })
}

export const getMeSocialAccountsDestroyMutationOptions = <
  TError = ErrorDetail | ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
    TError,
    { provider: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
  TError,
  { provider: string; uid: string },
  TContext
> => {
  const mutationKey = ['meSocialAccountsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
    { provider: string; uid: string }
  > = (props) => {
    const { provider, uid } = props ?? {}

    return meSocialAccountsDestroy(provider, uid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MeSocialAccountsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof meSocialAccountsDestroy>>>

export type MeSocialAccountsDestroyMutationError = ErrorDetail | ErrorObject

export const useMeSocialAccountsDestroy = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
    TError,
    { provider: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMeSocialAccountsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
