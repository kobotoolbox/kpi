/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AssetsHooksListParams } from '../models/assetsHooksListParams'

import type { AssetsHooksLogsListParams } from '../models/assetsHooksLogsListParams'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { Hook } from '../models/hook'

import type { HookLog } from '../models/hookLog'

import type { HookRetryResponse } from '../models/hookRetryResponse'

import type { LogsRetryResponse } from '../models/logsRetryResponse'

import type { PaginatedHookList } from '../models/paginatedHookList'

import type { PaginatedHookLogList } from '../models/paginatedHookLogList'

import type { PatchedHook } from '../models/patchedHook'

import type { PatchedHookLog } from '../models/patchedHookLog'

import { fetchWithAuth } from '../orval.mutator'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
    }
  : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List external services

Lists the external services endpoints accessible to requesting user

 */
export type assetsHooksListResponse200 = {
  data: PaginatedHookList
  status: 200
}

export type assetsHooksListResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsHooksListResponseComposite = assetsHooksListResponse200 | assetsHooksListResponse404

export type assetsHooksListResponse = assetsHooksListResponseComposite & {
  headers: Headers
}

export const getAssetsHooksListUrl = (parentLookupAsset: string, params?: AssetsHooksListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${parentLookupAsset}/hooks/?${stringifiedParams}`
    : `/api/v2/assets/${parentLookupAsset}/hooks/`
}

export const assetsHooksList = async (
  parentLookupAsset: string,
  params?: AssetsHooksListParams,
  options?: RequestInit,
): Promise<assetsHooksListResponse> => {
  return fetchWithAuth<assetsHooksListResponse>(getAssetsHooksListUrl(parentLookupAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHooksListQueryKey = (parentLookupAsset: string, params?: AssetsHooksListParams) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'hooks', ...(params ? [params] : [])] as const
}

export const getAssetsHooksListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksList>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  params?: AssetsHooksListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHooksListQueryKey(parentLookupAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksList>>> = ({ signal }) =>
    assetsHooksList(parentLookupAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!parentLookupAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHooksList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHooksListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksList>>>
export type AssetsHooksListQueryError = ErrorDetail

export function useAssetsHooksList<TData = Awaited<ReturnType<typeof assetsHooksList>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  params?: AssetsHooksListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksListQueryOptions(parentLookupAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Add an external service to asset.

Where:

* `name` and `endpoint` are required
* `active` is True by default
* `export_type` must be one of these values:

    1. `json` (_default_)
    2. `xml`

* `email_notification` is a boolean. If true, User will be notified when request to remote server has failed.
* `auth_level` must be one of these values:

    1. `no_auth` (_default_)
    2. `basic_auth`

* `subset_fields` is the list of fields of the form definition. Only these fields should be present in data sent to remote server
* `settings`.`custom_headers` is dictionary of `custom header`: `value`

For example:
>         "settings": {
>             "customer_headers": {
>                 "Authorization" : "Token 1af538baa9045a84c0e889f672baf83ff24"
>             }

* `payload_template` is a custom wrapper around `%SUBMISSION%` when sending data to remote server.
   It can be used only with JSON submission format.

For example:
>         "payload_template": '{"fields": %SUBMISSION%}'

 */
export type assetsHooksCreateResponse201 = {
  data: Hook
  status: 201
}

export type assetsHooksCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsHooksCreateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsHooksCreateResponseComposite =
  | assetsHooksCreateResponse201
  | assetsHooksCreateResponse400
  | assetsHooksCreateResponse404

export type assetsHooksCreateResponse = assetsHooksCreateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksCreateUrl = (parentLookupAsset: string) => {
  return `/api/v2/assets/${parentLookupAsset}/hooks/`
}

export const assetsHooksCreate = async (
  parentLookupAsset: string,
  hook: NonReadonly<Hook>,
  options?: RequestInit,
): Promise<assetsHooksCreateResponse> => {
  return fetchWithAuth<assetsHooksCreateResponse>(getAssetsHooksCreateUrl(parentLookupAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(hook),
  })
}

export const getAssetsHooksCreateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksCreate>>,
    TError,
    { parentLookupAsset: string; data: NonReadonly<Hook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksCreate>>,
  TError,
  { parentLookupAsset: string; data: NonReadonly<Hook> },
  TContext
> => {
  const mutationKey = ['assetsHooksCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksCreate>>,
    { parentLookupAsset: string; data: NonReadonly<Hook> }
  > = (props) => {
    const { parentLookupAsset, data } = props ?? {}

    return assetsHooksCreate(parentLookupAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsHooksCreate>>>
export type AssetsHooksCreateMutationBody = NonReadonly<Hook>
export type AssetsHooksCreateMutationError = ErrorObject | ErrorDetail

export const useAssetsHooksCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksCreate>>,
    TError,
    { parentLookupAsset: string; data: NonReadonly<Hook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List logs of an external services endpoints accessible to requesting user

Where:
* `asset_uid` - is the unique identifier of a specific asset
* `hook_uid` - is the unique identifier of a specific external service
* `uid` - is the unique identifier of a specific log

Use the `status` query parameter to filter logs by numeric status:
* `status=0`: hook has failed after exhausting all retries
* `status=1`: hook is still pending
* `status=2`: hook has succeeded

Use the `start` and `end` query parameters to filter logs by date range, providing ISO-8601 date strings (e.g. '2022-01-14', '2022-01-21 06:51:04', '2022-01-21T06:51:08.144004+02:00').
Note that `start` is inclusive, while `end` is exclusive.
Time zone is assumed to be UTC. If provided, it needs to be in '+00:00' format ('Z' is not supported). Watch out for url encoding for the '+' character (%2B).

 */
export type assetsHooksLogsListResponse200 = {
  data: PaginatedHookLogList
  status: 200
}

export type assetsHooksLogsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHooksLogsListResponseComposite = assetsHooksLogsListResponse200 | assetsHooksLogsListResponse403

export type assetsHooksLogsListResponse = assetsHooksLogsListResponseComposite & {
  headers: Headers
}

export const getAssetsHooksLogsListUrl = (
  parentLookupAsset: string,
  parentLookupHook: string,
  params?: AssetsHooksLogsListParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${parentLookupAsset}/hooks/${parentLookupHook}/logs/?${stringifiedParams}`
    : `/api/v2/assets/${parentLookupAsset}/hooks/${parentLookupHook}/logs/`
}

export const assetsHooksLogsList = async (
  parentLookupAsset: string,
  parentLookupHook: string,
  params?: AssetsHooksLogsListParams,
  options?: RequestInit,
): Promise<assetsHooksLogsListResponse> => {
  return fetchWithAuth<assetsHooksLogsListResponse>(
    getAssetsHooksLogsListUrl(parentLookupAsset, parentLookupHook, params),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsHooksLogsListQueryKey = (
  parentLookupAsset: string,
  parentLookupHook: string,
  params?: AssetsHooksLogsListParams,
) => {
  return [
    'api',
    'v2',
    'assets',
    parentLookupAsset,
    'hooks',
    parentLookupHook,
    'logs',
    ...(params ? [params] : []),
  ] as const
}

export const getAssetsHooksLogsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksLogsList>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  parentLookupHook: string,
  params?: AssetsHooksLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHooksLogsListQueryKey(parentLookupAsset, parentLookupHook, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksLogsList>>> = ({ signal }) =>
    assetsHooksLogsList(parentLookupAsset, parentLookupHook, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && parentLookupHook), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHooksLogsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHooksLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksLogsList>>>
export type AssetsHooksLogsListQueryError = ErrorDetail

export function useAssetsHooksLogsList<TData = Awaited<ReturnType<typeof assetsHooksLogsList>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  parentLookupHook: string,
  params?: AssetsHooksLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksLogsListQueryOptions(parentLookupAsset, parentLookupHook, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve an external service endpoint log

 */
export type assetsHooksLogsRetrieveResponse200 = {
  data: HookLog
  status: 200
}

export type assetsHooksLogsRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHooksLogsRetrieveResponseComposite =
  | assetsHooksLogsRetrieveResponse200
  | assetsHooksLogsRetrieveResponse403

export type assetsHooksLogsRetrieveResponse = assetsHooksLogsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsHooksLogsRetrieveUrl = (parentLookupAsset: string, parentLookupHook: string, uid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/hooks/${parentLookupHook}/logs/${uid}/`
}

export const assetsHooksLogsRetrieve = async (
  parentLookupAsset: string,
  parentLookupHook: string,
  uid: string,
  options?: RequestInit,
): Promise<assetsHooksLogsRetrieveResponse> => {
  return fetchWithAuth<assetsHooksLogsRetrieveResponse>(
    getAssetsHooksLogsRetrieveUrl(parentLookupAsset, parentLookupHook, uid),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsHooksLogsRetrieveQueryKey = (
  parentLookupAsset: string,
  parentLookupHook: string,
  uid: string,
) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'hooks', parentLookupHook, 'logs', uid] as const
}

export const getAssetsHooksLogsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  parentLookupHook: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAssetsHooksLogsRetrieveQueryKey(parentLookupAsset, parentLookupHook, uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>> = ({ signal }) =>
    assetsHooksLogsRetrieve(parentLookupAsset, parentLookupHook, uid, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!(parentLookupAsset && parentLookupHook && uid),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type AssetsHooksLogsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>>
export type AssetsHooksLogsRetrieveQueryError = ErrorDetail

export function useAssetsHooksLogsRetrieve<
  TData = Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  parentLookupHook: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksLogsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksLogsRetrieveQueryOptions(parentLookupAsset, parentLookupHook, uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retry a failed submission attempt

 */
export type assetsHooksLogsRetryPartialUpdateResponse200 = {
  data: LogsRetryResponse
  status: 200
}

export type assetsHooksLogsRetryPartialUpdateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHooksLogsRetryPartialUpdateResponseComposite =
  | assetsHooksLogsRetryPartialUpdateResponse200
  | assetsHooksLogsRetryPartialUpdateResponse403

export type assetsHooksLogsRetryPartialUpdateResponse = assetsHooksLogsRetryPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksLogsRetryPartialUpdateUrl = (
  parentLookupAsset: string,
  parentLookupHook: string,
  uid: string,
) => {
  return `/api/v2/assets/${parentLookupAsset}/hooks/${parentLookupHook}/logs/${uid}/retry/`
}

export const assetsHooksLogsRetryPartialUpdate = async (
  parentLookupAsset: string,
  parentLookupHook: string,
  uid: string,
  patchedHookLog: NonReadonly<PatchedHookLog>,
  options?: RequestInit,
): Promise<assetsHooksLogsRetryPartialUpdateResponse> => {
  return fetchWithAuth<assetsHooksLogsRetryPartialUpdateResponse>(
    getAssetsHooksLogsRetryPartialUpdateUrl(parentLookupAsset, parentLookupHook, uid),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedHookLog),
    },
  )
}

export const getAssetsHooksLogsRetryPartialUpdateMutationOptions = <
  TError = ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
    TError,
    { parentLookupAsset: string; parentLookupHook: string; uid: string; data: NonReadonly<PatchedHookLog> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
  TError,
  { parentLookupAsset: string; parentLookupHook: string; uid: string; data: NonReadonly<PatchedHookLog> },
  TContext
> => {
  const mutationKey = ['assetsHooksLogsRetryPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
    { parentLookupAsset: string; parentLookupHook: string; uid: string; data: NonReadonly<PatchedHookLog> }
  > = (props) => {
    const { parentLookupAsset, parentLookupHook, uid, data } = props ?? {}

    return assetsHooksLogsRetryPartialUpdate(parentLookupAsset, parentLookupHook, uid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksLogsRetryPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>
>
export type AssetsHooksLogsRetryPartialUpdateMutationBody = NonReadonly<PatchedHookLog>
export type AssetsHooksLogsRetryPartialUpdateMutationError = ErrorDetail

export const useAssetsHooksLogsRetryPartialUpdate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksLogsRetryPartialUpdate>>,
    TError,
    { parentLookupAsset: string; parentLookupHook: string; uid: string; data: NonReadonly<PatchedHookLog> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksLogsRetryPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve an external service

 */
export type assetsHooksRetrieveResponse200 = {
  data: Hook
  status: 200
}

export type assetsHooksRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsHooksRetrieveResponseComposite = assetsHooksRetrieveResponse200 | assetsHooksRetrieveResponse404

export type assetsHooksRetrieveResponse = assetsHooksRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsHooksRetrieveUrl = (parentLookupAsset: string, uid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/hooks/${uid}/`
}

export const assetsHooksRetrieve = async (
  parentLookupAsset: string,
  uid: string,
  options?: RequestInit,
): Promise<assetsHooksRetrieveResponse> => {
  return fetchWithAuth<assetsHooksRetrieveResponse>(getAssetsHooksRetrieveUrl(parentLookupAsset, uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHooksRetrieveQueryKey = (parentLookupAsset: string, uid: string) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'hooks', uid] as const
}

export const getAssetsHooksRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHooksRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHooksRetrieveQueryKey(parentLookupAsset, uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHooksRetrieve>>> = ({ signal }) =>
    assetsHooksRetrieve(parentLookupAsset, uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && uid), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHooksRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHooksRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHooksRetrieve>>>
export type AssetsHooksRetrieveQueryError = ErrorDetail

export function useAssetsHooksRetrieve<TData = Awaited<ReturnType<typeof assetsHooksRetrieve>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHooksRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHooksRetrieveQueryOptions(parentLookupAsset, uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update an external service.

 */
export type assetsHooksPartialUpdateResponse200 = {
  data: Hook
  status: 200
}

export type assetsHooksPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsHooksPartialUpdateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsHooksPartialUpdateResponseComposite =
  | assetsHooksPartialUpdateResponse200
  | assetsHooksPartialUpdateResponse400
  | assetsHooksPartialUpdateResponse404

export type assetsHooksPartialUpdateResponse = assetsHooksPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksPartialUpdateUrl = (parentLookupAsset: string, uid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/hooks/${uid}/`
}

export const assetsHooksPartialUpdate = async (
  parentLookupAsset: string,
  uid: string,
  patchedHook: NonReadonly<PatchedHook>,
  options?: RequestInit,
): Promise<assetsHooksPartialUpdateResponse> => {
  return fetchWithAuth<assetsHooksPartialUpdateResponse>(getAssetsHooksPartialUpdateUrl(parentLookupAsset, uid), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedHook),
  })
}

export const getAssetsHooksPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
    TError,
    { parentLookupAsset: string; uid: string; data: NonReadonly<PatchedHook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
  TError,
  { parentLookupAsset: string; uid: string; data: NonReadonly<PatchedHook> },
  TContext
> => {
  const mutationKey = ['assetsHooksPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
    { parentLookupAsset: string; uid: string; data: NonReadonly<PatchedHook> }
  > = (props) => {
    const { parentLookupAsset, uid, data } = props ?? {}

    return assetsHooksPartialUpdate(parentLookupAsset, uid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsHooksPartialUpdate>>>
export type AssetsHooksPartialUpdateMutationBody = NonReadonly<PatchedHook>
export type AssetsHooksPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useAssetsHooksPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksPartialUpdate>>,
    TError,
    { parentLookupAsset: string; uid: string; data: NonReadonly<PatchedHook> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete an external service.

 */
export type assetsHooksDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsHooksDestroyResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsHooksDestroyResponseComposite = assetsHooksDestroyResponse204 | assetsHooksDestroyResponse404

export type assetsHooksDestroyResponse = assetsHooksDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsHooksDestroyUrl = (parentLookupAsset: string, uid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/hooks/${uid}/`
}

export const assetsHooksDestroy = async (
  parentLookupAsset: string,
  uid: string,
  options?: RequestInit,
): Promise<assetsHooksDestroyResponse> => {
  return fetchWithAuth<assetsHooksDestroyResponse>(getAssetsHooksDestroyUrl(parentLookupAsset, uid), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsHooksDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksDestroy>>,
    TError,
    { parentLookupAsset: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksDestroy>>,
  TError,
  { parentLookupAsset: string; uid: string },
  TContext
> => {
  const mutationKey = ['assetsHooksDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksDestroy>>,
    { parentLookupAsset: string; uid: string }
  > = (props) => {
    const { parentLookupAsset, uid } = props ?? {}

    return assetsHooksDestroy(parentLookupAsset, uid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsHooksDestroy>>>

export type AssetsHooksDestroyMutationError = ErrorDetail

export const useAssetsHooksDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksDestroy>>,
    TError,
    { parentLookupAsset: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retries all failed attempts

**This call is asynchronous. Job is sent to Celery to be run in background**

It returns all logs `uid`s that are being retried.

 */
export type assetsHooksRetryPartialUpdateResponse200 = {
  data: HookRetryResponse
  status: 200
}

export type assetsHooksRetryPartialUpdateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsHooksRetryPartialUpdateResponseComposite =
  | assetsHooksRetryPartialUpdateResponse200
  | assetsHooksRetryPartialUpdateResponse404

export type assetsHooksRetryPartialUpdateResponse = assetsHooksRetryPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsHooksRetryPartialUpdateUrl = (parentLookupAsset: string, uid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/hooks/${uid}/retry/`
}

export const assetsHooksRetryPartialUpdate = async (
  parentLookupAsset: string,
  uid: string,
  options?: RequestInit,
): Promise<assetsHooksRetryPartialUpdateResponse> => {
  return fetchWithAuth<assetsHooksRetryPartialUpdateResponse>(
    getAssetsHooksRetryPartialUpdateUrl(parentLookupAsset, uid),
    {
      ...options,
      method: 'PATCH',
    },
  )
}

export const getAssetsHooksRetryPartialUpdateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
    TError,
    { parentLookupAsset: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
  TError,
  { parentLookupAsset: string; uid: string },
  TContext
> => {
  const mutationKey = ['assetsHooksRetryPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
    { parentLookupAsset: string; uid: string }
  > = (props) => {
    const { parentLookupAsset, uid } = props ?? {}

    return assetsHooksRetryPartialUpdate(parentLookupAsset, uid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHooksRetryPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>
>

export type AssetsHooksRetryPartialUpdateMutationError = ErrorDetail

export const useAssetsHooksRetryPartialUpdate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHooksRetryPartialUpdate>>,
    TError,
    { parentLookupAsset: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHooksRetryPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
