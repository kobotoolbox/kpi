/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useQuery } from '@tanstack/react-query'
import type { QueryFunction, QueryKey, UseQueryOptions, UseQueryResult } from '@tanstack/react-query'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { PaginatedUserListResponseList } from '../models/paginatedUserListResponseList'

import type { UserRetrieveResponse } from '../models/userRetrieveResponse'

import type { UsersListParams } from '../models/usersListParams'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List users

 */
export type usersListResponse200 = {
  data: PaginatedUserListResponseList
  status: 200
}

export type usersListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type usersListResponseComposite = usersListResponse200 | usersListResponse403

export type usersListResponse = usersListResponseComposite & {
  headers: Headers
}

export const getUsersListUrl = (params?: UsersListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/users/?${stringifiedParams}` : `/api/v2/users/`
}

export const usersList = async (params?: UsersListParams, options?: RequestInit): Promise<usersListResponse> => {
  return fetchWithAuth<usersListResponse>(getUsersListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getUsersListQueryKey = (params?: UsersListParams) => {
  return ['api', 'v2', 'users', ...(params ? [params] : [])] as const
}

export const getUsersListQueryOptions = <TData = Awaited<ReturnType<typeof usersList>>, TError = ErrorDetail>(
  params?: UsersListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getUsersListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersList>>> = ({ signal }) =>
    usersList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type UsersListQueryResult = NonNullable<Awaited<ReturnType<typeof usersList>>>
export type UsersListQueryError = ErrorDetail

export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = ErrorDetail>(
  params?: UsersListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUsersListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a user

 */
export type usersRetrieveResponse200 = {
  data: UserRetrieveResponse
  status: 200
}

export type usersRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type usersRetrieveResponseComposite = usersRetrieveResponse200 | usersRetrieveResponse404

export type usersRetrieveResponse = usersRetrieveResponseComposite & {
  headers: Headers
}

export const getUsersRetrieveUrl = (username: string) => {
  return `/api/v2/users/${username}/`
}

export const usersRetrieve = async (username: string, options?: RequestInit): Promise<usersRetrieveResponse> => {
  return fetchWithAuth<usersRetrieveResponse>(getUsersRetrieveUrl(username), {
    ...options,
    method: 'GET',
  })
}

export const getUsersRetrieveQueryKey = (username: string) => {
  return ['api', 'v2', 'users', username] as const
}

export const getUsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = ErrorObject>(
  username: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getUsersRetrieveQueryKey(username)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersRetrieve>>> = ({ signal }) =>
    usersRetrieve(username, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type UsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof usersRetrieve>>>
export type UsersRetrieveQueryError = ErrorObject

export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = ErrorObject>(
  username: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUsersRetrieveQueryOptions(username, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
