/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AssetsExportsListParams } from '../models/assetsExportsListParams'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { ExportCreatePayload } from '../models/exportCreatePayload'

import type { ExportResponse } from '../models/exportResponse'

import type { PaginatedExportResponseList } from '../models/paginatedExportResponseList'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List of export tasks endpoints

Lists the export tasks accessible to requesting user, for anonymous access
nothing is returned.

<sup>*</sup> _Required permissions: `view_submissions` (View submissions)_

Otherwise, the search can be more specific:

**Exports matching `uid`s:**
```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/{asset_uid}/exports/?q=uid__in:ehZUwRctkhp9QfJgvEWGg OR uid__in:ehZUwRctkhp9QfJgvDnjud
```

 */
export type assetsExportsListResponse200 = {
  data: PaginatedExportResponseList
  status: 200
}

export type assetsExportsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportsListResponseComposite =
  | assetsExportsListResponse200
  | assetsExportsListResponse403
  | assetsExportsListResponse404

export type assetsExportsListResponse = assetsExportsListResponseComposite & {
  headers: Headers
}

export const getAssetsExportsListUrl = (parentLookupAsset: string, params?: AssetsExportsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${parentLookupAsset}/exports/?${stringifiedParams}`
    : `/api/v2/assets/${parentLookupAsset}/exports/`
}

export const assetsExportsList = async (
  parentLookupAsset: string,
  params?: AssetsExportsListParams,
  options?: RequestInit,
): Promise<assetsExportsListResponse> => {
  return fetchWithAuth<assetsExportsListResponse>(getAssetsExportsListUrl(parentLookupAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsExportsListQueryKey = (parentLookupAsset: string, params?: AssetsExportsListParams) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'exports', ...(params ? [params] : [])] as const
}

export const getAssetsExportsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsExportsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  parentLookupAsset: string,
  params?: AssetsExportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsExportsListQueryKey(parentLookupAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsExportsList>>> = ({ signal }) =>
    assetsExportsList(parentLookupAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!parentLookupAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsExportsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsExportsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsExportsList>>>
export type AssetsExportsListQueryError = ErrorDetail | ErrorObject

export function useAssetsExportsList<
  TData = Awaited<ReturnType<typeof assetsExportsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  parentLookupAsset: string,
  params?: AssetsExportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsExportsListQueryOptions(parentLookupAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Creates an export task

Where:
* `fields_from_all_versions` (required) is a boolean to specify whether fields from all form versions will be included in the export.
    * `group_sep` (required) is a value used to separate the names in a hierarchy of groups. Valid inputs include:
        * Non-empty value
    * `hierarchy_in_labels` (required) is a boolean to specify whether the group hierarchy will be displayed in labels
    * `lang` (required) is a string that can be set to:
        * `_xml` to have XML values and headers, or
        * Any translation specified in the form such as `English (en)`, etc.
    * `multiple_select` (required) is a value to specify the display of `multiple_select-type` responses. Valid inputs include:
        * `both`,
        * `summary`, or
        * `details`
    * "`type`" (required) specifies the export format. Valid export formats include:
        * `csv`,
        * `geojson`,
        * `spss_labels`, or
        * `xls`
    * `fields` (optional) is an array of column names to be included in the export (including their group hierarchy). Valid inputs include:
        * An array containing any string value that matches the XML column name
        * An empty array which will result in all columns being included
        * If `fields` is not included in the `export_settings`, all columns will be included in the export
    * `flatten` (optional) is a boolean value and only relevant when exporting to "geojson" format.
    * `xls_types_as_text` (optional) is a boolean value that defaults to `false` and only affects `xls` export types.
    * `include_media_url` (optional) is a boolean value that defaults to `false` and only affects `xls` and "csv" export types. This will include an additional column for media-type questions (`question_name_URL`) with the URL link to the hosted file.
    * `submission_ids` (optional) is an array of submission ids that will filter exported submissions to only the specified array of ids. Valid inputs include:
        * An array containing integer values
        * An empty array (no filtering)
    * `query` (optional) is a JSON object containing a Mongo filter query for filtering exported submissions. Valid inputs include:
        * A JSON object containing a valid Mongo query
        * An empty JSON object (no filtering)

 */
export type assetsExportsCreateResponse201 = {
  data: ExportResponse
  status: 201
}

export type assetsExportsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsExportsCreateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsCreateResponseComposite =
  | assetsExportsCreateResponse201
  | assetsExportsCreateResponse400
  | assetsExportsCreateResponse403

export type assetsExportsCreateResponse = assetsExportsCreateResponseComposite & {
  headers: Headers
}

export const getAssetsExportsCreateUrl = (parentLookupAsset: string) => {
  return `/api/v2/assets/${parentLookupAsset}/exports/`
}

export const assetsExportsCreate = async (
  parentLookupAsset: string,
  exportCreatePayload: ExportCreatePayload,
  options?: RequestInit,
): Promise<assetsExportsCreateResponse> => {
  return fetchWithAuth<assetsExportsCreateResponse>(getAssetsExportsCreateUrl(parentLookupAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(exportCreatePayload),
  })
}

export const getAssetsExportsCreateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsCreate>>,
    TError,
    { parentLookupAsset: string; data: ExportCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsExportsCreate>>,
  TError,
  { parentLookupAsset: string; data: ExportCreatePayload },
  TContext
> => {
  const mutationKey = ['assetsExportsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsExportsCreate>>,
    { parentLookupAsset: string; data: ExportCreatePayload }
  > = (props) => {
    const { parentLookupAsset, data } = props ?? {}

    return assetsExportsCreate(parentLookupAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsExportsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsExportsCreate>>>
export type AssetsExportsCreateMutationBody = ExportCreatePayload
export type AssetsExportsCreateMutationError = ErrorObject | ErrorDetail

export const useAssetsExportsCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsCreate>>,
    TError,
    { parentLookupAsset: string; data: ExportCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsExportsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieves current export task

 */
export type assetsExportsRetrieveResponse200 = {
  data: ExportResponse
  status: 200
}

export type assetsExportsRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportsRetrieveResponseComposite =
  | assetsExportsRetrieveResponse200
  | assetsExportsRetrieveResponse403
  | assetsExportsRetrieveResponse404

export type assetsExportsRetrieveResponse = assetsExportsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsExportsRetrieveUrl = (parentLookupAsset: string, uid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/exports/${uid}/`
}

export const assetsExportsRetrieve = async (
  parentLookupAsset: string,
  uid: string,
  options?: RequestInit,
): Promise<assetsExportsRetrieveResponse> => {
  return fetchWithAuth<assetsExportsRetrieveResponse>(getAssetsExportsRetrieveUrl(parentLookupAsset, uid), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsExportsRetrieveQueryKey = (parentLookupAsset: string, uid: string) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'exports', uid] as const
}

export const getAssetsExportsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsExportsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  parentLookupAsset: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsExportsRetrieveQueryKey(parentLookupAsset, uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsExportsRetrieve>>> = ({ signal }) =>
    assetsExportsRetrieve(parentLookupAsset, uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && uid), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsExportsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsExportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsExportsRetrieve>>>
export type AssetsExportsRetrieveQueryError = ErrorDetail | ErrorObject

export function useAssetsExportsRetrieve<
  TData = Awaited<ReturnType<typeof assetsExportsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  parentLookupAsset: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsExportsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsExportsRetrieveQueryOptions(parentLookupAsset, uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Deletes current export task

 */
export type assetsExportsDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsExportsDestroyResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsExportsDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsExportsDestroyResponseComposite =
  | assetsExportsDestroyResponse204
  | assetsExportsDestroyResponse403
  | assetsExportsDestroyResponse404

export type assetsExportsDestroyResponse = assetsExportsDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsExportsDestroyUrl = (parentLookupAsset: string, uid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/exports/${uid}/`
}

export const assetsExportsDestroy = async (
  parentLookupAsset: string,
  uid: string,
  options?: RequestInit,
): Promise<assetsExportsDestroyResponse> => {
  return fetchWithAuth<assetsExportsDestroyResponse>(getAssetsExportsDestroyUrl(parentLookupAsset, uid), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsExportsDestroyMutationOptions = <
  TError = ErrorDetail | ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsDestroy>>,
    TError,
    { parentLookupAsset: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsExportsDestroy>>,
  TError,
  { parentLookupAsset: string; uid: string },
  TContext
> => {
  const mutationKey = ['assetsExportsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsExportsDestroy>>,
    { parentLookupAsset: string; uid: string }
  > = (props) => {
    const { parentLookupAsset, uid } = props ?? {}

    return assetsExportsDestroy(parentLookupAsset, uid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsExportsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsExportsDestroy>>>

export type AssetsExportsDestroyMutationError = ErrorDetail | ErrorObject

export const useAssetsExportsDestroy = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsExportsDestroy>>,
    TError,
    { parentLookupAsset: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsExportsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
