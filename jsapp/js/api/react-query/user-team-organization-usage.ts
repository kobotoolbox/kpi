/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * This page documents all KoboToolbox API endpoints.

The endpoints are grouped by area of intended use. Each category contains related endpoints, with detailed documentation on usage and configuration. Use this as a reference to quickly find the right endpoint for managing projects, forms, data, permissions, integrations, logs, and organizational resources.

**General note**: All projects (whether deployed or draft), as well as all library content (questions, blocks, templates, and collections) in the user-facing application are represented in the API as assets.
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AssetUsageListParams } from '../models/assetUsageListParams'

import type { EmailAddress } from '../models/emailAddress'

import type { EmailRequestPayload } from '../models/emailRequestPayload'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { InviteCreatePayload } from '../models/inviteCreatePayload'

import type { InviteCreateResponse } from '../models/inviteCreateResponse'

import type { InviteResponse } from '../models/inviteResponse'

import type { MeEmailsListParams } from '../models/meEmailsListParams'

import type { MeListResponse } from '../models/meListResponse'

import type { MeSocialAccountsListParams } from '../models/meSocialAccountsListParams'

import type { MemberListResponse } from '../models/memberListResponse'

import type { OrganizationResponse } from '../models/organizationResponse'

import type { OrganizationServiceUsageResponse } from '../models/organizationServiceUsageResponse'

import type { OrganizationsInvitesListParams } from '../models/organizationsInvitesListParams'

import type { OrganizationsListParams } from '../models/organizationsListParams'

import type { OrganizationsMembersListParams } from '../models/organizationsMembersListParams'

import type { PaginatedAssetList } from '../models/paginatedAssetList'

import type { PaginatedAssetUsageResponseList } from '../models/paginatedAssetUsageResponseList'

import type { PaginatedEmailAddressList } from '../models/paginatedEmailAddressList'

import type { PaginatedInviteResponseList } from '../models/paginatedInviteResponseList'

import type { PaginatedMemberListResponseList } from '../models/paginatedMemberListResponseList'

import type { PaginatedOrganizationAssetUsageResponseList } from '../models/paginatedOrganizationAssetUsageResponseList'

import type { PaginatedOrganizationResponseList } from '../models/paginatedOrganizationResponseList'

import type { PaginatedProjectViewAssetResponseList } from '../models/paginatedProjectViewAssetResponseList'

import type { PaginatedProjectViewListResponseList } from '../models/paginatedProjectViewListResponseList'

import type { PaginatedProjectViewUserResponseList } from '../models/paginatedProjectViewUserResponseList'

import type { PaginatedSocialAccountList } from '../models/paginatedSocialAccountList'

import type { PaginatedUserListResponseList } from '../models/paginatedUserListResponseList'

import type { PatchedCurrentUser } from '../models/patchedCurrentUser'

import type { PatchedInvitePatchPayload } from '../models/patchedInvitePatchPayload'

import type { PatchedMemberPatchRequest } from '../models/patchedMemberPatchRequest'

import type { PatchedOrganizationPatchPayload } from '../models/patchedOrganizationPatchPayload'

import type { ProjectViewExportCreateResponse } from '../models/projectViewExportCreateResponse'

import type { ProjectViewExportResponse } from '../models/projectViewExportResponse'

import type { ProjectViewListResponse } from '../models/projectViewListResponse'

import type { ProjectViewsAssetsRetrieveParams } from '../models/projectViewsAssetsRetrieveParams'

import type { ProjectViewsListParams } from '../models/projectViewsListParams'

import type { ProjectViewsUsersRetrieveParams } from '../models/projectViewsUsersRetrieveParams'

import type { ServiceUsageResponse } from '../models/serviceUsageResponse'

import type { SocialAccount } from '../models/socialAccount'

import type { UserRetrieveResponse } from '../models/userRetrieveResponse'

import type { UsersListParams } from '../models/usersListParams'

import { fetchWithAuth } from '../orval.mutator'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
    }
  : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## Get user's asset usage

 */
export type assetUsageListResponse200 = {
  data: PaginatedAssetUsageResponseList
  status: 200
}

export type assetUsageListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetUsageListResponseComposite = assetUsageListResponse200 | assetUsageListResponse401

export type assetUsageListResponse = assetUsageListResponseComposite & {
  headers: Headers
}

export const getAssetUsageListUrl = (params?: AssetUsageListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/asset_usage/?${stringifiedParams}` : `/api/v2/asset_usage/`
}

export const assetUsageList = async (
  params?: AssetUsageListParams,
  options?: RequestInit,
): Promise<assetUsageListResponse> => {
  return fetchWithAuth<assetUsageListResponse>(getAssetUsageListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetUsageListQueryKey = (params?: AssetUsageListParams) => {
  return ['api', 'v2', 'asset_usage', ...(params ? [params] : [])] as const
}

export const getAssetUsageListQueryOptions = <TData = Awaited<ReturnType<typeof assetUsageList>>, TError = ErrorDetail>(
  params?: AssetUsageListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetUsageList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetUsageListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetUsageList>>> = ({ signal }) =>
    assetUsageList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetUsageList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetUsageListQueryResult = NonNullable<Awaited<ReturnType<typeof assetUsageList>>>
export type AssetUsageListQueryError = ErrorDetail

export function useAssetUsageList<TData = Awaited<ReturnType<typeof assetUsageList>>, TError = ErrorDetail>(
  params?: AssetUsageListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetUsageList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetUsageListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List user's organizations

 */
export type organizationsListResponse200 = {
  data: PaginatedOrganizationResponseList
  status: 200
}

export type organizationsListResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsListResponseComposite = organizationsListResponse200 | organizationsListResponse404

export type organizationsListResponse = organizationsListResponseComposite & {
  headers: Headers
}

export const getOrganizationsListUrl = (params?: OrganizationsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/organizations/?${stringifiedParams}` : `/api/v2/organizations/`
}

export const organizationsList = async (
  params?: OrganizationsListParams,
  options?: RequestInit,
): Promise<organizationsListResponse> => {
  return fetchWithAuth<organizationsListResponse>(getOrganizationsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsListQueryKey = (params?: OrganizationsListParams) => {
  return ['api', 'v2', 'organizations', ...(params ? [params] : [])] as const
}

export const getOrganizationsListQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsList>>,
  TError = ErrorDetail,
>(
  params?: OrganizationsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsList>>> = ({ signal }) =>
    organizationsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsListQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsList>>>
export type OrganizationsListQueryError = ErrorDetail

export function useOrganizationsList<TData = Awaited<ReturnType<typeof organizationsList>>, TError = ErrorDetail>(
  params?: OrganizationsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve organization's details

 */
export type organizationsRetrieveResponse200 = {
  data: OrganizationResponse
  status: 200
}

export type organizationsRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsRetrieveResponseComposite = organizationsRetrieveResponse200 | organizationsRetrieveResponse404

export type organizationsRetrieveResponse = organizationsRetrieveResponseComposite & {
  headers: Headers
}

export const getOrganizationsRetrieveUrl = (id: string) => {
  return `/api/v2/organizations/${id}/`
}

export const organizationsRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<organizationsRetrieveResponse> => {
  return fetchWithAuth<organizationsRetrieveResponse>(getOrganizationsRetrieveUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsRetrieveQueryKey = (id: string) => {
  return ['api', 'v2', 'organizations', id] as const
}

export const getOrganizationsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsRetrieveQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsRetrieve>>> = ({ signal }) =>
    organizationsRetrieve(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsRetrieve>>>
export type OrganizationsRetrieveQueryError = ErrorDetail

export function useOrganizationsRetrieve<
  TData = Awaited<ReturnType<typeof organizationsRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsRetrieveQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update organization's details

 */
export type organizationsPartialUpdateResponse200 = {
  data: OrganizationResponse
  status: 200
}

export type organizationsPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type organizationsPartialUpdateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsPartialUpdateResponseComposite =
  | organizationsPartialUpdateResponse200
  | organizationsPartialUpdateResponse400
  | organizationsPartialUpdateResponse404

export type organizationsPartialUpdateResponse = organizationsPartialUpdateResponseComposite & {
  headers: Headers
}

export const getOrganizationsPartialUpdateUrl = (id: string) => {
  return `/api/v2/organizations/${id}/`
}

export const organizationsPartialUpdate = async (
  id: string,
  patchedOrganizationPatchPayload: PatchedOrganizationPatchPayload,
  options?: RequestInit,
): Promise<organizationsPartialUpdateResponse> => {
  return fetchWithAuth<organizationsPartialUpdateResponse>(getOrganizationsPartialUpdateUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedOrganizationPatchPayload),
  })
}

export const getOrganizationsPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsPartialUpdate>>,
    TError,
    { id: string; data: PatchedOrganizationPatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsPartialUpdate>>,
  TError,
  { id: string; data: PatchedOrganizationPatchPayload },
  TContext
> => {
  const mutationKey = ['organizationsPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsPartialUpdate>>,
    { id: string; data: PatchedOrganizationPatchPayload }
  > = (props) => {
    const { id, data } = props ?? {}

    return organizationsPartialUpdate(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type OrganizationsPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsPartialUpdate>>
>
export type OrganizationsPartialUpdateMutationBody = PatchedOrganizationPatchPayload
export type OrganizationsPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useOrganizationsPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsPartialUpdate>>,
    TError,
    { id: string; data: PatchedOrganizationPatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getOrganizationsPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve organization asset usage tracker

Tracks the total usage of each asset for the user in the given organization

 */
export type organizationsAssetUsageRetrieveResponse200 = {
  data: PaginatedOrganizationAssetUsageResponseList
  status: 200
}

export type organizationsAssetUsageRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsAssetUsageRetrieveResponseComposite =
  | organizationsAssetUsageRetrieveResponse200
  | organizationsAssetUsageRetrieveResponse404

export type organizationsAssetUsageRetrieveResponse = organizationsAssetUsageRetrieveResponseComposite & {
  headers: Headers
}

export const getOrganizationsAssetUsageRetrieveUrl = (id: string) => {
  return `/api/v2/organizations/${id}/asset_usage/`
}

export const organizationsAssetUsageRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<organizationsAssetUsageRetrieveResponse> => {
  return fetchWithAuth<organizationsAssetUsageRetrieveResponse>(getOrganizationsAssetUsageRetrieveUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsAssetUsageRetrieveQueryKey = (id: string) => {
  return ['api', 'v2', 'organizations', id, 'asset_usage'] as const
}

export const getOrganizationsAssetUsageRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsAssetUsageRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsAssetUsageRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsAssetUsageRetrieveQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsAssetUsageRetrieve>>> = ({ signal }) =>
    organizationsAssetUsageRetrieve(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsAssetUsageRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsAssetUsageRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsAssetUsageRetrieve>>
>
export type OrganizationsAssetUsageRetrieveQueryError = ErrorDetail

export function useOrganizationsAssetUsageRetrieve<
  TData = Awaited<ReturnType<typeof organizationsAssetUsageRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsAssetUsageRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsAssetUsageRetrieveQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve Organization Assets

This endpoint returns all assets associated with a specific organization.
The assets listed here are restricted to those owned by the specified
organization.

Only the owner or administrators of the organization can access this endpoint.

### Additional Information
For more details, please refer to `/api/v2/assets/`.

 */
export type organizationsAssetsRetrieveResponse200 = {
  data: PaginatedAssetList
  status: 200
}

export type organizationsAssetsRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsAssetsRetrieveResponseComposite =
  | organizationsAssetsRetrieveResponse200
  | organizationsAssetsRetrieveResponse404

export type organizationsAssetsRetrieveResponse = organizationsAssetsRetrieveResponseComposite & {
  headers: Headers
}

export const getOrganizationsAssetsRetrieveUrl = (id: string) => {
  return `/api/v2/organizations/${id}/assets/`
}

export const organizationsAssetsRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<organizationsAssetsRetrieveResponse> => {
  return fetchWithAuth<organizationsAssetsRetrieveResponse>(getOrganizationsAssetsRetrieveUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsAssetsRetrieveQueryKey = (id: string) => {
  return ['api', 'v2', 'organizations', id, 'assets'] as const
}

export const getOrganizationsAssetsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsAssetsRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsAssetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsAssetsRetrieveQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsAssetsRetrieve>>> = ({ signal }) =>
    organizationsAssetsRetrieve(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsAssetsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsAssetsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsAssetsRetrieve>>
>
export type OrganizationsAssetsRetrieveQueryError = ErrorDetail

export function useOrganizationsAssetsRetrieve<
  TData = Awaited<ReturnType<typeof organizationsAssetsRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsAssetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsAssetsRetrieveQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Organization Usage Tracker

- Tracks the total usage of different services for each account in an organization
- Tracks the submissions and NLP seconds/characters for the current month/year/all time
- Tracks the current total storage used
- Includes a detailed list of balances relative to a user's usage limits
- If no organization is found with the provided ID, returns the usage for the logged-in user

**This endpoint is cached for an amount of time determined by ENDPOINT_CACHE_DURATION**

 */
export type organizationsServiceUsageRetrieveResponse200 = {
  data: OrganizationServiceUsageResponse
  status: 200
}

export type organizationsServiceUsageRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsServiceUsageRetrieveResponseComposite =
  | organizationsServiceUsageRetrieveResponse200
  | organizationsServiceUsageRetrieveResponse404

export type organizationsServiceUsageRetrieveResponse = organizationsServiceUsageRetrieveResponseComposite & {
  headers: Headers
}

export const getOrganizationsServiceUsageRetrieveUrl = (id: string) => {
  return `/api/v2/organizations/${id}/service_usage/`
}

export const organizationsServiceUsageRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<organizationsServiceUsageRetrieveResponse> => {
  return fetchWithAuth<organizationsServiceUsageRetrieveResponse>(getOrganizationsServiceUsageRetrieveUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsServiceUsageRetrieveQueryKey = (id: string) => {
  return ['api', 'v2', 'organizations', id, 'service_usage'] as const
}

export const getOrganizationsServiceUsageRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsServiceUsageRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsServiceUsageRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsServiceUsageRetrieveQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsServiceUsageRetrieve>>> = ({ signal }) =>
    organizationsServiceUsageRetrieve(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsServiceUsageRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsServiceUsageRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsServiceUsageRetrieve>>
>
export type OrganizationsServiceUsageRetrieveQueryError = ErrorDetail

export function useOrganizationsServiceUsageRetrieve<
  TData = Awaited<ReturnType<typeof organizationsServiceUsageRetrieve>>,
  TError = ErrorDetail,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsServiceUsageRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsServiceUsageRetrieveQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List organization invites

 */
export type organizationsInvitesListResponse200 = {
  data: PaginatedInviteResponseList
  status: 200
}

export type organizationsInvitesListResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsInvitesListResponseComposite =
  | organizationsInvitesListResponse200
  | organizationsInvitesListResponse404

export type organizationsInvitesListResponse = organizationsInvitesListResponseComposite & {
  headers: Headers
}

export const getOrganizationsInvitesListUrl = (organizationId: string, params?: OrganizationsInvitesListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/organizations/${organizationId}/invites/?${stringifiedParams}`
    : `/api/v2/organizations/${organizationId}/invites/`
}

export const organizationsInvitesList = async (
  organizationId: string,
  params?: OrganizationsInvitesListParams,
  options?: RequestInit,
): Promise<organizationsInvitesListResponse> => {
  return fetchWithAuth<organizationsInvitesListResponse>(getOrganizationsInvitesListUrl(organizationId, params), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsInvitesListQueryKey = (
  organizationId: string,
  params?: OrganizationsInvitesListParams,
) => {
  return ['api', 'v2', 'organizations', organizationId, 'invites', ...(params ? [params] : [])] as const
}

export const getOrganizationsInvitesListQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsInvitesList>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  params?: OrganizationsInvitesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsInvitesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsInvitesListQueryKey(organizationId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsInvitesList>>> = ({ signal }) =>
    organizationsInvitesList(organizationId, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!organizationId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsInvitesList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsInvitesListQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsInvitesList>>>
export type OrganizationsInvitesListQueryError = ErrorDetail

export function useOrganizationsInvitesList<
  TData = Awaited<ReturnType<typeof organizationsInvitesList>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  params?: OrganizationsInvitesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsInvitesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsInvitesListQueryOptions(organizationId, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create Organization Invite

* Create organization invites for registered and unregistered users.
* Set the role for which the user is being invited -
(Choices: `member`, `admin`). Default is `member`.

 */
export type organizationsInvitesCreateResponse201 = {
  data: InviteCreateResponse
  status: 201
}

export type organizationsInvitesCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type organizationsInvitesCreateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsInvitesCreateResponseComposite =
  | organizationsInvitesCreateResponse201
  | organizationsInvitesCreateResponse400
  | organizationsInvitesCreateResponse404

export type organizationsInvitesCreateResponse = organizationsInvitesCreateResponseComposite & {
  headers: Headers
}

export const getOrganizationsInvitesCreateUrl = (organizationId: string) => {
  return `/api/v2/organizations/${organizationId}/invites/`
}

export const organizationsInvitesCreate = async (
  organizationId: string,
  inviteCreatePayload: InviteCreatePayload,
  options?: RequestInit,
): Promise<organizationsInvitesCreateResponse> => {
  return fetchWithAuth<organizationsInvitesCreateResponse>(getOrganizationsInvitesCreateUrl(organizationId), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(inviteCreatePayload),
  })
}

export const getOrganizationsInvitesCreateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsInvitesCreate>>,
    TError,
    { organizationId: string; data: InviteCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsInvitesCreate>>,
  TError,
  { organizationId: string; data: InviteCreatePayload },
  TContext
> => {
  const mutationKey = ['organizationsInvitesCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsInvitesCreate>>,
    { organizationId: string; data: InviteCreatePayload }
  > = (props) => {
    const { organizationId, data } = props ?? {}

    return organizationsInvitesCreate(organizationId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type OrganizationsInvitesCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsInvitesCreate>>
>
export type OrganizationsInvitesCreateMutationBody = InviteCreatePayload
export type OrganizationsInvitesCreateMutationError = ErrorObject | ErrorDetail

export const useOrganizationsInvitesCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsInvitesCreate>>,
    TError,
    { organizationId: string; data: InviteCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getOrganizationsInvitesCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve organization invite

 */
export type organizationsInvitesRetrieveResponse200 = {
  data: InviteResponse
  status: 200
}

export type organizationsInvitesRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsInvitesRetrieveResponseComposite =
  | organizationsInvitesRetrieveResponse200
  | organizationsInvitesRetrieveResponse404

export type organizationsInvitesRetrieveResponse = organizationsInvitesRetrieveResponseComposite & {
  headers: Headers
}

export const getOrganizationsInvitesRetrieveUrl = (organizationId: string, guid: string) => {
  return `/api/v2/organizations/${organizationId}/invites/${guid}/`
}

export const organizationsInvitesRetrieve = async (
  organizationId: string,
  guid: string,
  options?: RequestInit,
): Promise<organizationsInvitesRetrieveResponse> => {
  return fetchWithAuth<organizationsInvitesRetrieveResponse>(getOrganizationsInvitesRetrieveUrl(organizationId, guid), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsInvitesRetrieveQueryKey = (organizationId: string, guid: string) => {
  return ['api', 'v2', 'organizations', organizationId, 'invites', guid] as const
}

export const getOrganizationsInvitesRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsInvitesRetrieve>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  guid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsInvitesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsInvitesRetrieveQueryKey(organizationId, guid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsInvitesRetrieve>>> = ({ signal }) =>
    organizationsInvitesRetrieve(organizationId, guid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(organizationId && guid), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsInvitesRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsInvitesRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsInvitesRetrieve>>
>
export type OrganizationsInvitesRetrieveQueryError = ErrorDetail

export function useOrganizationsInvitesRetrieve<
  TData = Awaited<ReturnType<typeof organizationsInvitesRetrieve>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  guid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsInvitesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsInvitesRetrieveQueryOptions(organizationId, guid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update Organization Invite

* Update an organization invite to accept, decline, cancel, expire, or resend.
* Update the role of the invitee to `admin` or `member`. Only the owner or admin can update the role.


 */
export type organizationsInvitesPartialUpdateResponse200 = {
  data: InviteResponse
  status: 200
}

export type organizationsInvitesPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type organizationsInvitesPartialUpdateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type organizationsInvitesPartialUpdateResponseComposite =
  | organizationsInvitesPartialUpdateResponse200
  | organizationsInvitesPartialUpdateResponse400
  | organizationsInvitesPartialUpdateResponse403

export type organizationsInvitesPartialUpdateResponse = organizationsInvitesPartialUpdateResponseComposite & {
  headers: Headers
}

export const getOrganizationsInvitesPartialUpdateUrl = (organizationId: string, guid: string) => {
  return `/api/v2/organizations/${organizationId}/invites/${guid}/`
}

export const organizationsInvitesPartialUpdate = async (
  organizationId: string,
  guid: string,
  patchedInvitePatchPayload: PatchedInvitePatchPayload,
  options?: RequestInit,
): Promise<organizationsInvitesPartialUpdateResponse> => {
  return fetchWithAuth<organizationsInvitesPartialUpdateResponse>(
    getOrganizationsInvitesPartialUpdateUrl(organizationId, guid),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedInvitePatchPayload),
    },
  )
}

export const getOrganizationsInvitesPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsInvitesPartialUpdate>>,
    TError,
    { organizationId: string; guid: string; data: PatchedInvitePatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsInvitesPartialUpdate>>,
  TError,
  { organizationId: string; guid: string; data: PatchedInvitePatchPayload },
  TContext
> => {
  const mutationKey = ['organizationsInvitesPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsInvitesPartialUpdate>>,
    { organizationId: string; guid: string; data: PatchedInvitePatchPayload }
  > = (props) => {
    const { organizationId, guid, data } = props ?? {}

    return organizationsInvitesPartialUpdate(organizationId, guid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type OrganizationsInvitesPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsInvitesPartialUpdate>>
>
export type OrganizationsInvitesPartialUpdateMutationBody = PatchedInvitePatchPayload
export type OrganizationsInvitesPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useOrganizationsInvitesPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsInvitesPartialUpdate>>,
    TError,
    { organizationId: string; guid: string; data: PatchedInvitePatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getOrganizationsInvitesPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete Organization Invite

* Organization owner or admin can delete an organization invite.

 */
export type organizationsInvitesDestroyResponse204 = {
  data: void
  status: 204
}

export type organizationsInvitesDestroyResponse403 = {
  data: ErrorDetail
  status: 403
}

export type organizationsInvitesDestroyResponseComposite =
  | organizationsInvitesDestroyResponse204
  | organizationsInvitesDestroyResponse403

export type organizationsInvitesDestroyResponse = organizationsInvitesDestroyResponseComposite & {
  headers: Headers
}

export const getOrganizationsInvitesDestroyUrl = (organizationId: string, guid: string) => {
  return `/api/v2/organizations/${organizationId}/invites/${guid}/`
}

export const organizationsInvitesDestroy = async (
  organizationId: string,
  guid: string,
  options?: RequestInit,
): Promise<organizationsInvitesDestroyResponse> => {
  return fetchWithAuth<organizationsInvitesDestroyResponse>(getOrganizationsInvitesDestroyUrl(organizationId, guid), {
    ...options,
    method: 'DELETE',
  })
}

export const getOrganizationsInvitesDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsInvitesDestroy>>,
    TError,
    { organizationId: string; guid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsInvitesDestroy>>,
  TError,
  { organizationId: string; guid: string },
  TContext
> => {
  const mutationKey = ['organizationsInvitesDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsInvitesDestroy>>,
    { organizationId: string; guid: string }
  > = (props) => {
    const { organizationId, guid } = props ?? {}

    return organizationsInvitesDestroy(organizationId, guid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type OrganizationsInvitesDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsInvitesDestroy>>
>

export type OrganizationsInvitesDestroyMutationError = ErrorDetail

export const useOrganizationsInvitesDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsInvitesDestroy>>,
    TError,
    { organizationId: string; guid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getOrganizationsInvitesDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List Members

Retrieves all members in the specified organization.

 */
export type organizationsMembersListResponse200 = {
  data: PaginatedMemberListResponseList
  status: 200
}

export type organizationsMembersListResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsMembersListResponseComposite =
  | organizationsMembersListResponse200
  | organizationsMembersListResponse404

export type organizationsMembersListResponse = organizationsMembersListResponseComposite & {
  headers: Headers
}

export const getOrganizationsMembersListUrl = (organizationId: string, params?: OrganizationsMembersListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/organizations/${organizationId}/members/?${stringifiedParams}`
    : `/api/v2/organizations/${organizationId}/members/`
}

export const organizationsMembersList = async (
  organizationId: string,
  params?: OrganizationsMembersListParams,
  options?: RequestInit,
): Promise<organizationsMembersListResponse> => {
  return fetchWithAuth<organizationsMembersListResponse>(getOrganizationsMembersListUrl(organizationId, params), {
    ...options,
    method: 'GET',
  })
}

export const getOrganizationsMembersListQueryKey = (
  organizationId: string,
  params?: OrganizationsMembersListParams,
) => {
  return ['api', 'v2', 'organizations', organizationId, 'members', ...(params ? [params] : [])] as const
}

export const getOrganizationsMembersListQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsMembersList>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  params?: OrganizationsMembersListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsMembersList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsMembersListQueryKey(organizationId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsMembersList>>> = ({ signal }) =>
    organizationsMembersList(organizationId, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!organizationId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsMembersList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsMembersListQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsMembersList>>>
export type OrganizationsMembersListQueryError = ErrorDetail

export function useOrganizationsMembersList<
  TData = Awaited<ReturnType<typeof organizationsMembersList>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  params?: OrganizationsMembersListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsMembersList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsMembersListQueryOptions(organizationId, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve Member Details

Retrieves the details of a specific member within an organization by username.

 */
export type organizationsMembersRetrieveResponse200 = {
  data: MemberListResponse
  status: 200
}

export type organizationsMembersRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type organizationsMembersRetrieveResponseComposite =
  | organizationsMembersRetrieveResponse200
  | organizationsMembersRetrieveResponse404

export type organizationsMembersRetrieveResponse = organizationsMembersRetrieveResponseComposite & {
  headers: Headers
}

export const getOrganizationsMembersRetrieveUrl = (organizationId: string, userUsername: string) => {
  return `/api/v2/organizations/${organizationId}/members/${userUsername}/`
}

export const organizationsMembersRetrieve = async (
  organizationId: string,
  userUsername: string,
  options?: RequestInit,
): Promise<organizationsMembersRetrieveResponse> => {
  return fetchWithAuth<organizationsMembersRetrieveResponse>(
    getOrganizationsMembersRetrieveUrl(organizationId, userUsername),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getOrganizationsMembersRetrieveQueryKey = (organizationId: string, userUsername: string) => {
  return ['api', 'v2', 'organizations', organizationId, 'members', userUsername] as const
}

export const getOrganizationsMembersRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsMembersRetrieve>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  userUsername: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsMembersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOrganizationsMembersRetrieveQueryKey(organizationId, userUsername)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsMembersRetrieve>>> = ({ signal }) =>
    organizationsMembersRetrieve(organizationId, userUsername, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(organizationId && userUsername), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsMembersRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OrganizationsMembersRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsMembersRetrieve>>
>
export type OrganizationsMembersRetrieveQueryError = ErrorDetail

export function useOrganizationsMembersRetrieve<
  TData = Awaited<ReturnType<typeof organizationsMembersRetrieve>>,
  TError = ErrorDetail,
>(
  organizationId: string,
  userUsername: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof organizationsMembersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOrganizationsMembersRetrieveQueryOptions(organizationId, userUsername, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update Member Role

Updates the role of a member within the organization to `admin` or
`member`.

- **admin**: Grants the member admin privileges within the organization
- **member**: Revokes admin privileges, setting the member as a regular user

 */
export type organizationsMembersPartialUpdateResponse200 = {
  data: MemberListResponse
  status: 200
}

export type organizationsMembersPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type organizationsMembersPartialUpdateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type organizationsMembersPartialUpdateResponseComposite =
  | organizationsMembersPartialUpdateResponse200
  | organizationsMembersPartialUpdateResponse400
  | organizationsMembersPartialUpdateResponse403

export type organizationsMembersPartialUpdateResponse = organizationsMembersPartialUpdateResponseComposite & {
  headers: Headers
}

export const getOrganizationsMembersPartialUpdateUrl = (organizationId: string, userUsername: string) => {
  return `/api/v2/organizations/${organizationId}/members/${userUsername}/`
}

export const organizationsMembersPartialUpdate = async (
  organizationId: string,
  userUsername: string,
  patchedMemberPatchRequest: PatchedMemberPatchRequest,
  options?: RequestInit,
): Promise<organizationsMembersPartialUpdateResponse> => {
  return fetchWithAuth<organizationsMembersPartialUpdateResponse>(
    getOrganizationsMembersPartialUpdateUrl(organizationId, userUsername),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedMemberPatchRequest),
    },
  )
}

export const getOrganizationsMembersPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsMembersPartialUpdate>>,
    TError,
    { organizationId: string; userUsername: string; data: PatchedMemberPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsMembersPartialUpdate>>,
  TError,
  { organizationId: string; userUsername: string; data: PatchedMemberPatchRequest },
  TContext
> => {
  const mutationKey = ['organizationsMembersPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsMembersPartialUpdate>>,
    { organizationId: string; userUsername: string; data: PatchedMemberPatchRequest }
  > = (props) => {
    const { organizationId, userUsername, data } = props ?? {}

    return organizationsMembersPartialUpdate(organizationId, userUsername, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type OrganizationsMembersPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsMembersPartialUpdate>>
>
export type OrganizationsMembersPartialUpdateMutationBody = PatchedMemberPatchRequest
export type OrganizationsMembersPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useOrganizationsMembersPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsMembersPartialUpdate>>,
    TError,
    { organizationId: string; userUsername: string; data: PatchedMemberPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getOrganizationsMembersPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Remove Member

Delete an organization member.

 */
export type organizationsMembersDestroyResponse204 = {
  data: void
  status: 204
}

export type organizationsMembersDestroyResponse403 = {
  data: ErrorDetail
  status: 403
}

export type organizationsMembersDestroyResponseComposite =
  | organizationsMembersDestroyResponse204
  | organizationsMembersDestroyResponse403

export type organizationsMembersDestroyResponse = organizationsMembersDestroyResponseComposite & {
  headers: Headers
}

export const getOrganizationsMembersDestroyUrl = (organizationId: string, userUsername: string) => {
  return `/api/v2/organizations/${organizationId}/members/${userUsername}/`
}

export const organizationsMembersDestroy = async (
  organizationId: string,
  userUsername: string,
  options?: RequestInit,
): Promise<organizationsMembersDestroyResponse> => {
  return fetchWithAuth<organizationsMembersDestroyResponse>(
    getOrganizationsMembersDestroyUrl(organizationId, userUsername),
    {
      ...options,
      method: 'DELETE',
    },
  )
}

export const getOrganizationsMembersDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsMembersDestroy>>,
    TError,
    { organizationId: string; userUsername: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsMembersDestroy>>,
  TError,
  { organizationId: string; userUsername: string },
  TContext
> => {
  const mutationKey = ['organizationsMembersDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsMembersDestroy>>,
    { organizationId: string; userUsername: string }
  > = (props) => {
    const { organizationId, userUsername } = props ?? {}

    return organizationsMembersDestroy(organizationId, userUsername, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type OrganizationsMembersDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsMembersDestroy>>
>

export type OrganizationsMembersDestroyMutationError = ErrorDetail

export const useOrganizationsMembersDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsMembersDestroy>>,
    TError,
    { organizationId: string; userUsername: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getOrganizationsMembersDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List project views for current user

 */
export type projectViewsListResponse200 = {
  data: PaginatedProjectViewListResponseList
  status: 200
}

export type projectViewsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectViewsListResponseComposite = projectViewsListResponse200 | projectViewsListResponse403

export type projectViewsListResponse = projectViewsListResponseComposite & {
  headers: Headers
}

export const getProjectViewsListUrl = (params?: ProjectViewsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/project-views/?${stringifiedParams}` : `/api/v2/project-views/`
}

export const projectViewsList = async (
  params?: ProjectViewsListParams,
  options?: RequestInit,
): Promise<projectViewsListResponse> => {
  return fetchWithAuth<projectViewsListResponse>(getProjectViewsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getProjectViewsListQueryKey = (params?: ProjectViewsListParams) => {
  return ['api', 'v2', 'project-views', ...(params ? [params] : [])] as const
}

export const getProjectViewsListQueryOptions = <
  TData = Awaited<ReturnType<typeof projectViewsList>>,
  TError = ErrorDetail,
>(
  params?: ProjectViewsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectViewsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectViewsList>>> = ({ signal }) =>
    projectViewsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectViewsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectViewsListQueryResult = NonNullable<Awaited<ReturnType<typeof projectViewsList>>>
export type ProjectViewsListQueryError = ErrorDetail

export function useProjectViewsList<TData = Awaited<ReturnType<typeof projectViewsList>>, TError = ErrorDetail>(
  params?: ProjectViewsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectViewsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve project view of a shared project to current user

 */
export type projectViewsRetrieveResponse200 = {
  data: ProjectViewListResponse
  status: 200
}

export type projectViewsRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectViewsRetrieveResponseComposite = projectViewsRetrieveResponse200 | projectViewsRetrieveResponse403

export type projectViewsRetrieveResponse = projectViewsRetrieveResponseComposite & {
  headers: Headers
}

export const getProjectViewsRetrieveUrl = (uid: string) => {
  return `/api/v2/project-views/${uid}/`
}

export const projectViewsRetrieve = async (
  uid: string,
  options?: RequestInit,
): Promise<projectViewsRetrieveResponse> => {
  return fetchWithAuth<projectViewsRetrieveResponse>(getProjectViewsRetrieveUrl(uid), {
    ...options,
    method: 'GET',
  })
}

export const getProjectViewsRetrieveQueryKey = (uid: string) => {
  return ['api', 'v2', 'project-views', uid] as const
}

export const getProjectViewsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectViewsRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectViewsRetrieveQueryKey(uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectViewsRetrieve>>> = ({ signal }) =>
    projectViewsRetrieve(uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectViewsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectViewsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof projectViewsRetrieve>>>
export type ProjectViewsRetrieveQueryError = ErrorDetail

export function useProjectViewsRetrieve<TData = Awaited<ReturnType<typeof projectViewsRetrieve>>, TError = ErrorDetail>(
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectViewsRetrieveQueryOptions(uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve an export for the requested object

* Note: `{obj_type}` can either be `users` or `assets`


 */
export type projectViewsExportRetrieveResponse200 = {
  data: ProjectViewExportResponse
  status: 200
}

export type projectViewsExportRetrieveResponse400 = {
  data: ErrorObject
  status: 400
}

export type projectViewsExportRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type projectViewsExportRetrieveResponseComposite =
  | projectViewsExportRetrieveResponse200
  | projectViewsExportRetrieveResponse400
  | projectViewsExportRetrieveResponse401

export type projectViewsExportRetrieveResponse = projectViewsExportRetrieveResponseComposite & {
  headers: Headers
}

export const getProjectViewsExportRetrieveUrl = (uid: string, objType: string) => {
  return `/api/v2/project-views/${uid}/${objType}/export/`
}

export const projectViewsExportRetrieve = async (
  uid: string,
  objType: string,
  options?: RequestInit,
): Promise<projectViewsExportRetrieveResponse> => {
  return fetchWithAuth<projectViewsExportRetrieveResponse>(getProjectViewsExportRetrieveUrl(uid, objType), {
    ...options,
    method: 'GET',
  })
}

export const getProjectViewsExportRetrieveQueryKey = (uid: string, objType: string) => {
  return ['api', 'v2', 'project-views', uid, objType, 'export'] as const
}

export const getProjectViewsExportRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectViewsExportRetrieve>>,
  TError = ErrorObject | ErrorDetail,
>(
  uid: string,
  objType: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsExportRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectViewsExportRetrieveQueryKey(uid, objType)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectViewsExportRetrieve>>> = ({ signal }) =>
    projectViewsExportRetrieve(uid, objType, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uid && objType), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectViewsExportRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectViewsExportRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof projectViewsExportRetrieve>>>
export type ProjectViewsExportRetrieveQueryError = ErrorObject | ErrorDetail

export function useProjectViewsExportRetrieve<
  TData = Awaited<ReturnType<typeof projectViewsExportRetrieve>>,
  TError = ErrorObject | ErrorDetail,
>(
  uid: string,
  objType: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsExportRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectViewsExportRetrieveQueryOptions(uid, objType, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export for the requested object

* Note: `{obj_type}` can either be `users` or `assets`

 */
export type projectViewsExportCreateResponse200 = {
  data: ProjectViewExportCreateResponse
  status: 200
}

export type projectViewsExportCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type projectViewsExportCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type projectViewsExportCreateResponseComposite =
  | projectViewsExportCreateResponse200
  | projectViewsExportCreateResponse400
  | projectViewsExportCreateResponse401

export type projectViewsExportCreateResponse = projectViewsExportCreateResponseComposite & {
  headers: Headers
}

export const getProjectViewsExportCreateUrl = (uid: string, objType: string) => {
  return `/api/v2/project-views/${uid}/${objType}/export/`
}

export const projectViewsExportCreate = async (
  uid: string,
  objType: string,
  options?: RequestInit,
): Promise<projectViewsExportCreateResponse> => {
  return fetchWithAuth<projectViewsExportCreateResponse>(getProjectViewsExportCreateUrl(uid, objType), {
    ...options,
    method: 'POST',
  })
}

export const getProjectViewsExportCreateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectViewsExportCreate>>,
    TError,
    { uid: string; objType: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof projectViewsExportCreate>>,
  TError,
  { uid: string; objType: string },
  TContext
> => {
  const mutationKey = ['projectViewsExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof projectViewsExportCreate>>,
    { uid: string; objType: string }
  > = (props) => {
    const { uid, objType } = props ?? {}

    return projectViewsExportCreate(uid, objType, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProjectViewsExportCreateMutationResult = NonNullable<Awaited<ReturnType<typeof projectViewsExportCreate>>>

export type ProjectViewsExportCreateMutationError = ErrorObject | ErrorDetail

export const useProjectViewsExportCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectViewsExportCreate>>,
    TError,
    { uid: string; objType: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getProjectViewsExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve assets available in project view

 */
export type projectViewsAssetsRetrieveResponse200 = {
  data: PaginatedProjectViewAssetResponseList
  status: 200
}

export type projectViewsAssetsRetrieveResponse400 = {
  data: ErrorObject
  status: 400
}

export type projectViewsAssetsRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type projectViewsAssetsRetrieveResponseComposite =
  | projectViewsAssetsRetrieveResponse200
  | projectViewsAssetsRetrieveResponse400
  | projectViewsAssetsRetrieveResponse401

export type projectViewsAssetsRetrieveResponse = projectViewsAssetsRetrieveResponseComposite & {
  headers: Headers
}

export const getProjectViewsAssetsRetrieveUrl = (uid: string, params?: ProjectViewsAssetsRetrieveParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/project-views/${uid}/assets/?${stringifiedParams}`
    : `/api/v2/project-views/${uid}/assets/`
}

export const projectViewsAssetsRetrieve = async (
  uid: string,
  params?: ProjectViewsAssetsRetrieveParams,
  options?: RequestInit,
): Promise<projectViewsAssetsRetrieveResponse> => {
  return fetchWithAuth<projectViewsAssetsRetrieveResponse>(getProjectViewsAssetsRetrieveUrl(uid, params), {
    ...options,
    method: 'GET',
  })
}

export const getProjectViewsAssetsRetrieveQueryKey = (uid: string, params?: ProjectViewsAssetsRetrieveParams) => {
  return ['api', 'v2', 'project-views', uid, 'assets', ...(params ? [params] : [])] as const
}

export const getProjectViewsAssetsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectViewsAssetsRetrieve>>,
  TError = ErrorObject | ErrorDetail,
>(
  uid: string,
  params?: ProjectViewsAssetsRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsAssetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectViewsAssetsRetrieveQueryKey(uid, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectViewsAssetsRetrieve>>> = ({ signal }) =>
    projectViewsAssetsRetrieve(uid, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectViewsAssetsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectViewsAssetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof projectViewsAssetsRetrieve>>>
export type ProjectViewsAssetsRetrieveQueryError = ErrorObject | ErrorDetail

export function useProjectViewsAssetsRetrieve<
  TData = Awaited<ReturnType<typeof projectViewsAssetsRetrieve>>,
  TError = ErrorObject | ErrorDetail,
>(
  uid: string,
  params?: ProjectViewsAssetsRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsAssetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectViewsAssetsRetrieveQueryOptions(uid, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve users available in project view

 */
export type projectViewsUsersRetrieveResponse200 = {
  data: PaginatedProjectViewUserResponseList
  status: 200
}

export type projectViewsUsersRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectViewsUsersRetrieveResponseComposite =
  | projectViewsUsersRetrieveResponse200
  | projectViewsUsersRetrieveResponse403

export type projectViewsUsersRetrieveResponse = projectViewsUsersRetrieveResponseComposite & {
  headers: Headers
}

export const getProjectViewsUsersRetrieveUrl = (uid: string, params?: ProjectViewsUsersRetrieveParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/project-views/${uid}/users/?${stringifiedParams}`
    : `/api/v2/project-views/${uid}/users/`
}

export const projectViewsUsersRetrieve = async (
  uid: string,
  params?: ProjectViewsUsersRetrieveParams,
  options?: RequestInit,
): Promise<projectViewsUsersRetrieveResponse> => {
  return fetchWithAuth<projectViewsUsersRetrieveResponse>(getProjectViewsUsersRetrieveUrl(uid, params), {
    ...options,
    method: 'GET',
  })
}

export const getProjectViewsUsersRetrieveQueryKey = (uid: string, params?: ProjectViewsUsersRetrieveParams) => {
  return ['api', 'v2', 'project-views', uid, 'users', ...(params ? [params] : [])] as const
}

export const getProjectViewsUsersRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectViewsUsersRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  params?: ProjectViewsUsersRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsUsersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectViewsUsersRetrieveQueryKey(uid, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectViewsUsersRetrieve>>> = ({ signal }) =>
    projectViewsUsersRetrieve(uid, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectViewsUsersRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectViewsUsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof projectViewsUsersRetrieve>>>
export type ProjectViewsUsersRetrieveQueryError = ErrorDetail

export function useProjectViewsUsersRetrieve<
  TData = Awaited<ReturnType<typeof projectViewsUsersRetrieve>>,
  TError = ErrorDetail,
>(
  uid: string,
  params?: ProjectViewsUsersRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectViewsUsersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectViewsUsersRetrieveQueryOptions(uid, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * <span class='label label-warning'>‚ö†Ô∏è Deprecated</span>
## Track Service Usage

Tracks the total usage of different services for the logged-in user. </br>
Tracks the submissions and NLP seconds/characters for the current month/year/all time. </br>
Tracks the current total storage used. </br>
Note: this endpoint is not currently used by the frontend to display usage information. </br>
See `/api/v2/organizations/{organization_id}/service_usage/` for the endpoint we use on the Usage page. </br>

 */
export type serviceUsageListResponse200 = {
  data: ServiceUsageResponse[]
  status: 200
}

export type serviceUsageListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type serviceUsageListResponseComposite = serviceUsageListResponse200 | serviceUsageListResponse401

export type serviceUsageListResponse = serviceUsageListResponseComposite & {
  headers: Headers
}

export const getServiceUsageListUrl = () => {
  return `/api/v2/service_usage/`
}

export const serviceUsageList = async (options?: RequestInit): Promise<serviceUsageListResponse> => {
  return fetchWithAuth<serviceUsageListResponse>(getServiceUsageListUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getServiceUsageListQueryKey = () => {
  return ['api', 'v2', 'service_usage'] as const
}

export const getServiceUsageListQueryOptions = <
  TData = Awaited<ReturnType<typeof serviceUsageList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof serviceUsageList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getServiceUsageListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof serviceUsageList>>> = ({ signal }) =>
    serviceUsageList({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof serviceUsageList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ServiceUsageListQueryResult = NonNullable<Awaited<ReturnType<typeof serviceUsageList>>>
export type ServiceUsageListQueryError = ErrorDetail

export function useServiceUsageList<
  TData = Awaited<ReturnType<typeof serviceUsageList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof serviceUsageList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getServiceUsageListQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List users

 */
export type usersListResponse200 = {
  data: PaginatedUserListResponseList
  status: 200
}

export type usersListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type usersListResponseComposite = usersListResponse200 | usersListResponse403

export type usersListResponse = usersListResponseComposite & {
  headers: Headers
}

export const getUsersListUrl = (params?: UsersListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/users/?${stringifiedParams}` : `/api/v2/users/`
}

export const usersList = async (params?: UsersListParams, options?: RequestInit): Promise<usersListResponse> => {
  return fetchWithAuth<usersListResponse>(getUsersListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getUsersListQueryKey = (params?: UsersListParams) => {
  return ['api', 'v2', 'users', ...(params ? [params] : [])] as const
}

export const getUsersListQueryOptions = <TData = Awaited<ReturnType<typeof usersList>>, TError = ErrorDetail>(
  params?: UsersListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getUsersListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersList>>> = ({ signal }) =>
    usersList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type UsersListQueryResult = NonNullable<Awaited<ReturnType<typeof usersList>>>
export type UsersListQueryError = ErrorDetail

export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = ErrorDetail>(
  params?: UsersListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUsersListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a user

 */
export type usersRetrieveResponse200 = {
  data: UserRetrieveResponse
  status: 200
}

export type usersRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type usersRetrieveResponseComposite = usersRetrieveResponse200 | usersRetrieveResponse404

export type usersRetrieveResponse = usersRetrieveResponseComposite & {
  headers: Headers
}

export const getUsersRetrieveUrl = (username: string) => {
  return `/api/v2/users/${username}/`
}

export const usersRetrieve = async (username: string, options?: RequestInit): Promise<usersRetrieveResponse> => {
  return fetchWithAuth<usersRetrieveResponse>(getUsersRetrieveUrl(username), {
    ...options,
    method: 'GET',
  })
}

export const getUsersRetrieveQueryKey = (username: string) => {
  return ['api', 'v2', 'users', username] as const
}

export const getUsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = ErrorDetail>(
  username: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getUsersRetrieveQueryKey(username)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersRetrieve>>> = ({ signal }) =>
    usersRetrieve(username, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type UsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof usersRetrieve>>>
export type UsersRetrieveQueryError = ErrorDetail

export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = ErrorDetail>(
  username: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUsersRetrieveQueryOptions(username, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve current user profile

 */
export type meRetrieveResponse200 = {
  data: MeListResponse
  status: 200
}

export type meRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meRetrieveResponseComposite = meRetrieveResponse200 | meRetrieveResponse401

export type meRetrieveResponse = meRetrieveResponseComposite & {
  headers: Headers
}

export const getMeRetrieveUrl = () => {
  return `/me/`
}

export const meRetrieve = async (options?: RequestInit): Promise<meRetrieveResponse> => {
  return fetchWithAuth<meRetrieveResponse>(getMeRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getMeRetrieveQueryKey = () => {
  return ['me'] as const
}

export const getMeRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof meRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof meRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meRetrieve>>> = ({ signal }) =>
    meRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof meRetrieve>>>
export type MeRetrieveQueryError = ErrorDetail

export function useMeRetrieve<TData = Awaited<ReturnType<typeof meRetrieve>>, TError = ErrorDetail>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof meRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update current user infos

 */
export type mePartialUpdateResponse200 = {
  data: MeListResponse
  status: 200
}

export type mePartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type mePartialUpdateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type mePartialUpdateResponseComposite =
  | mePartialUpdateResponse200
  | mePartialUpdateResponse400
  | mePartialUpdateResponse401

export type mePartialUpdateResponse = mePartialUpdateResponseComposite & {
  headers: Headers
}

export const getMePartialUpdateUrl = () => {
  return `/me/`
}

export const mePartialUpdate = async (
  patchedCurrentUser: NonReadonly<PatchedCurrentUser>,
  options?: RequestInit,
): Promise<mePartialUpdateResponse> => {
  return fetchWithAuth<mePartialUpdateResponse>(getMePartialUpdateUrl(), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedCurrentUser),
  })
}

export const getMePartialUpdateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mePartialUpdate>>,
    TError,
    { data: NonReadonly<PatchedCurrentUser> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof mePartialUpdate>>,
  TError,
  { data: NonReadonly<PatchedCurrentUser> },
  TContext
> => {
  const mutationKey = ['mePartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mePartialUpdate>>,
    { data: NonReadonly<PatchedCurrentUser> }
  > = (props) => {
    const { data } = props ?? {}

    return mePartialUpdate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof mePartialUpdate>>>
export type MePartialUpdateMutationBody = NonReadonly<PatchedCurrentUser>
export type MePartialUpdateMutationError = ErrorObject | ErrorDetail

export const useMePartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mePartialUpdate>>,
    TError,
    { data: NonReadonly<PatchedCurrentUser> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMePartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete current user

> Payload Example:
>
>       {
>           "confirm": "user__extra_details__uid",
>       }


### !! Due to current DRF-Spectacular limitations with AOS 3.1, DELETE operations do not display request or response bodies in this documentation (as payloads are not typically recommended for DELETE). This means direct testing is unavailable. However, example payloads and responses are provided for reference, and HTTP codes/error messages are accurate.  !!

 */
export type meDestroyResponse204 = {
  data: void
  status: 204
}

export type meDestroyResponse400 = {
  data: ErrorObject
  status: 400
}

export type meDestroyResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meDestroyResponseComposite = meDestroyResponse204 | meDestroyResponse400 | meDestroyResponse401

export type meDestroyResponse = meDestroyResponseComposite & {
  headers: Headers
}

export const getMeDestroyUrl = () => {
  return `/me/`
}

export const meDestroy = async (options?: RequestInit): Promise<meDestroyResponse> => {
  return fetchWithAuth<meDestroyResponse>(getMeDestroyUrl(), {
    ...options,
    method: 'DELETE',
  })
}

export const getMeDestroyMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof meDestroy>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof meDestroy>>, TError, void, TContext> => {
  const mutationKey = ['meDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof meDestroy>>, void> = () => {
    return meDestroy(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MeDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof meDestroy>>>

export type MeDestroyMutationError = ErrorObject | ErrorDetail

export const useMeDestroy = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof meDestroy>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMeDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## View current user's email

 */
export type meEmailsListResponse200 = {
  data: PaginatedEmailAddressList
  status: 200
}

export type meEmailsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meEmailsListResponseComposite = meEmailsListResponse200 | meEmailsListResponse401

export type meEmailsListResponse = meEmailsListResponseComposite & {
  headers: Headers
}

export const getMeEmailsListUrl = (params?: MeEmailsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/me/emails/?${stringifiedParams}` : `/me/emails/`
}

export const meEmailsList = async (
  params?: MeEmailsListParams,
  options?: RequestInit,
): Promise<meEmailsListResponse> => {
  return fetchWithAuth<meEmailsListResponse>(getMeEmailsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getMeEmailsListQueryKey = (params?: MeEmailsListParams) => {
  return ['me', 'emails', ...(params ? [params] : [])] as const
}

export const getMeEmailsListQueryOptions = <TData = Awaited<ReturnType<typeof meEmailsList>>, TError = ErrorDetail>(
  params?: MeEmailsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meEmailsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeEmailsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meEmailsList>>> = ({ signal }) =>
    meEmailsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meEmailsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeEmailsListQueryResult = NonNullable<Awaited<ReturnType<typeof meEmailsList>>>
export type MeEmailsListQueryError = ErrorDetail

export function useMeEmailsList<TData = Awaited<ReturnType<typeof meEmailsList>>, TError = ErrorDetail>(
  params?: MeEmailsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meEmailsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeEmailsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Set a new email

The new email will be unverified and replace existing unverified, non-primary emails.
New email is not usable until verified.

 */
export type meEmailsCreateResponse201 = {
  data: EmailAddress
  status: 201
}

export type meEmailsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type meEmailsCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meEmailsCreateResponseComposite =
  | meEmailsCreateResponse201
  | meEmailsCreateResponse400
  | meEmailsCreateResponse401

export type meEmailsCreateResponse = meEmailsCreateResponseComposite & {
  headers: Headers
}

export const getMeEmailsCreateUrl = () => {
  return `/me/emails/`
}

export const meEmailsCreate = async (
  emailRequestPayload: EmailRequestPayload,
  options?: RequestInit,
): Promise<meEmailsCreateResponse> => {
  return fetchWithAuth<meEmailsCreateResponse>(getMeEmailsCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(emailRequestPayload),
  })
}

export const getMeEmailsCreateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meEmailsCreate>>,
    TError,
    { data: EmailRequestPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof meEmailsCreate>>, TError, { data: EmailRequestPayload }, TContext> => {
  const mutationKey = ['meEmailsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof meEmailsCreate>>, { data: EmailRequestPayload }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return meEmailsCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MeEmailsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meEmailsCreate>>>
export type MeEmailsCreateMutationBody = EmailRequestPayload
export type MeEmailsCreateMutationError = ErrorObject | ErrorDetail

export const useMeEmailsCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meEmailsCreate>>,
    TError,
    { data: EmailRequestPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMeEmailsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List user's social accounts

 */
export type meSocialAccountsListResponse200 = {
  data: PaginatedSocialAccountList
  status: 200
}

export type meSocialAccountsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meSocialAccountsListResponseComposite = meSocialAccountsListResponse200 | meSocialAccountsListResponse401

export type meSocialAccountsListResponse = meSocialAccountsListResponseComposite & {
  headers: Headers
}

export const getMeSocialAccountsListUrl = (params?: MeSocialAccountsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/me/social-accounts/?${stringifiedParams}` : `/me/social-accounts/`
}

export const meSocialAccountsList = async (
  params?: MeSocialAccountsListParams,
  options?: RequestInit,
): Promise<meSocialAccountsListResponse> => {
  return fetchWithAuth<meSocialAccountsListResponse>(getMeSocialAccountsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getMeSocialAccountsListQueryKey = (params?: MeSocialAccountsListParams) => {
  return ['me', 'social-accounts', ...(params ? [params] : [])] as const
}

export const getMeSocialAccountsListQueryOptions = <
  TData = Awaited<ReturnType<typeof meSocialAccountsList>>,
  TError = ErrorDetail,
>(
  params?: MeSocialAccountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeSocialAccountsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meSocialAccountsList>>> = ({ signal }) =>
    meSocialAccountsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meSocialAccountsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeSocialAccountsListQueryResult = NonNullable<Awaited<ReturnType<typeof meSocialAccountsList>>>
export type MeSocialAccountsListQueryError = ErrorDetail

export function useMeSocialAccountsList<TData = Awaited<ReturnType<typeof meSocialAccountsList>>, TError = ErrorDetail>(
  params?: MeSocialAccountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeSocialAccountsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a social account provider

 */
export type meSocialAccountsRetrieveResponse200 = {
  data: SocialAccount
  status: 200
}

export type meSocialAccountsRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meSocialAccountsRetrieveResponseComposite =
  | meSocialAccountsRetrieveResponse200
  | meSocialAccountsRetrieveResponse401

export type meSocialAccountsRetrieveResponse = meSocialAccountsRetrieveResponseComposite & {
  headers: Headers
}

export const getMeSocialAccountsRetrieveUrl = (provider: string, uid: string) => {
  return `/me/social-accounts/${provider}/${uid}/`
}

export const meSocialAccountsRetrieve = async (
  provider: string,
  uid: string,
  options?: RequestInit,
): Promise<meSocialAccountsRetrieveResponse> => {
  return fetchWithAuth<meSocialAccountsRetrieveResponse>(getMeSocialAccountsRetrieveUrl(provider, uid), {
    ...options,
    method: 'GET',
  })
}

export const getMeSocialAccountsRetrieveQueryKey = (provider: string, uid: string) => {
  return ['me', 'social-accounts', provider, uid] as const
}

export const getMeSocialAccountsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof meSocialAccountsRetrieve>>,
  TError = ErrorDetail,
>(
  provider: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeSocialAccountsRetrieveQueryKey(provider, uid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>> = ({ signal }) =>
    meSocialAccountsRetrieve(provider, uid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(provider && uid), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meSocialAccountsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MeSocialAccountsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>>
export type MeSocialAccountsRetrieveQueryError = ErrorDetail

export function useMeSocialAccountsRetrieve<
  TData = Awaited<ReturnType<typeof meSocialAccountsRetrieve>>,
  TError = ErrorDetail,
>(
  provider: string,
  uid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof meSocialAccountsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMeSocialAccountsRetrieveQueryOptions(provider, uid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Delete a social account provider

 */
export type meSocialAccountsDestroyResponse204 = {
  data: void
  status: 204
}

export type meSocialAccountsDestroyResponse401 = {
  data: ErrorDetail
  status: 401
}

export type meSocialAccountsDestroyResponseComposite =
  | meSocialAccountsDestroyResponse204
  | meSocialAccountsDestroyResponse401

export type meSocialAccountsDestroyResponse = meSocialAccountsDestroyResponseComposite & {
  headers: Headers
}

export const getMeSocialAccountsDestroyUrl = (provider: string, uid: string) => {
  return `/me/social-accounts/${provider}/${uid}/`
}

export const meSocialAccountsDestroy = async (
  provider: string,
  uid: string,
  options?: RequestInit,
): Promise<meSocialAccountsDestroyResponse> => {
  return fetchWithAuth<meSocialAccountsDestroyResponse>(getMeSocialAccountsDestroyUrl(provider, uid), {
    ...options,
    method: 'DELETE',
  })
}

export const getMeSocialAccountsDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
    TError,
    { provider: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
  TError,
  { provider: string; uid: string },
  TContext
> => {
  const mutationKey = ['meSocialAccountsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
    { provider: string; uid: string }
  > = (props) => {
    const { provider, uid } = props ?? {}

    return meSocialAccountsDestroy(provider, uid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MeSocialAccountsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof meSocialAccountsDestroy>>>

export type MeSocialAccountsDestroyMutationError = ErrorDetail

export const useMeSocialAccountsDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meSocialAccountsDestroy>>,
    TError,
    { provider: string; uid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getMeSocialAccountsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
