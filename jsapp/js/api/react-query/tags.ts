/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useQuery } from '@tanstack/react-query'
import type { QueryFunction, QueryKey, UseQueryOptions, UseQueryResult } from '@tanstack/react-query'

import type { ErrorDetail } from '../models/errorDetail'

import type { PaginatedTagListResponseList } from '../models/paginatedTagListResponseList'

import type { TagRetrieveResponse } from '../models/tagRetrieveResponse'

import type { TagsListParams } from '../models/tagsListParams'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List current user's assets' tags

 */
export type tagsListResponse200 = {
  data: PaginatedTagListResponseList
  status: 200
}

export type tagsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type tagsListResponseComposite = tagsListResponse200 | tagsListResponse401

export type tagsListResponse = tagsListResponseComposite & {
  headers: Headers
}

export const getTagsListUrl = (params?: TagsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/tags/?${stringifiedParams}` : `/api/v2/tags/`
}

export const tagsList = async (params?: TagsListParams, options?: RequestInit): Promise<tagsListResponse> => {
  return fetchWithAuth<tagsListResponse>(getTagsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getTagsListQueryKey = (params?: TagsListParams) => {
  return ['api', 'v2', 'tags', ...(params ? [params] : [])] as const
}

export const getTagsListQueryOptions = <TData = Awaited<ReturnType<typeof tagsList>>, TError = ErrorDetail>(
  params?: TagsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTagsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsList>>> = ({ signal }) =>
    tagsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tagsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TagsListQueryResult = NonNullable<Awaited<ReturnType<typeof tagsList>>>
export type TagsListQueryError = ErrorDetail

export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = ErrorDetail>(
  params?: TagsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTagsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a tag's data

 */
export type tagsRetrieveResponse200 = {
  data: TagRetrieveResponse
  status: 200
}

export type tagsRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type tagsRetrieveResponseComposite = tagsRetrieveResponse200 | tagsRetrieveResponse401

export type tagsRetrieveResponse = tagsRetrieveResponseComposite & {
  headers: Headers
}

export const getTagsRetrieveUrl = (taguidUid: string) => {
  return `/api/v2/tags/${taguidUid}/`
}

export const tagsRetrieve = async (taguidUid: string, options?: RequestInit): Promise<tagsRetrieveResponse> => {
  return fetchWithAuth<tagsRetrieveResponse>(getTagsRetrieveUrl(taguidUid), {
    ...options,
    method: 'GET',
  })
}

export const getTagsRetrieveQueryKey = (taguidUid: string) => {
  return ['api', 'v2', 'tags', taguidUid] as const
}

export const getTagsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = ErrorDetail>(
  taguidUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTagsRetrieveQueryKey(taguidUid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsRetrieve>>> = ({ signal }) =>
    tagsRetrieve(taguidUid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!taguidUid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tagsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TagsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof tagsRetrieve>>>
export type TagsRetrieveQueryError = ErrorDetail

export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = ErrorDetail>(
  taguidUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTagsRetrieveQueryOptions(taguidUid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
