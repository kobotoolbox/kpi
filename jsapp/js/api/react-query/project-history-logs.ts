/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { ExportHistoryResponse } from '../models/exportHistoryResponse'

import type { PaginatedProjectHistoryLogResponseList } from '../models/paginatedProjectHistoryLogResponseList'

import type { ProjectHistoryLogsListParams } from '../models/projectHistoryLogsListParams'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List all project history logs for all projects.

‚ö†Ô∏è_Only available to superusers_

Results from this endpoint can be filtered by a Boolean query
specified in the `q` parameter.

**Filterable fields for all project history logs:**

* date_created
* user_uid
* user__username
* user__email
* user__is_superuser
* metadata__source
* metadata__ip_address
* metadata__asset_uid
* metadata__log_subtype
    * available subtypes: "project", "permission"
* action

available actions:

>       add-media
>       add-submission
>       allow-anonymous-submissions
>       archive
>       clone-permissions
>       connect-project
>       delete-media
>       delete-service
>       delete-submission
>       deploy
>       disable-sharing
>       disallow-anonymous-submissions
>       disconnect-project
>       enable-sharing
>       export
>       modify-imported-fields
>       modify-qa-data
>       modify-service
>       modify-sharing
>       modify-submission
>       modify-user-permissions
>       redeploy
>       register-service
>       replace-form
>       share-data-publicly
>       share-form-publicly
>       transfer
>       unarchive
>       unshare-data-publicly
>       unshare-form-publicly
>       update-content
>       update-name
>       update-settings
>       update-qa

**Filterable fields by action:**

* add-media

    a. metadata__asset-file__uid

    b. metadata__asset-file__filename

* add-submission

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

* archive

    a. metadata__latest_version_uid

* clone-permissions

    a. metadata__cloned_from

* connect-project

    a. metadata__paired-data__source_uid

    b. metadata__paired-data__source_name

* delete-media

    a. metadata__asset-file__uid

    b. metadata__asset-file__filename

* delete-service

    a. metadata__hook__uid

    b. metadata__hook__endpoint

    c. metadata__hook__active

* delete-submission

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

* deploy

    a. metadata__latest_version_uid

    b. metadata__latest_deployed_version_uid

* disconnect-project

    a. metadata__paired-data__source_uid

    b. metadata__paired-data__source_name

* modify-imported-fields

    a. metadata__paired-data__source_uid

    b. metadata__paired-data__source_name

* modify-qa-data

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

* modify-service

    a. metadata__hook__uid

    b. metadata__hook__endpoint

    c. metadata__hook__active

* modify-submission

    a. metadata__submission__submitted_by

    b. metadata__submission__root_uuid

    b. metadata__submission__status (only present if changed)

* modify-user-permissions

    a. metadata__permissions__username

* redeploy

    a. metadata__latest_version_uid

    b. metadata__latest_deployed_version_uid

* register-service

    a. metadata__hook__uid

    b. metadata__hook__endpoint

    c. metadata__hook__active

* transfer

    a. metadata__username

* unarchive

    a. metadata__latest_version_uid

* update-name

    a. metadata__name__old

    b. metadata__name__new

* update-settings

    a. metadata__settings__description__old

    b. metadata__settings__description__new

This endpoint can be paginated with 'offset' and 'limit' parameters

 */
export type projectHistoryLogsListResponse200 = {
  data: PaginatedProjectHistoryLogResponseList
  status: 200
}

export type projectHistoryLogsListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectHistoryLogsListResponse404 = {
  data: ErrorObject
  status: 404
}

export type projectHistoryLogsListResponseComposite =
  | projectHistoryLogsListResponse200
  | projectHistoryLogsListResponse403
  | projectHistoryLogsListResponse404

export type projectHistoryLogsListResponse = projectHistoryLogsListResponseComposite & {
  headers: Headers
}

export const getProjectHistoryLogsListUrl = (params?: ProjectHistoryLogsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/project-history-logs/?${stringifiedParams}`
    : `/api/v2/project-history-logs/`
}

export const projectHistoryLogsList = async (
  params?: ProjectHistoryLogsListParams,
  options?: RequestInit,
): Promise<projectHistoryLogsListResponse> => {
  return fetchWithAuth<projectHistoryLogsListResponse>(getProjectHistoryLogsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getProjectHistoryLogsListQueryKey = (params?: ProjectHistoryLogsListParams) => {
  return ['api', 'v2', 'project-history-logs', ...(params ? [params] : [])] as const
}

export const getProjectHistoryLogsListQueryOptions = <
  TData = Awaited<ReturnType<typeof projectHistoryLogsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  params?: ProjectHistoryLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectHistoryLogsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectHistoryLogsList>>> = ({ signal }) =>
    projectHistoryLogsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectHistoryLogsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectHistoryLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof projectHistoryLogsList>>>
export type ProjectHistoryLogsListQueryError = ErrorDetail | ErrorObject

export function useProjectHistoryLogsList<
  TData = Awaited<ReturnType<typeof projectHistoryLogsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  params?: ProjectHistoryLogsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectHistoryLogsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List of Project History Exports

‚ö†Ô∏è _Only available to superusers_

 */
export type projectHistoryLogsExportRetrieveResponse202 = {
  data: ExportHistoryResponse
  status: 202
}

export type projectHistoryLogsExportRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectHistoryLogsExportRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type projectHistoryLogsExportRetrieveResponseComposite =
  | projectHistoryLogsExportRetrieveResponse202
  | projectHistoryLogsExportRetrieveResponse403
  | projectHistoryLogsExportRetrieveResponse404

export type projectHistoryLogsExportRetrieveResponse = projectHistoryLogsExportRetrieveResponseComposite & {
  headers: Headers
}

export const getProjectHistoryLogsExportRetrieveUrl = () => {
  return `/api/v2/project-history-logs/export/`
}

export const projectHistoryLogsExportRetrieve = async (
  options?: RequestInit,
): Promise<projectHistoryLogsExportRetrieveResponse> => {
  return fetchWithAuth<projectHistoryLogsExportRetrieveResponse>(getProjectHistoryLogsExportRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getProjectHistoryLogsExportRetrieveQueryKey = () => {
  return ['api', 'v2', 'project-history-logs', 'export'] as const
}

export const getProjectHistoryLogsExportRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectHistoryLogsExportRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>> = ({ signal }) =>
    projectHistoryLogsExportRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectHistoryLogsExportRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>
>
export type ProjectHistoryLogsExportRetrieveQueryError = ErrorDetail | ErrorObject

export function useProjectHistoryLogsExportRetrieve<
  TData = Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof projectHistoryLogsExportRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectHistoryLogsExportRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export of projects history logs

‚ö†Ô∏è _Only available to superusers_

Export project history logs and send it by email to the requesting user.

 */
export type projectHistoryLogsExportCreateResponse202 = {
  data: ExportHistoryResponse
  status: 202
}

export type projectHistoryLogsExportCreateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectHistoryLogsExportCreateResponse404 = {
  data: ErrorObject
  status: 404
}

export type projectHistoryLogsExportCreateResponseComposite =
  | projectHistoryLogsExportCreateResponse202
  | projectHistoryLogsExportCreateResponse403
  | projectHistoryLogsExportCreateResponse404

export type projectHistoryLogsExportCreateResponse = projectHistoryLogsExportCreateResponseComposite & {
  headers: Headers
}

export const getProjectHistoryLogsExportCreateUrl = () => {
  return `/api/v2/project-history-logs/export/`
}

export const projectHistoryLogsExportCreate = async (
  options?: RequestInit,
): Promise<projectHistoryLogsExportCreateResponse> => {
  return fetchWithAuth<projectHistoryLogsExportCreateResponse>(getProjectHistoryLogsExportCreateUrl(), {
    ...options,
    method: 'POST',
  })
}

export const getProjectHistoryLogsExportCreateMutationOptions = <
  TError = ErrorDetail | ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, TError, void, TContext> => {
  const mutationKey = ['projectHistoryLogsExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, void> = () => {
    return projectHistoryLogsExportCreate(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProjectHistoryLogsExportCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>
>

export type ProjectHistoryLogsExportCreateMutationError = ErrorDetail | ErrorObject

export const useProjectHistoryLogsExportCreate = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof projectHistoryLogsExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getProjectHistoryLogsExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
