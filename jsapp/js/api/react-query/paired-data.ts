/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * Powerful and intuitive data collection tools to make an impact
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { AssetsPairedDataListParams } from '../models/assetsPairedDataListParams'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { ExternalResponse } from '../models/externalResponse'

import type { PaginatedPairedDataResponseList } from '../models/paginatedPairedDataResponseList'

import type { PairedData } from '../models/pairedData'

import type { PairedDataResponse } from '../models/pairedDataResponse'

import type { PatchedPairedDataPatchPayload } from '../models/patchedPairedDataPatchPayload'

import { fetchWithAuth } from '../orval.mutator'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
    }
  : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List paired project endpoints

This endpoint is paginated and accepts these parameters:
- `offset`: The initial index from which to return the results
- `limit`: Number of results to return per page

 */
export type assetsPairedDataListResponse200 = {
  data: PaginatedPairedDataResponseList
  status: 200
}

export type assetsPairedDataListResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsPairedDataListResponseComposite = assetsPairedDataListResponse200 | assetsPairedDataListResponse404

export type assetsPairedDataListResponse = assetsPairedDataListResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataListUrl = (parentLookupAsset: string, params?: AssetsPairedDataListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${parentLookupAsset}/paired-data/?${stringifiedParams}`
    : `/api/v2/assets/${parentLookupAsset}/paired-data/`
}

export const assetsPairedDataList = async (
  parentLookupAsset: string,
  params?: AssetsPairedDataListParams,
  options?: RequestInit,
): Promise<assetsPairedDataListResponse> => {
  return fetchWithAuth<assetsPairedDataListResponse>(getAssetsPairedDataListUrl(parentLookupAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsPairedDataListQueryKey = (parentLookupAsset: string, params?: AssetsPairedDataListParams) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'paired-data', ...(params ? [params] : [])] as const
}

export const getAssetsPairedDataListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsPairedDataList>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  params?: AssetsPairedDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsPairedDataListQueryKey(parentLookupAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsPairedDataList>>> = ({ signal }) =>
    assetsPairedDataList(parentLookupAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!parentLookupAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsPairedDataList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsPairedDataListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataList>>>
export type AssetsPairedDataListQueryError = ErrorDetail

export function useAssetsPairedDataList<TData = Awaited<ReturnType<typeof assetsPairedDataList>>, TError = ErrorDetail>(
  parentLookupAsset: string,
  params?: AssetsPairedDataListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsPairedDataListQueryOptions(parentLookupAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create a connection between two projects

* `fields`: Optional. List of questions whose responses will be retrieved
        from the source data. If missing or empty, all responses will be
        retrieved. Questions must be identified by full group path separated by
        slashes, e.g. `group/subgroup/question_name`.
* `filename`: Must be unique among all asset files. Only accepts letters, numbers and '-'.

 */
export type assetsPairedDataCreateResponse201 = {
  data: PairedDataResponse
  status: 201
}

export type assetsPairedDataCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsPairedDataCreateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsPairedDataCreateResponseComposite =
  | assetsPairedDataCreateResponse201
  | assetsPairedDataCreateResponse400
  | assetsPairedDataCreateResponse404

export type assetsPairedDataCreateResponse = assetsPairedDataCreateResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataCreateUrl = (parentLookupAsset: string) => {
  return `/api/v2/assets/${parentLookupAsset}/paired-data/`
}

export const assetsPairedDataCreate = async (
  parentLookupAsset: string,
  pairedData: NonReadonly<PairedData>,
  options?: RequestInit,
): Promise<assetsPairedDataCreateResponse> => {
  return fetchWithAuth<assetsPairedDataCreateResponse>(getAssetsPairedDataCreateUrl(parentLookupAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(pairedData),
  })
}

export const getAssetsPairedDataCreateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataCreate>>,
    TError,
    { parentLookupAsset: string; data: NonReadonly<PairedData> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPairedDataCreate>>,
  TError,
  { parentLookupAsset: string; data: NonReadonly<PairedData> },
  TContext
> => {
  const mutationKey = ['assetsPairedDataCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPairedDataCreate>>,
    { parentLookupAsset: string; data: NonReadonly<PairedData> }
  > = (props) => {
    const { parentLookupAsset, data } = props ?? {}

    return assetsPairedDataCreate(parentLookupAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPairedDataCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataCreate>>>
export type AssetsPairedDataCreateMutationBody = NonReadonly<PairedData>
export type AssetsPairedDataCreateMutationError = ErrorObject | ErrorDetail

export const useAssetsPairedDataCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataCreate>>,
    TError,
    { parentLookupAsset: string; data: NonReadonly<PairedData> },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPairedDataCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve a connection between two projects

 */
export type assetsPairedDataRetrieveResponse200 = {
  data: PairedDataResponse
  status: 200
}

export type assetsPairedDataRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsPairedDataRetrieveResponseComposite =
  | assetsPairedDataRetrieveResponse200
  | assetsPairedDataRetrieveResponse404

export type assetsPairedDataRetrieveResponse = assetsPairedDataRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataRetrieveUrl = (parentLookupAsset: string, pairedDataUid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/paired-data/${pairedDataUid}/`
}

export const assetsPairedDataRetrieve = async (
  parentLookupAsset: string,
  pairedDataUid: string,
  options?: RequestInit,
): Promise<assetsPairedDataRetrieveResponse> => {
  return fetchWithAuth<assetsPairedDataRetrieveResponse>(
    getAssetsPairedDataRetrieveUrl(parentLookupAsset, pairedDataUid),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsPairedDataRetrieveQueryKey = (parentLookupAsset: string, pairedDataUid: string) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'paired-data', pairedDataUid] as const
}

export const getAssetsPairedDataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsPairedDataRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  pairedDataUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsPairedDataRetrieveQueryKey(parentLookupAsset, pairedDataUid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>> = ({ signal }) =>
    assetsPairedDataRetrieve(parentLookupAsset, pairedDataUid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && pairedDataUid), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsPairedDataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsPairedDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>>
export type AssetsPairedDataRetrieveQueryError = ErrorDetail

export function useAssetsPairedDataRetrieve<
  TData = Awaited<ReturnType<typeof assetsPairedDataRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  pairedDataUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsPairedDataRetrieveQueryOptions(parentLookupAsset, pairedDataUid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update a connection between two projects

_Notes: `source` cannot be changed_

 */
export type assetsPairedDataPartialUpdateResponse200 = {
  data: PairedDataResponse
  status: 200
}

export type assetsPairedDataPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsPairedDataPartialUpdateResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsPairedDataPartialUpdateResponseComposite =
  | assetsPairedDataPartialUpdateResponse200
  | assetsPairedDataPartialUpdateResponse400
  | assetsPairedDataPartialUpdateResponse404

export type assetsPairedDataPartialUpdateResponse = assetsPairedDataPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataPartialUpdateUrl = (parentLookupAsset: string, pairedDataUid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/paired-data/${pairedDataUid}/`
}

export const assetsPairedDataPartialUpdate = async (
  parentLookupAsset: string,
  pairedDataUid: string,
  patchedPairedDataPatchPayload: PatchedPairedDataPatchPayload,
  options?: RequestInit,
): Promise<assetsPairedDataPartialUpdateResponse> => {
  return fetchWithAuth<assetsPairedDataPartialUpdateResponse>(
    getAssetsPairedDataPartialUpdateUrl(parentLookupAsset, pairedDataUid),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedPairedDataPatchPayload),
    },
  )
}

export const getAssetsPairedDataPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
    TError,
    { parentLookupAsset: string; pairedDataUid: string; data: PatchedPairedDataPatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
  TError,
  { parentLookupAsset: string; pairedDataUid: string; data: PatchedPairedDataPatchPayload },
  TContext
> => {
  const mutationKey = ['assetsPairedDataPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
    { parentLookupAsset: string; pairedDataUid: string; data: PatchedPairedDataPatchPayload }
  > = (props) => {
    const { parentLookupAsset, pairedDataUid, data } = props ?? {}

    return assetsPairedDataPartialUpdate(parentLookupAsset, pairedDataUid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPairedDataPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>
>
export type AssetsPairedDataPartialUpdateMutationBody = PatchedPairedDataPatchPayload
export type AssetsPairedDataPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useAssetsPairedDataPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataPartialUpdate>>,
    TError,
    { parentLookupAsset: string; pairedDataUid: string; data: PatchedPairedDataPatchPayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPairedDataPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Remove a connection between two projects

 */
export type assetsPairedDataDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsPairedDataDestroyResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsPairedDataDestroyResponseComposite =
  | assetsPairedDataDestroyResponse204
  | assetsPairedDataDestroyResponse404

export type assetsPairedDataDestroyResponse = assetsPairedDataDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataDestroyUrl = (parentLookupAsset: string, pairedDataUid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/paired-data/${pairedDataUid}/`
}

export const assetsPairedDataDestroy = async (
  parentLookupAsset: string,
  pairedDataUid: string,
  options?: RequestInit,
): Promise<assetsPairedDataDestroyResponse> => {
  return fetchWithAuth<assetsPairedDataDestroyResponse>(
    getAssetsPairedDataDestroyUrl(parentLookupAsset, pairedDataUid),
    {
      ...options,
      method: 'DELETE',
    },
  )
}

export const getAssetsPairedDataDestroyMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
    TError,
    { parentLookupAsset: string; pairedDataUid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
  TError,
  { parentLookupAsset: string; pairedDataUid: string },
  TContext
> => {
  const mutationKey = ['assetsPairedDataDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
    { parentLookupAsset: string; pairedDataUid: string }
  > = (props) => {
    const { parentLookupAsset, pairedDataUid } = props ?? {}

    return assetsPairedDataDestroy(parentLookupAsset, pairedDataUid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPairedDataDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsPairedDataDestroy>>>

export type AssetsPairedDataDestroyMutationError = ErrorDetail

export const useAssetsPairedDataDestroy = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPairedDataDestroy>>,
    TError,
    { parentLookupAsset: string; pairedDataUid: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPairedDataDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Return an XML which contains data submitted to paired asset

Creates the endpoints
- /api/v2/assets/<parent_lookup_asset>/paired-data/<paired_data_uid>/external/
- /api/v2/assets/<parent_lookup_asset>/paired-data/<paired_data_uid>/external.xml/

 */
export type assetsPairedDataExternalRetrieveResponse200 = {
  data: ExternalResponse
  status: 200
}

export type assetsPairedDataExternalRetrieveResponse404 = {
  data: ErrorDetail
  status: 404
}

export type assetsPairedDataExternalRetrieveResponseComposite =
  | assetsPairedDataExternalRetrieveResponse200
  | assetsPairedDataExternalRetrieveResponse404

export type assetsPairedDataExternalRetrieveResponse = assetsPairedDataExternalRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsPairedDataExternalRetrieveUrl = (parentLookupAsset: string, pairedDataUid: string) => {
  return `/api/v2/assets/${parentLookupAsset}/paired-data/${pairedDataUid}/external/`
}

export const assetsPairedDataExternalRetrieve = async (
  parentLookupAsset: string,
  pairedDataUid: string,
  options?: RequestInit,
): Promise<assetsPairedDataExternalRetrieveResponse> => {
  return fetchWithAuth<assetsPairedDataExternalRetrieveResponse>(
    getAssetsPairedDataExternalRetrieveUrl(parentLookupAsset, pairedDataUid),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getAssetsPairedDataExternalRetrieveQueryKey = (parentLookupAsset: string, pairedDataUid: string) => {
  return ['api', 'v2', 'assets', parentLookupAsset, 'paired-data', pairedDataUid, 'external'] as const
}

export const getAssetsPairedDataExternalRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  pairedDataUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAssetsPairedDataExternalRetrieveQueryKey(parentLookupAsset, pairedDataUid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>> = ({ signal }) =>
    assetsPairedDataExternalRetrieve(parentLookupAsset, pairedDataUid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(parentLookupAsset && pairedDataUid), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsPairedDataExternalRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>
>
export type AssetsPairedDataExternalRetrieveQueryError = ErrorDetail

export function useAssetsPairedDataExternalRetrieve<
  TData = Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>,
  TError = ErrorDetail,
>(
  parentLookupAsset: string,
  pairedDataUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsPairedDataExternalRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsPairedDataExternalRetrieveQueryOptions(parentLookupAsset, pairedDataUid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
