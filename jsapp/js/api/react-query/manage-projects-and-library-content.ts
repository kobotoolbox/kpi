/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox API
 * This page documents all KoboToolbox API endpoints.

The endpoints are grouped by area of intended use. Each category contains related endpoints, with detailed documentation on usage and configuration. Use this as a reference to quickly find the right endpoint for managing projects, forms, data, permissions, integrations, logs, and organizational resources.

**General note**: All projects (whether deployed or draft), as well as all library content (questions, blocks, templates, and collections) in the user-facing application are represented in the API as assets.
 * OpenAPI spec version: 2.0.0 (api_v2)
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type { Asset } from '../models/asset'

import type { AssetBulkRequest } from '../models/assetBulkRequest'

import type { AssetBulkResponse } from '../models/assetBulkResponse'

import type { AssetCreateRequest } from '../models/assetCreateRequest'

import type { AssetMetadataResponse } from '../models/assetMetadataResponse'

import type { AssetsCountsListParams } from '../models/assetsCountsListParams'

import type { AssetsListParams } from '../models/assetsListParams'

import type { AssetsRetrieveParams } from '../models/assetsRetrieveParams'

import type { AssetsVersionsListParams } from '../models/assetsVersionsListParams'

import type { DeploymentCreateRequest } from '../models/deploymentCreateRequest'

import type { DeploymentResponse } from '../models/deploymentResponse'

import type { ErrorDetail } from '../models/errorDetail'

import type { ErrorObject } from '../models/errorObject'

import type { HashResponse } from '../models/hashResponse'

import type { ImportCreateRequest } from '../models/importCreateRequest'

import type { ImportCreateResponse } from '../models/importCreateResponse'

import type { ImportResponse } from '../models/importResponse'

import type { ImportsListParams } from '../models/importsListParams'

import type { PaginatedAssetCountResponseList } from '../models/paginatedAssetCountResponseList'

import type { PaginatedAssetList } from '../models/paginatedAssetList'

import type { PaginatedImportResponseList } from '../models/paginatedImportResponseList'

import type { PaginatedProjectInviteResponseList } from '../models/paginatedProjectInviteResponseList'

import type { PaginatedTagListResponseList } from '../models/paginatedTagListResponseList'

import type { PaginatedVersionListResponseList } from '../models/paginatedVersionListResponseList'

import type { PatchedAssetPatchRequest } from '../models/patchedAssetPatchRequest'

import type { PatchedDeploymentPatchRequest } from '../models/patchedDeploymentPatchRequest'

import type { PatchedInviteUpdatePayload } from '../models/patchedInviteUpdatePayload'

import type { ProjectInviteCreatePayload } from '../models/projectInviteCreatePayload'

import type { ProjectInviteResponse } from '../models/projectInviteResponse'

import type { ProjectOwnershipInvitesListParams } from '../models/projectOwnershipInvitesListParams'

import type { TagRetrieveResponse } from '../models/tagRetrieveResponse'

import type { TagsListParams } from '../models/tagsListParams'

import type { TransferListResponse } from '../models/transferListResponse'

import type { VersionRetrieveResponse } from '../models/versionRetrieveResponse'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## Get user's assets


Search can be made with `q` parameter.
Search filters can be returned with results by passing `metadata=on` to querystring.


Results can be sorted with `ordering` parameter, e.g.:

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/?ordering=-name
```


Allowed fields are:

- `asset_type`
- `date_modified`
- `date_deployed`
- `date_modified__date`
- `date_deployed__date`
- `name`
- `settings__sector`
- `settings__sector__value`
- `settings__description`
- `owner__username`
- `owner__extra_details__data__name`
- `owner__extra_details__data__organization`
- `owner__email`
- `_deployment_status`
- `subscribers_count`


Note: Collections can be displayed first with parameter `collections_first`, e.g.:

```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/?collections_first=true&ordering=-name
```

 */
export type assetsListResponse200 = {
  data: PaginatedAssetList
  status: 200
}

export type assetsListResponseComposite = assetsListResponse200

export type assetsListResponse = assetsListResponseComposite & {
  headers: Headers
}

export const getAssetsListUrl = (params?: AssetsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/assets/?${stringifiedParams}` : `/api/v2/assets/`
}

export const assetsList = async (params?: AssetsListParams, options?: RequestInit): Promise<assetsListResponse> => {
  return fetchWithAuth<assetsListResponse>(getAssetsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsListQueryKey = (params?: AssetsListParams) => {
  return ['api', 'v2', 'assets', ...(params ? [params] : [])] as const
}

export const getAssetsListQueryOptions = <TData = Awaited<ReturnType<typeof assetsList>>, TError = unknown>(
  params?: AssetsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsList>>> = ({ signal }) =>
    assetsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsList>>>
export type AssetsListQueryError = unknown

export function useAssetsList<TData = Awaited<ReturnType<typeof assetsList>>, TError = unknown>(
  params?: AssetsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create or clone an asset

When cloning an asset, you must provide:

- the name (as a string),
- the `clone_from` (the uid representing the asset),
- the asset_type

Where `asset_type` must be one of these values:

* block (can be cloned to `block`, `question`, `survey`, `template`)
* question (can be cloned to `question`, `survey`, `template`)
* survey (can be cloned to `block`, `question`, `survey`, `template`)
* template (can be cloned to `survey`, `template`)

Settings are cloned only when type of assets are `survey` or `template`.
In that case, `share-metadata` is not preserved.

When creating a new `block` or `question` asset, settings are not saved either.

 */
export type assetsCreateResponse201 = {
  data: Asset
  status: 201
}

export type assetsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsCreateResponseComposite = assetsCreateResponse201 | assetsCreateResponse400 | assetsCreateResponse401

export type assetsCreateResponse = assetsCreateResponseComposite & {
  headers: Headers
}

export const getAssetsCreateUrl = () => {
  return `/api/v2/assets/`
}

export const assetsCreate = async (
  assetCreateRequest: AssetCreateRequest,
  options?: RequestInit,
): Promise<assetsCreateResponse> => {
  return fetchWithAuth<assetsCreateResponse>(getAssetsCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(assetCreateRequest),
  })
}

export const getAssetsCreateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsCreate>>,
    TError,
    { data: AssetCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof assetsCreate>>, TError, { data: AssetCreateRequest }, TContext> => {
  const mutationKey = ['assetsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsCreate>>, { data: AssetCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return assetsCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsCreate>>>
export type AssetsCreateMutationBody = AssetCreateRequest
export type AssetsCreateMutationError = ErrorObject | ErrorDetail

export const useAssetsCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsCreate>>,
    TError,
    { data: AssetCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Get a user's current asset

 */
export type assetsRetrieveResponse200 = {
  data: Asset
  status: 200
}

export type assetsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsRetrieveResponseComposite = assetsRetrieveResponse200 | assetsRetrieveResponse404

export type assetsRetrieveResponse = assetsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsRetrieveUrl = (uidAsset: string, params?: AssetsRetrieveParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/`
}

export const assetsRetrieve = async (
  uidAsset: string,
  params?: AssetsRetrieveParams,
  options?: RequestInit,
): Promise<assetsRetrieveResponse> => {
  return fetchWithAuth<assetsRetrieveResponse>(getAssetsRetrieveUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsRetrieveQueryKey = (uidAsset: string, params?: AssetsRetrieveParams) => {
  return ['api', 'v2', 'assets', uidAsset, ...(params ? [params] : [])] as const
}

export const getAssetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof assetsRetrieve>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsRetrieveQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsRetrieve>>> = ({ signal }) =>
    assetsRetrieve(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsRetrieve>>>
export type AssetsRetrieveQueryError = ErrorObject

export function useAssetsRetrieve<TData = Awaited<ReturnType<typeof assetsRetrieve>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsRetrieveParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsRetrieveQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update or connect a user's asset

Updates a project or connect project's data from this project to other projects

When `Data sharing`:

`fields`: Optional. List of questions whose responses will be shared. If
missing or empty, all responses will be shared. Questions must be
identified by full group path separated by slashes, e.g.
`group/subgroup/question_name`.

 */
export type assetsPartialUpdateResponse200 = {
  data: Asset
  status: 200
}

export type assetsPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsPartialUpdateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsPartialUpdateResponseComposite =
  | assetsPartialUpdateResponse200
  | assetsPartialUpdateResponse400
  | assetsPartialUpdateResponse401

export type assetsPartialUpdateResponse = assetsPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsPartialUpdateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/`
}

export const assetsPartialUpdate = async (
  uidAsset: string,
  patchedAssetPatchRequest: PatchedAssetPatchRequest,
  options?: RequestInit,
): Promise<assetsPartialUpdateResponse> => {
  return fetchWithAuth<assetsPartialUpdateResponse>(getAssetsPartialUpdateUrl(uidAsset), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedAssetPatchRequest),
  })
}

export const getAssetsPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedAssetPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsPartialUpdate>>,
  TError,
  { uidAsset: string; data: PatchedAssetPatchRequest },
  TContext
> => {
  const mutationKey = ['assetsPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsPartialUpdate>>,
    { uidAsset: string; data: PatchedAssetPatchRequest }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsPartialUpdate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsPartialUpdate>>>
export type AssetsPartialUpdateMutationBody = PatchedAssetPatchRequest
export type AssetsPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useAssetsPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedAssetPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete a user's asset

 */
export type assetsDestroyResponse204 = {
  data: void
  status: 204
}

export type assetsDestroyResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDestroyResponseComposite =
  | assetsDestroyResponse204
  | assetsDestroyResponse401
  | assetsDestroyResponse404

export type assetsDestroyResponse = assetsDestroyResponseComposite & {
  headers: Headers
}

export const getAssetsDestroyUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/`
}

export const assetsDestroy = async (uidAsset: string, options?: RequestInit): Promise<assetsDestroyResponse> => {
  return fetchWithAuth<assetsDestroyResponse>(getAssetsDestroyUrl(uidAsset), {
    ...options,
    method: 'DELETE',
  })
}

export const getAssetsDestroyMutationOptions = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof assetsDestroy>>, TError, { uidAsset: string }, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof assetsDestroy>>, TError, { uidAsset: string }, TContext> => {
  const mutationKey = ['assetsDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsDestroy>>, { uidAsset: string }> = (props) => {
    const { uidAsset } = props ?? {}

    return assetsDestroy(uidAsset, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDestroy>>>

export type AssetsDestroyMutationError = ErrorDetail | ErrorObject

export const useAssetsDestroy = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof assetsDestroy>>, TError, { uidAsset: string }, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Count the daily amount of submission

Returns up to the last 31 days of daily counts and total counts of submissions to a survey.


Use the `days` query to get the daily counts from the last x amount of days.
Default amount is 30 days


```shell
curl -X GET https://kf.kobotoolbox.org/api/v2/assets/aSAvYreNzVEkrWg5Gdcvg/counts/?days=7
```

 */
export type assetsCountsListResponse200 = {
  data: PaginatedAssetCountResponseList
  status: 200
}

export type assetsCountsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsCountsListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsCountsListResponseComposite =
  | assetsCountsListResponse200
  | assetsCountsListResponse401
  | assetsCountsListResponse404

export type assetsCountsListResponse = assetsCountsListResponseComposite & {
  headers: Headers
}

export const getAssetsCountsListUrl = (uidAsset: string, params?: AssetsCountsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/counts/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/counts/`
}

export const assetsCountsList = async (
  uidAsset: string,
  params?: AssetsCountsListParams,
  options?: RequestInit,
): Promise<assetsCountsListResponse> => {
  return fetchWithAuth<assetsCountsListResponse>(getAssetsCountsListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsCountsListQueryKey = (uidAsset: string, params?: AssetsCountsListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'counts', ...(params ? [params] : [])] as const
}

export const getAssetsCountsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsCountsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  params?: AssetsCountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsCountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsCountsListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsCountsList>>> = ({ signal }) =>
    assetsCountsList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsCountsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsCountsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsCountsList>>>
export type AssetsCountsListQueryError = ErrorDetail | ErrorObject

export function useAssetsCountsList<
  TData = Awaited<ReturnType<typeof assetsCountsList>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidAsset: string,
  params?: AssetsCountsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsCountsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsCountsListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve the existing deployment (if any)

 */
export type assetsDeploymentRetrieveResponse200 = {
  data: DeploymentResponse
  status: 200
}

export type assetsDeploymentRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsDeploymentRetrieveResponseComposite =
  | assetsDeploymentRetrieveResponse200
  | assetsDeploymentRetrieveResponse404

export type assetsDeploymentRetrieveResponse = assetsDeploymentRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsDeploymentRetrieveUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/deployment/`
}

export const assetsDeploymentRetrieve = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsDeploymentRetrieveResponse> => {
  return fetchWithAuth<assetsDeploymentRetrieveResponse>(getAssetsDeploymentRetrieveUrl(uidAsset), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsDeploymentRetrieveQueryKey = (uidAsset: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'deployment'] as const
}

export const getAssetsDeploymentRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsDeploymentRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDeploymentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsDeploymentRetrieveQueryKey(uidAsset)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsDeploymentRetrieve>>> = ({ signal }) =>
    assetsDeploymentRetrieve(uidAsset, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsDeploymentRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsDeploymentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsDeploymentRetrieve>>>
export type AssetsDeploymentRetrieveQueryError = ErrorObject

export function useAssetsDeploymentRetrieve<
  TData = Awaited<ReturnType<typeof assetsDeploymentRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsDeploymentRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsDeploymentRetrieveQueryOptions(uidAsset, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## (Re)Deploy a form

Deploy a new form or re-deploy an existing one.

 */
export type assetsDeploymentCreateResponse200 = {
  data: DeploymentResponse
  status: 200
}

export type assetsDeploymentCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsDeploymentCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsDeploymentCreateResponseComposite =
  | assetsDeploymentCreateResponse200
  | assetsDeploymentCreateResponse400
  | assetsDeploymentCreateResponse401

export type assetsDeploymentCreateResponse = assetsDeploymentCreateResponseComposite & {
  headers: Headers
}

export const getAssetsDeploymentCreateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/deployment/`
}

export const assetsDeploymentCreate = async (
  uidAsset: string,
  deploymentCreateRequest: DeploymentCreateRequest,
  options?: RequestInit,
): Promise<assetsDeploymentCreateResponse> => {
  return fetchWithAuth<assetsDeploymentCreateResponse>(getAssetsDeploymentCreateUrl(uidAsset), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deploymentCreateRequest),
  })
}

export const getAssetsDeploymentCreateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDeploymentCreate>>,
    TError,
    { uidAsset: string; data: DeploymentCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDeploymentCreate>>,
  TError,
  { uidAsset: string; data: DeploymentCreateRequest },
  TContext
> => {
  const mutationKey = ['assetsDeploymentCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDeploymentCreate>>,
    { uidAsset: string; data: DeploymentCreateRequest }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsDeploymentCreate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDeploymentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsDeploymentCreate>>>
export type AssetsDeploymentCreateMutationBody = DeploymentCreateRequest
export type AssetsDeploymentCreateMutationError = ErrorObject | ErrorDetail

export const useAssetsDeploymentCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDeploymentCreate>>,
    TError,
    { uidAsset: string; data: DeploymentCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDeploymentCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## (Un)Archive the existing deployment.

Update the `active` field of the existing deployment.

To overwrite the entire deployment (including the form contents), use a PUT request.

 */
export type assetsDeploymentPartialUpdateResponse200 = {
  data: DeploymentResponse
  status: 200
}

export type assetsDeploymentPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type assetsDeploymentPartialUpdateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsDeploymentPartialUpdateResponseComposite =
  | assetsDeploymentPartialUpdateResponse200
  | assetsDeploymentPartialUpdateResponse400
  | assetsDeploymentPartialUpdateResponse401

export type assetsDeploymentPartialUpdateResponse = assetsDeploymentPartialUpdateResponseComposite & {
  headers: Headers
}

export const getAssetsDeploymentPartialUpdateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/deployment/`
}

export const assetsDeploymentPartialUpdate = async (
  uidAsset: string,
  patchedDeploymentPatchRequest: PatchedDeploymentPatchRequest,
  options?: RequestInit,
): Promise<assetsDeploymentPartialUpdateResponse> => {
  return fetchWithAuth<assetsDeploymentPartialUpdateResponse>(getAssetsDeploymentPartialUpdateUrl(uidAsset), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchedDeploymentPatchRequest),
  })
}

export const getAssetsDeploymentPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDeploymentPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedDeploymentPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsDeploymentPartialUpdate>>,
  TError,
  { uidAsset: string; data: PatchedDeploymentPatchRequest },
  TContext
> => {
  const mutationKey = ['assetsDeploymentPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsDeploymentPartialUpdate>>,
    { uidAsset: string; data: PatchedDeploymentPatchRequest }
  > = (props) => {
    const { uidAsset, data } = props ?? {}

    return assetsDeploymentPartialUpdate(uidAsset, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsDeploymentPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsDeploymentPartialUpdate>>
>
export type AssetsDeploymentPartialUpdateMutationBody = PatchedDeploymentPatchRequest
export type AssetsDeploymentPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useAssetsDeploymentPartialUpdate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsDeploymentPartialUpdate>>,
    TError,
    { uidAsset: string; data: PatchedDeploymentPatchRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsDeploymentPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List the versions of forms

 */
export type assetsVersionsListResponse200 = {
  data: PaginatedVersionListResponseList
  status: 200
}

export type assetsVersionsListResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsVersionsListResponseComposite = assetsVersionsListResponse200 | assetsVersionsListResponse404

export type assetsVersionsListResponse = assetsVersionsListResponseComposite & {
  headers: Headers
}

export const getAssetsVersionsListUrl = (uidAsset: string, params?: AssetsVersionsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/versions/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/versions/`
}

export const assetsVersionsList = async (
  uidAsset: string,
  params?: AssetsVersionsListParams,
  options?: RequestInit,
): Promise<assetsVersionsListResponse> => {
  return fetchWithAuth<assetsVersionsListResponse>(getAssetsVersionsListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsVersionsListQueryKey = (uidAsset: string, params?: AssetsVersionsListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'versions', ...(params ? [params] : [])] as const
}

export const getAssetsVersionsListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsVersionsList>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  params?: AssetsVersionsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsVersionsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsVersionsListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsVersionsList>>> = ({ signal }) =>
    assetsVersionsList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsVersionsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsVersionsListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsVersionsList>>>
export type AssetsVersionsListQueryError = ErrorObject

export function useAssetsVersionsList<TData = Awaited<ReturnType<typeof assetsVersionsList>>, TError = ErrorObject>(
  uidAsset: string,
  params?: AssetsVersionsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsVersionsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsVersionsListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve asset versions

Returns the details of an asset version

 */
export type assetsVersionsRetrieveResponse200 = {
  data: VersionRetrieveResponse
  status: 200
}

export type assetsVersionsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsVersionsRetrieveResponseComposite =
  | assetsVersionsRetrieveResponse200
  | assetsVersionsRetrieveResponse404

export type assetsVersionsRetrieveResponse = assetsVersionsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsVersionsRetrieveUrl = (uidAsset: string, uidVersion: string) => {
  return `/api/v2/assets/${uidAsset}/versions/${uidVersion}/`
}

export const assetsVersionsRetrieve = async (
  uidAsset: string,
  uidVersion: string,
  options?: RequestInit,
): Promise<assetsVersionsRetrieveResponse> => {
  return fetchWithAuth<assetsVersionsRetrieveResponse>(getAssetsVersionsRetrieveUrl(uidAsset, uidVersion), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsVersionsRetrieveQueryKey = (uidAsset: string, uidVersion: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'versions', uidVersion] as const
}

export const getAssetsVersionsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsVersionsRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidVersion: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsVersionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsVersionsRetrieveQueryKey(uidAsset, uidVersion)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsVersionsRetrieve>>> = ({ signal }) =>
    assetsVersionsRetrieve(uidAsset, uidVersion, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidAsset && uidVersion), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsVersionsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsVersionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsVersionsRetrieve>>>
export type AssetsVersionsRetrieveQueryError = ErrorObject

export function useAssetsVersionsRetrieve<
  TData = Awaited<ReturnType<typeof assetsVersionsRetrieve>>,
  TError = ErrorObject,
>(
  uidAsset: string,
  uidVersion: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsVersionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsVersionsRetrieveQueryOptions(uidAsset, uidVersion, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## This route will render the XForm into syntax-highlighted HTML.

It is useful for debugging pyxform transformations

 */
export type assetsXformRetrieveResponse200 = {
  data: string
  status: 200
}

export type assetsXformRetrieveResponse404 = {
  data: void
  status: 404
}

export type assetsXformRetrieveResponseComposite = assetsXformRetrieveResponse200 | assetsXformRetrieveResponse404

export type assetsXformRetrieveResponse = assetsXformRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsXformRetrieveUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/xform/`
}

export const assetsXformRetrieve = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsXformRetrieveResponse> => {
  return fetchWithAuth<assetsXformRetrieveResponse>(getAssetsXformRetrieveUrl(uidAsset), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsXformRetrieveQueryKey = (uidAsset: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'xform'] as const
}

export const getAssetsXformRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsXformRetrieve>>,
  TError = void,
>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsXformRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsXformRetrieveQueryKey(uidAsset)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsXformRetrieve>>> = ({ signal }) =>
    assetsXformRetrieve(uidAsset, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsXformRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsXformRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsXformRetrieve>>>
export type AssetsXformRetrieveQueryError = void

export function useAssetsXformRetrieve<TData = Awaited<ReturnType<typeof assetsXformRetrieve>>, TError = void>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsXformRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsXformRetrieveQueryOptions(uidAsset, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Perform bulk actions on assets

Actions available:

- `archive`
- `delete`
- `unarchive`
- `undelete` (superusers only)

 */
export type assetsBulkCreateResponse200 = {
  data: AssetBulkResponse
  status: 200
}

export type assetsBulkCreateResponse404 = {
  data: ErrorObject
  status: 404
}

export type assetsBulkCreateResponseComposite = assetsBulkCreateResponse200 | assetsBulkCreateResponse404

export type assetsBulkCreateResponse = assetsBulkCreateResponseComposite & {
  headers: Headers
}

export const getAssetsBulkCreateUrl = () => {
  return `/api/v2/assets/bulk/`
}

export const assetsBulkCreate = async (
  assetBulkRequest: AssetBulkRequest,
  options?: RequestInit,
): Promise<assetsBulkCreateResponse> => {
  return fetchWithAuth<assetsBulkCreateResponse>(getAssetsBulkCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(assetBulkRequest),
  })
}

export const getAssetsBulkCreateMutationOptions = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsBulkCreate>>,
    TError,
    { data: AssetBulkRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof assetsBulkCreate>>, TError, { data: AssetBulkRequest }, TContext> => {
  const mutationKey = ['assetsBulkCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsBulkCreate>>, { data: AssetBulkRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return assetsBulkCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsBulkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsBulkCreate>>>
export type AssetsBulkCreateMutationBody = AssetBulkRequest
export type AssetsBulkCreateMutationError = ErrorObject

export const useAssetsBulkCreate = <TError = ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsBulkCreate>>,
    TError,
    { data: AssetBulkRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsBulkCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Get a hash of all `version_id`s of all accessible assets by the current user.

Useful to detect any changes in assets with only one call to `API`

 */
export type assetsHashRetrieveResponse200 = {
  data: HashResponse
  status: 200
}

export type assetsHashRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type assetsHashRetrieveResponseComposite = assetsHashRetrieveResponse200 | assetsHashRetrieveResponse401

export type assetsHashRetrieveResponse = assetsHashRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsHashRetrieveUrl = () => {
  return `/api/v2/assets/hash/`
}

export const assetsHashRetrieve = async (options?: RequestInit): Promise<assetsHashRetrieveResponse> => {
  return fetchWithAuth<assetsHashRetrieveResponse>(getAssetsHashRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHashRetrieveQueryKey = () => {
  return ['api', 'v2', 'assets', 'hash'] as const
}

export const getAssetsHashRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHashRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHashRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHashRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHashRetrieve>>> = ({ signal }) =>
    assetsHashRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHashRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHashRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHashRetrieve>>>
export type AssetsHashRetrieveQueryError = ErrorDetail

export function useAssetsHashRetrieve<
  TData = Awaited<ReturnType<typeof assetsHashRetrieve>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHashRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHashRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Get metadata for all authenticated user' assets

 */
export type assetsMetadataRetrieveResponse200 = {
  data: AssetMetadataResponse
  status: 200
}

export type assetsMetadataRetrieveResponseComposite = assetsMetadataRetrieveResponse200

export type assetsMetadataRetrieveResponse = assetsMetadataRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsMetadataRetrieveUrl = () => {
  return `/api/v2/assets/metadata/`
}

export const assetsMetadataRetrieve = async (options?: RequestInit): Promise<assetsMetadataRetrieveResponse> => {
  return fetchWithAuth<assetsMetadataRetrieveResponse>(getAssetsMetadataRetrieveUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsMetadataRetrieveQueryKey = () => {
  return ['api', 'v2', 'assets', 'metadata'] as const
}

export const getAssetsMetadataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsMetadataRetrieve>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsMetadataRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsMetadataRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsMetadataRetrieve>>> = ({ signal }) =>
    assetsMetadataRetrieve({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsMetadataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsMetadataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof assetsMetadataRetrieve>>>
export type AssetsMetadataRetrieveQueryError = unknown

export function useAssetsMetadataRetrieve<
  TData = Awaited<ReturnType<typeof assetsMetadataRetrieve>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof assetsMetadataRetrieve>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsMetadataRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List imported files

 */
export type importsListResponse200 = {
  data: PaginatedImportResponseList
  status: 200
}

export type importsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type importsListResponseComposite = importsListResponse200 | importsListResponse401

export type importsListResponse = importsListResponseComposite & {
  headers: Headers
}

export const getImportsListUrl = (params?: ImportsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/imports/?${stringifiedParams}` : `/api/v2/imports/`
}

export const importsList = async (params?: ImportsListParams, options?: RequestInit): Promise<importsListResponse> => {
  return fetchWithAuth<importsListResponse>(getImportsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getImportsListQueryKey = (params?: ImportsListParams) => {
  return ['api', 'v2', 'imports', ...(params ? [params] : [])] as const
}

export const getImportsListQueryOptions = <TData = Awaited<ReturnType<typeof importsList>>, TError = ErrorDetail>(
  params?: ImportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof importsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getImportsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof importsList>>> = ({ signal }) =>
    importsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof importsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ImportsListQueryResult = NonNullable<Awaited<ReturnType<typeof importsList>>>
export type ImportsListQueryError = ErrorDetail

export function useImportsList<TData = Awaited<ReturnType<typeof importsList>>, TError = ErrorDetail>(
  params?: ImportsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof importsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getImportsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Import file

_**Note**: this endpoint is expecting a multipart/form-data_

 */
export type importsCreateResponse201 = {
  data: ImportCreateResponse
  status: 201
}

export type importsCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type importsCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type importsCreateResponseComposite =
  | importsCreateResponse201
  | importsCreateResponse400
  | importsCreateResponse401

export type importsCreateResponse = importsCreateResponseComposite & {
  headers: Headers
}

export const getImportsCreateUrl = () => {
  return `/api/v2/imports/`
}

export const importsCreate = async (
  importCreateRequest: ImportCreateRequest,
  options?: RequestInit,
): Promise<importsCreateResponse> => {
  const formData = new FormData()
  formData.append(`destination`, importCreateRequest.destination)
  formData.append(`url`, importCreateRequest.url)
  if (importCreateRequest.name !== undefined) {
    formData.append(`name`, importCreateRequest.name)
  }
  formData.append(`assetUid`, importCreateRequest.assetUid)

  return fetchWithAuth<importsCreateResponse>(getImportsCreateUrl(), {
    ...options,
    method: 'POST',
    body: formData,
  })
}

export const getImportsCreateMutationOptions = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importsCreate>>,
    TError,
    { data: ImportCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof importsCreate>>, TError, { data: ImportCreateRequest }, TContext> => {
  const mutationKey = ['importsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof importsCreate>>, { data: ImportCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return importsCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof importsCreate>>>
export type ImportsCreateMutationBody = ImportCreateRequest
export type ImportsCreateMutationError = ErrorObject | ErrorDetail

export const useImportsCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importsCreate>>,
    TError,
    { data: ImportCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getImportsCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve imported files

 */
export type importsRetrieveResponse200 = {
  data: ImportResponse
  status: 200
}

export type importsRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type importsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type importsRetrieveResponseComposite =
  | importsRetrieveResponse200
  | importsRetrieveResponse401
  | importsRetrieveResponse404

export type importsRetrieveResponse = importsRetrieveResponseComposite & {
  headers: Headers
}

export const getImportsRetrieveUrl = (uidImport: string) => {
  return `/api/v2/imports/${uidImport}/`
}

export const importsRetrieve = async (uidImport: string, options?: RequestInit): Promise<importsRetrieveResponse> => {
  return fetchWithAuth<importsRetrieveResponse>(getImportsRetrieveUrl(uidImport), {
    ...options,
    method: 'GET',
  })
}

export const getImportsRetrieveQueryKey = (uidImport: string) => {
  return ['api', 'v2', 'imports', uidImport] as const
}

export const getImportsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof importsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidImport: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof importsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getImportsRetrieveQueryKey(uidImport)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof importsRetrieve>>> = ({ signal }) =>
    importsRetrieve(uidImport, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidImport, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof importsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ImportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof importsRetrieve>>>
export type ImportsRetrieveQueryError = ErrorDetail | ErrorObject

export function useImportsRetrieve<
  TData = Awaited<ReturnType<typeof importsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidImport: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof importsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getImportsRetrieveQueryOptions(uidImport, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List of invites

Invites sent or received by current user about transferring project ownership.

List can be filtered with `mode` parameter,  e.g.: display only received invites.

Possible values for `mode`:
- `sender`
- `recipient`


 */
export type projectOwnershipInvitesListResponse200 = {
  data: PaginatedProjectInviteResponseList
  status: 200
}

export type projectOwnershipInvitesListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectOwnershipInvitesListResponseComposite =
  | projectOwnershipInvitesListResponse200
  | projectOwnershipInvitesListResponse403

export type projectOwnershipInvitesListResponse = projectOwnershipInvitesListResponseComposite & {
  headers: Headers
}

export const getProjectOwnershipInvitesListUrl = (params?: ProjectOwnershipInvitesListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/project-ownership/invites/?${stringifiedParams}`
    : `/api/v2/project-ownership/invites/`
}

export const projectOwnershipInvitesList = async (
  params?: ProjectOwnershipInvitesListParams,
  options?: RequestInit,
): Promise<projectOwnershipInvitesListResponse> => {
  return fetchWithAuth<projectOwnershipInvitesListResponse>(getProjectOwnershipInvitesListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getProjectOwnershipInvitesListQueryKey = (params?: ProjectOwnershipInvitesListParams) => {
  return ['api', 'v2', 'project-ownership', 'invites', ...(params ? [params] : [])] as const
}

export const getProjectOwnershipInvitesListQueryOptions = <
  TData = Awaited<ReturnType<typeof projectOwnershipInvitesList>>,
  TError = ErrorDetail,
>(
  params?: ProjectOwnershipInvitesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectOwnershipInvitesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectOwnershipInvitesListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectOwnershipInvitesList>>> = ({ signal }) =>
    projectOwnershipInvitesList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectOwnershipInvitesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof projectOwnershipInvitesList>>
>
export type ProjectOwnershipInvitesListQueryError = ErrorDetail

export function useProjectOwnershipInvitesList<
  TData = Awaited<ReturnType<typeof projectOwnershipInvitesList>>,
  TError = ErrorDetail,
>(
  params?: ProjectOwnershipInvitesListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectOwnershipInvitesList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectOwnershipInvitesListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create (send) an invite

Where the assets `uid` are given in the payload's list



 */
export type projectOwnershipInvitesCreateResponse201 = {
  data: ProjectInviteResponse
  status: 201
}

export type projectOwnershipInvitesCreateResponse400 = {
  data: ErrorObject
  status: 400
}

export type projectOwnershipInvitesCreateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectOwnershipInvitesCreateResponseComposite =
  | projectOwnershipInvitesCreateResponse201
  | projectOwnershipInvitesCreateResponse400
  | projectOwnershipInvitesCreateResponse403

export type projectOwnershipInvitesCreateResponse = projectOwnershipInvitesCreateResponseComposite & {
  headers: Headers
}

export const getProjectOwnershipInvitesCreateUrl = () => {
  return `/api/v2/project-ownership/invites/`
}

export const projectOwnershipInvitesCreate = async (
  projectInviteCreatePayload: ProjectInviteCreatePayload,
  options?: RequestInit,
): Promise<projectOwnershipInvitesCreateResponse> => {
  return fetchWithAuth<projectOwnershipInvitesCreateResponse>(getProjectOwnershipInvitesCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(projectInviteCreatePayload),
  })
}

export const getProjectOwnershipInvitesCreateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesCreate>>,
    TError,
    { data: ProjectInviteCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof projectOwnershipInvitesCreate>>,
  TError,
  { data: ProjectInviteCreatePayload },
  TContext
> => {
  const mutationKey = ['projectOwnershipInvitesCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof projectOwnershipInvitesCreate>>,
    { data: ProjectInviteCreatePayload }
  > = (props) => {
    const { data } = props ?? {}

    return projectOwnershipInvitesCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProjectOwnershipInvitesCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof projectOwnershipInvitesCreate>>
>
export type ProjectOwnershipInvitesCreateMutationBody = ProjectInviteCreatePayload
export type ProjectOwnershipInvitesCreateMutationError = ErrorObject | ErrorDetail

export const useProjectOwnershipInvitesCreate = <TError = ErrorObject | ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesCreate>>,
    TError,
    { data: ProjectInviteCreatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getProjectOwnershipInvitesCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Retrieve transfer details

 */
export type projectOwnershipInvitesTransfersRetrieveResponse200 = {
  data: TransferListResponse
  status: 200
}

export type projectOwnershipInvitesTransfersRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type projectOwnershipInvitesTransfersRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type projectOwnershipInvitesTransfersRetrieveResponseComposite =
  | projectOwnershipInvitesTransfersRetrieveResponse200
  | projectOwnershipInvitesTransfersRetrieveResponse401
  | projectOwnershipInvitesTransfersRetrieveResponse404

export type projectOwnershipInvitesTransfersRetrieveResponse =
  projectOwnershipInvitesTransfersRetrieveResponseComposite & {
    headers: Headers
  }

export const getProjectOwnershipInvitesTransfersRetrieveUrl = (uidInviteUid: string, uidTransfer: string) => {
  return `/api/v2/project-ownership/invites/${uidInviteUid}/transfers/${uidTransfer}/`
}

export const projectOwnershipInvitesTransfersRetrieve = async (
  uidInviteUid: string,
  uidTransfer: string,
  options?: RequestInit,
): Promise<projectOwnershipInvitesTransfersRetrieveResponse> => {
  return fetchWithAuth<projectOwnershipInvitesTransfersRetrieveResponse>(
    getProjectOwnershipInvitesTransfersRetrieveUrl(uidInviteUid, uidTransfer),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getProjectOwnershipInvitesTransfersRetrieveQueryKey = (uidInviteUid: string, uidTransfer: string) => {
  return ['api', 'v2', 'project-ownership', 'invites', uidInviteUid, 'transfers', uidTransfer] as const
}

export const getProjectOwnershipInvitesTransfersRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectOwnershipInvitesTransfersRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidInviteUid: string,
  uidTransfer: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectOwnershipInvitesTransfersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getProjectOwnershipInvitesTransfersRetrieveQueryKey(uidInviteUid, uidTransfer)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectOwnershipInvitesTransfersRetrieve>>> = ({ signal }) =>
    projectOwnershipInvitesTransfersRetrieve(uidInviteUid, uidTransfer, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!(uidInviteUid && uidTransfer), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesTransfersRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectOwnershipInvitesTransfersRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof projectOwnershipInvitesTransfersRetrieve>>
>
export type ProjectOwnershipInvitesTransfersRetrieveQueryError = ErrorDetail | ErrorObject

export function useProjectOwnershipInvitesTransfersRetrieve<
  TData = Awaited<ReturnType<typeof projectOwnershipInvitesTransfersRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidInviteUid: string,
  uidTransfer: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectOwnershipInvitesTransfersRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectOwnershipInvitesTransfersRetrieveQueryOptions(uidInviteUid, uidTransfer, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Invite detail

It can be useful to monitor the invite status while the transfer is being processed

 */
export type projectOwnershipInvitesRetrieveResponse200 = {
  data: ProjectInviteResponse
  status: 200
}

export type projectOwnershipInvitesRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectOwnershipInvitesRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type projectOwnershipInvitesRetrieveResponseComposite =
  | projectOwnershipInvitesRetrieveResponse200
  | projectOwnershipInvitesRetrieveResponse403
  | projectOwnershipInvitesRetrieveResponse404

export type projectOwnershipInvitesRetrieveResponse = projectOwnershipInvitesRetrieveResponseComposite & {
  headers: Headers
}

export const getProjectOwnershipInvitesRetrieveUrl = (uidInvite: string) => {
  return `/api/v2/project-ownership/invites/${uidInvite}/`
}

export const projectOwnershipInvitesRetrieve = async (
  uidInvite: string,
  options?: RequestInit,
): Promise<projectOwnershipInvitesRetrieveResponse> => {
  return fetchWithAuth<projectOwnershipInvitesRetrieveResponse>(getProjectOwnershipInvitesRetrieveUrl(uidInvite), {
    ...options,
    method: 'GET',
  })
}

export const getProjectOwnershipInvitesRetrieveQueryKey = (uidInvite: string) => {
  return ['api', 'v2', 'project-ownership', 'invites', uidInvite] as const
}

export const getProjectOwnershipInvitesRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof projectOwnershipInvitesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidInvite: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectOwnershipInvitesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectOwnershipInvitesRetrieveQueryKey(uidInvite)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectOwnershipInvitesRetrieve>>> = ({ signal }) =>
    projectOwnershipInvitesRetrieve(uidInvite, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidInvite, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProjectOwnershipInvitesRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof projectOwnershipInvitesRetrieve>>
>
export type ProjectOwnershipInvitesRetrieveQueryError = ErrorDetail | ErrorObject

export function useProjectOwnershipInvitesRetrieve<
  TData = Awaited<ReturnType<typeof projectOwnershipInvitesRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  uidInvite: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof projectOwnershipInvitesRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProjectOwnershipInvitesRetrieveQueryOptions(uidInvite, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Update an invite status

Update the status of an invite.
Status accepted:
- `cancelled`
- `accepted`
- `declined`

**Notes**:
- _When submitting `accepted` the invite status becomes automatically `in_progress`_
- _Only the sender can cancel an invite, and **if only if** the invite is still pending._
- _Only the recipient can accept or decline, **if and only if** the invite is still pending._


 */
export type projectOwnershipInvitesPartialUpdateResponse200 = {
  data: ProjectInviteResponse
  status: 200
}

export type projectOwnershipInvitesPartialUpdateResponse400 = {
  data: ErrorObject
  status: 400
}

export type projectOwnershipInvitesPartialUpdateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectOwnershipInvitesPartialUpdateResponseComposite =
  | projectOwnershipInvitesPartialUpdateResponse200
  | projectOwnershipInvitesPartialUpdateResponse400
  | projectOwnershipInvitesPartialUpdateResponse403

export type projectOwnershipInvitesPartialUpdateResponse = projectOwnershipInvitesPartialUpdateResponseComposite & {
  headers: Headers
}

export const getProjectOwnershipInvitesPartialUpdateUrl = (uidInvite: string) => {
  return `/api/v2/project-ownership/invites/${uidInvite}/`
}

export const projectOwnershipInvitesPartialUpdate = async (
  uidInvite: string,
  patchedInviteUpdatePayload: PatchedInviteUpdatePayload,
  options?: RequestInit,
): Promise<projectOwnershipInvitesPartialUpdateResponse> => {
  return fetchWithAuth<projectOwnershipInvitesPartialUpdateResponse>(
    getProjectOwnershipInvitesPartialUpdateUrl(uidInvite),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchedInviteUpdatePayload),
    },
  )
}

export const getProjectOwnershipInvitesPartialUpdateMutationOptions = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesPartialUpdate>>,
    TError,
    { uidInvite: string; data: PatchedInviteUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof projectOwnershipInvitesPartialUpdate>>,
  TError,
  { uidInvite: string; data: PatchedInviteUpdatePayload },
  TContext
> => {
  const mutationKey = ['projectOwnershipInvitesPartialUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof projectOwnershipInvitesPartialUpdate>>,
    { uidInvite: string; data: PatchedInviteUpdatePayload }
  > = (props) => {
    const { uidInvite, data } = props ?? {}

    return projectOwnershipInvitesPartialUpdate(uidInvite, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProjectOwnershipInvitesPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof projectOwnershipInvitesPartialUpdate>>
>
export type ProjectOwnershipInvitesPartialUpdateMutationBody = PatchedInviteUpdatePayload
export type ProjectOwnershipInvitesPartialUpdateMutationError = ErrorObject | ErrorDetail

export const useProjectOwnershipInvitesPartialUpdate = <
  TError = ErrorObject | ErrorDetail,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesPartialUpdate>>,
    TError,
    { uidInvite: string; data: PatchedInviteUpdatePayload },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getProjectOwnershipInvitesPartialUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## Delete invite

 */
export type projectOwnershipInvitesDestroyResponse204 = {
  data: void
  status: 204
}

export type projectOwnershipInvitesDestroyResponse403 = {
  data: ErrorDetail
  status: 403
}

export type projectOwnershipInvitesDestroyResponse404 = {
  data: ErrorObject
  status: 404
}

export type projectOwnershipInvitesDestroyResponseComposite =
  | projectOwnershipInvitesDestroyResponse204
  | projectOwnershipInvitesDestroyResponse403
  | projectOwnershipInvitesDestroyResponse404

export type projectOwnershipInvitesDestroyResponse = projectOwnershipInvitesDestroyResponseComposite & {
  headers: Headers
}

export const getProjectOwnershipInvitesDestroyUrl = (uidInvite: string) => {
  return `/api/v2/project-ownership/invites/${uidInvite}/`
}

export const projectOwnershipInvitesDestroy = async (
  uidInvite: string,
  options?: RequestInit,
): Promise<projectOwnershipInvitesDestroyResponse> => {
  return fetchWithAuth<projectOwnershipInvitesDestroyResponse>(getProjectOwnershipInvitesDestroyUrl(uidInvite), {
    ...options,
    method: 'DELETE',
  })
}

export const getProjectOwnershipInvitesDestroyMutationOptions = <
  TError = ErrorDetail | ErrorObject,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesDestroy>>,
    TError,
    { uidInvite: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof projectOwnershipInvitesDestroy>>,
  TError,
  { uidInvite: string },
  TContext
> => {
  const mutationKey = ['projectOwnershipInvitesDestroy']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof projectOwnershipInvitesDestroy>>,
    { uidInvite: string }
  > = (props) => {
    const { uidInvite } = props ?? {}

    return projectOwnershipInvitesDestroy(uidInvite, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProjectOwnershipInvitesDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof projectOwnershipInvitesDestroy>>
>

export type ProjectOwnershipInvitesDestroyMutationError = ErrorDetail | ErrorObject

export const useProjectOwnershipInvitesDestroy = <TError = ErrorDetail | ErrorObject, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof projectOwnershipInvitesDestroy>>,
    TError,
    { uidInvite: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getProjectOwnershipInvitesDestroyMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List current user's assets' tags

 */
export type tagsListResponse200 = {
  data: PaginatedTagListResponseList
  status: 200
}

export type tagsListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type tagsListResponseComposite = tagsListResponse200 | tagsListResponse401

export type tagsListResponse = tagsListResponseComposite & {
  headers: Headers
}

export const getTagsListUrl = (params?: TagsListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/tags/?${stringifiedParams}` : `/api/v2/tags/`
}

export const tagsList = async (params?: TagsListParams, options?: RequestInit): Promise<tagsListResponse> => {
  return fetchWithAuth<tagsListResponse>(getTagsListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getTagsListQueryKey = (params?: TagsListParams) => {
  return ['api', 'v2', 'tags', ...(params ? [params] : [])] as const
}

export const getTagsListQueryOptions = <TData = Awaited<ReturnType<typeof tagsList>>, TError = ErrorDetail>(
  params?: TagsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTagsListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsList>>> = ({ signal }) =>
    tagsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tagsList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TagsListQueryResult = NonNullable<Awaited<ReturnType<typeof tagsList>>>
export type TagsListQueryError = ErrorDetail

export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = ErrorDetail>(
  params?: TagsListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTagsListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve a tag's data

 */
export type tagsRetrieveResponse200 = {
  data: TagRetrieveResponse
  status: 200
}

export type tagsRetrieveResponse401 = {
  data: ErrorDetail
  status: 401
}

export type tagsRetrieveResponse404 = {
  data: ErrorObject
  status: 404
}

export type tagsRetrieveResponseComposite = tagsRetrieveResponse200 | tagsRetrieveResponse401 | tagsRetrieveResponse404

export type tagsRetrieveResponse = tagsRetrieveResponseComposite & {
  headers: Headers
}

export const getTagsRetrieveUrl = (taguidUid: string) => {
  return `/api/v2/tags/${taguidUid}/`
}

export const tagsRetrieve = async (taguidUid: string, options?: RequestInit): Promise<tagsRetrieveResponse> => {
  return fetchWithAuth<tagsRetrieveResponse>(getTagsRetrieveUrl(taguidUid), {
    ...options,
    method: 'GET',
  })
}

export const getTagsRetrieveQueryKey = (taguidUid: string) => {
  return ['api', 'v2', 'tags', taguidUid] as const
}

export const getTagsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof tagsRetrieve>>,
  TError = ErrorDetail | ErrorObject,
>(
  taguidUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTagsRetrieveQueryKey(taguidUid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsRetrieve>>> = ({ signal }) =>
    tagsRetrieve(taguidUid, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!taguidUid, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tagsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type TagsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof tagsRetrieve>>>
export type TagsRetrieveQueryError = ErrorDetail | ErrorObject

export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = ErrorDetail | ErrorObject>(
  taguidUid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTagsRetrieveQueryOptions(taguidUid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
