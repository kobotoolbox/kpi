/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * KoboToolbox Primary API
 * This page documents all KoboToolbox API endpoints, except for those implementing the OpenRosa protocol, which are [documented separately](/api/openrosa/docs/).

The endpoints are grouped by area of intended use. Each category contains related endpoints, with detailed documentation on usage and configuration. Use this as a reference to quickly find the right endpoint for managing projects, forms, data, permissions, integrations, logs, and organizational resources.

**General note**: All projects (whether deployed or draft), as well as all library content (questions, blocks, templates, and collections) in the user-facing application are represented in the API as "assets".
 * OpenAPI spec version: 2.0.0 (api_v2)
 */

import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'

import type { AccessLogsMeListParams } from '../models/accessLogsMeListParams'

import type { AssetsHistoryListParams } from '../models/assetsHistoryListParams'

import type { ErrorDetail } from '../models/errorDetail'

import type { ExportCreateResponse } from '../models/exportCreateResponse'

import type { ExportListResponse } from '../models/exportListResponse'

import type { HistoryActionResponse } from '../models/historyActionResponse'

import type { HistoryExportResponse } from '../models/historyExportResponse'

import type { PaginatedAccessLogResponseList } from '../models/paginatedAccessLogResponseList'

import type { PaginatedHistoryListResponseList } from '../models/paginatedHistoryListResponseList'

import { fetchWithAuth } from '../orval.mutator'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ## List all access logs for the authenticated user

Submissions will be grouped together by hour

Results from this endpoint can be filtered by a boolean query specified in the `q` parameter.

**Filterable fields:**

* date_created
* metadata__source
* metadata__auth_type
* metadata__ip_address

**Some examples:**

* All logs from a specific IP address
    `api/v2/access-logs/?q=metadata__ip_address:"127.0.0.1"`
* All logs created after Jan, 1 2025
    `api/v2/access-logs/?q=date_created__date__gte:"2025-01-01"`

*Notes: Do not forget to wrap search terms in double-quotes if they contain spaces
(e.g. date and time "2022-11-15 20:34")*

 */
export type accessLogsMeListResponse200 = {
  data: PaginatedAccessLogResponseList
  status: 200
}

export type accessLogsMeListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsMeListResponseComposite = accessLogsMeListResponse200 | accessLogsMeListResponse401

export type accessLogsMeListResponse = accessLogsMeListResponseComposite & {
  headers: Headers
}

export const getAccessLogsMeListUrl = (params?: AccessLogsMeListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/api/v2/access-logs/me/?${stringifiedParams}` : `/api/v2/access-logs/me/`
}

export const accessLogsMeList = async (
  params?: AccessLogsMeListParams,
  options?: RequestInit,
): Promise<accessLogsMeListResponse> => {
  return fetchWithAuth<accessLogsMeListResponse>(getAccessLogsMeListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsMeListQueryKey = (params?: AccessLogsMeListParams) => {
  return ['api', 'v2', 'access-logs', 'me', ...(params ? [params] : [])] as const
}

export const getAccessLogsMeListQueryOptions = <
  TData = Awaited<ReturnType<typeof accessLogsMeList>>,
  TError = ErrorDetail,
>(
  params?: AccessLogsMeListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsMeListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsMeList>>> = ({ signal }) =>
    accessLogsMeList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsMeList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsMeListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsMeList>>>
export type AccessLogsMeListQueryError = ErrorDetail

export function useAccessLogsMeList<TData = Awaited<ReturnType<typeof accessLogsMeList>>, TError = ErrorDetail>(
  params?: AccessLogsMeListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsMeListQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## List all access logs export tasks for the authenticated user

 */
export type accessLogsMeExportListResponse200 = {
  data: ExportListResponse[]
  status: 200
}

export type accessLogsMeExportListResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsMeExportListResponseComposite =
  | accessLogsMeExportListResponse200
  | accessLogsMeExportListResponse401

export type accessLogsMeExportListResponse = accessLogsMeExportListResponseComposite & {
  headers: Headers
}

export const getAccessLogsMeExportListUrl = () => {
  return `/api/v2/access-logs/me/export/`
}

export const accessLogsMeExportList = async (options?: RequestInit): Promise<accessLogsMeExportListResponse> => {
  return fetchWithAuth<accessLogsMeExportListResponse>(getAccessLogsMeExportListUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getAccessLogsMeExportListQueryKey = () => {
  return ['api', 'v2', 'access-logs', 'me', 'export'] as const
}

export const getAccessLogsMeExportListQueryOptions = <
  TData = Awaited<ReturnType<typeof accessLogsMeExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccessLogsMeExportListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accessLogsMeExportList>>> = ({ signal }) =>
    accessLogsMeExportList({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof accessLogsMeExportList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AccessLogsMeExportListQueryResult = NonNullable<Awaited<ReturnType<typeof accessLogsMeExportList>>>
export type AccessLogsMeExportListQueryError = ErrorDetail

export function useAccessLogsMeExportList<
  TData = Awaited<ReturnType<typeof accessLogsMeExportList>>,
  TError = ErrorDetail,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof accessLogsMeExportList>>, TError, TData>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAccessLogsMeExportListQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Create an export task for the authenticated user

 */
export type accessLogsMeExportCreateResponse202 = {
  data: ExportCreateResponse
  status: 202
}

export type accessLogsMeExportCreateResponse401 = {
  data: ErrorDetail
  status: 401
}

export type accessLogsMeExportCreateResponseComposite =
  | accessLogsMeExportCreateResponse202
  | accessLogsMeExportCreateResponse401

export type accessLogsMeExportCreateResponse = accessLogsMeExportCreateResponseComposite & {
  headers: Headers
}

export const getAccessLogsMeExportCreateUrl = () => {
  return `/api/v2/access-logs/me/export/`
}

export const accessLogsMeExportCreate = async (options?: RequestInit): Promise<accessLogsMeExportCreateResponse> => {
  return fetchWithAuth<accessLogsMeExportCreateResponse>(getAccessLogsMeExportCreateUrl(), {
    ...options,
    method: 'POST',
  })
}

export const getAccessLogsMeExportCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, TError, void, TContext> => {
  const mutationKey = ['accessLogsMeExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, void> = () => {
    return accessLogsMeExportCreate(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AccessLogsMeExportCreateMutationResult = NonNullable<Awaited<ReturnType<typeof accessLogsMeExportCreate>>>

export type AccessLogsMeExportCreateMutationError = ErrorDetail

export const useAccessLogsMeExportCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof accessLogsMeExportCreate>>, TError, void, TContext>
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAccessLogsMeExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * ## List project history logs

Lists all project history logs for a single project.

‚ö†Ô∏è _Required permissions: `manage_asset` (Manage project)_

Results from this endpoint can be filtered by a Boolean query specified in the `q` parameter.

### Filterable fields for all project history logs:

  - date_created
  - user_uid
  - user__username
  - user__email
  - user__is_superuser
  - metadata__source
  - metadata__ip_address
  - metadata__log_subtype
    - available subtypes: "project", "permission"

### action

available actions:
  - add-media
  - add-submission
  - allow-anonymous-submissions
  - archive
  - clone-permissions
  - connect-project
  - delete-media
  - delete-service
  - delete-submission
  - deploy
  - disable-sharing
  - disallow-anonymous-submissions
  - disconnect-project
  - enable-sharing
  - export
  - modify-imported-fields
  - modify-qa-data
  - modify-service
  - modify-sharing
  - modify-submission
  - modify-user-permissions
  - redeploy
   - register-service
  - replace-form
  - share-data-publicly
  - share-form-publicly
  - transfer
  - unarchive
  - unshare-data-publicly
  - unshare-form-publicly
  - update-content
  - update-name
  - update-settings
  - update-qa

### Filterable fields by action:

  add-media
  - metadata__asset-file__uid
  - metadata__asset-file__filename

  add-submission
  - metadata__submission__submitted_by
  - metadata__submission__root_uuid

  archive
  - metadata__latest_version_uid

  clone-permissions
  - metadata__cloned_from

  connect-project
  - metadata__paired-data__source_uid
  - metadata__paired-data__source_name

  delete-media
  - metadata__asset-file__uid
  - metadata__asset-file__filename

  delete-service
  - metadata__hook__uid
  - metadata__hook__endpoint
  - metadata__hook__active

  delete-submission
  - metadata__submission__submitted_by
  - metadata__submission__root_uuid

  deploy
  - metadata__latest_version_uid
  - metadata__latest_deployed_version_uid

  disconnect-project
  - metadata__paired-data__source_uid
  - metadata__paired-data__source_name

  modify-imported-fields
  - metadata__paired-data__source_uid
  - metadata__paired-data__source_name

  modify-qa-data
  - metadata__submission__submitted_by
  - metadata__submission__root_uuid

  modify-service
  - metadata__hook__uid
  - metadata__hook__endpoint
  - metadata__hook__active

  modify-submission
  - metadata__submission__submitted_by
  - metadata__submission__root_uuid
  - metadata__submission__status (only present if changed)

  modify-user-permissions
  - metadata__permissions__username

  redeploy
  - metadata__latest_version_uid
  - metadata__latest_deployed_version_uid

  register-service
  - metadata__hook__uid
  - metadata__hook__endpoint
  - metadata__hook__active

  transfer
  - metadata__username

  unarchive
  - metadata__latest_version_uid

  update-name
  - metadata__name__old
  - metadata__name__new

  update-settings
  - metadata__settings__description__old
  - metadata__settings__description__new

This endpoint can be paginated with 'offset' and 'limit' parameters.

 */
export type assetsHistoryListResponse200 = {
  data: PaginatedHistoryListResponseList
  status: 200
}

export type assetsHistoryListResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHistoryListResponseComposite = assetsHistoryListResponse200 | assetsHistoryListResponse403

export type assetsHistoryListResponse = assetsHistoryListResponseComposite & {
  headers: Headers
}

export const getAssetsHistoryListUrl = (uidAsset: string, params?: AssetsHistoryListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v2/assets/${uidAsset}/history/?${stringifiedParams}`
    : `/api/v2/assets/${uidAsset}/history/`
}

export const assetsHistoryList = async (
  uidAsset: string,
  params?: AssetsHistoryListParams,
  options?: RequestInit,
): Promise<assetsHistoryListResponse> => {
  return fetchWithAuth<assetsHistoryListResponse>(getAssetsHistoryListUrl(uidAsset, params), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHistoryListQueryKey = (uidAsset: string, params?: AssetsHistoryListParams) => {
  return ['api', 'v2', 'assets', uidAsset, 'history', ...(params ? [params] : [])] as const
}

export const getAssetsHistoryListQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHistoryList>>,
  TError = ErrorDetail,
>(
  uidAsset: string,
  params?: AssetsHistoryListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHistoryList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHistoryListQueryKey(uidAsset, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHistoryList>>> = ({ signal }) =>
    assetsHistoryList(uidAsset, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHistoryList>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHistoryListQueryResult = NonNullable<Awaited<ReturnType<typeof assetsHistoryList>>>
export type AssetsHistoryListQueryError = ErrorDetail

export function useAssetsHistoryList<TData = Awaited<ReturnType<typeof assetsHistoryList>>, TError = ErrorDetail>(
  uidAsset: string,
  params?: AssetsHistoryListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHistoryList>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHistoryListQueryOptions(uidAsset, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Retrieve distinct actions performed on the project.

 */
export type assetsHistoryActionsRetrieveResponse200 = {
  data: HistoryActionResponse
  status: 200
}

export type assetsHistoryActionsRetrieveResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHistoryActionsRetrieveResponseComposite =
  | assetsHistoryActionsRetrieveResponse200
  | assetsHistoryActionsRetrieveResponse403

export type assetsHistoryActionsRetrieveResponse = assetsHistoryActionsRetrieveResponseComposite & {
  headers: Headers
}

export const getAssetsHistoryActionsRetrieveUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/history/actions/`
}

export const assetsHistoryActionsRetrieve = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsHistoryActionsRetrieveResponse> => {
  return fetchWithAuth<assetsHistoryActionsRetrieveResponse>(getAssetsHistoryActionsRetrieveUrl(uidAsset), {
    ...options,
    method: 'GET',
  })
}

export const getAssetsHistoryActionsRetrieveQueryKey = (uidAsset: string) => {
  return ['api', 'v2', 'assets', uidAsset, 'history', 'actions'] as const
}

export const getAssetsHistoryActionsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsHistoryActionsRetrieve>>,
  TError = ErrorDetail,
>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHistoryActionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAssetsHistoryActionsRetrieveQueryKey(uidAsset)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof assetsHistoryActionsRetrieve>>> = ({ signal }) =>
    assetsHistoryActionsRetrieve(uidAsset, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!uidAsset, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsHistoryActionsRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AssetsHistoryActionsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsHistoryActionsRetrieve>>
>
export type AssetsHistoryActionsRetrieveQueryError = ErrorDetail

export function useAssetsHistoryActionsRetrieve<
  TData = Awaited<ReturnType<typeof assetsHistoryActionsRetrieve>>,
  TError = ErrorDetail,
>(
  uidAsset: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof assetsHistoryActionsRetrieve>>, TError, TData>
    request?: SecondParameter<typeof fetchWithAuth>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAssetsHistoryActionsRetrieveQueryOptions(uidAsset, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ## Export current project's history

Exports the project's history and sends it by email to the requesting user.

 */
export type assetsHistoryExportCreateResponse202 = {
  data: HistoryExportResponse
  status: 202
}

export type assetsHistoryExportCreateResponse403 = {
  data: ErrorDetail
  status: 403
}

export type assetsHistoryExportCreateResponseComposite =
  | assetsHistoryExportCreateResponse202
  | assetsHistoryExportCreateResponse403

export type assetsHistoryExportCreateResponse = assetsHistoryExportCreateResponseComposite & {
  headers: Headers
}

export const getAssetsHistoryExportCreateUrl = (uidAsset: string) => {
  return `/api/v2/assets/${uidAsset}/history/export/`
}

export const assetsHistoryExportCreate = async (
  uidAsset: string,
  options?: RequestInit,
): Promise<assetsHistoryExportCreateResponse> => {
  return fetchWithAuth<assetsHistoryExportCreateResponse>(getAssetsHistoryExportCreateUrl(uidAsset), {
    ...options,
    method: 'POST',
  })
}

export const getAssetsHistoryExportCreateMutationOptions = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHistoryExportCreate>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsHistoryExportCreate>>,
  TError,
  { uidAsset: string },
  TContext
> => {
  const mutationKey = ['assetsHistoryExportCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof assetsHistoryExportCreate>>, { uidAsset: string }> = (
    props,
  ) => {
    const { uidAsset } = props ?? {}

    return assetsHistoryExportCreate(uidAsset, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssetsHistoryExportCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assetsHistoryExportCreate>>>

export type AssetsHistoryExportCreateMutationError = ErrorDetail

export const useAssetsHistoryExportCreate = <TError = ErrorDetail, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsHistoryExportCreate>>,
    TError,
    { uidAsset: string },
    TContext
  >
  request?: SecondParameter<typeof fetchWithAuth>
}) => {
  const mutationOptions = getAssetsHistoryExportCreateMutationOptions(options)

  return useMutation(mutationOptions)
}
